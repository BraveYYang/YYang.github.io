<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言链表学习</title>
    <link href="/YYang.github.io/2024/08/06/Work%20No.16/"/>
    <url>/YYang.github.io/2024/08/06/Work%20No.16/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言链表学习"><a href="#C语言链表学习" class="headerlink" title="C语言链表学习"></a>C语言链表学习</h1><h3 id="感谢博主："><a href="#感谢博主：" class="headerlink" title="感谢博主："></a>感谢博主：</h3><p><a href="https://blog.csdn.net/qq_35664104/article/details/120769681">数据结构–链表入门超详细解析(简单易懂纯原篇)_链表教学-CSDN博客</a></p><h3 id="链表基础知识"><a href="#链表基础知识" class="headerlink" title="链表基础知识"></a>链表基础知识</h3><p>链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点</p><p>链表都有一个头指针，一般以head来表示，存放的是一个地址。</p><p>链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。</p><p>链表中每个节点都分为两部分，一个数据域，一个是指针域。</p><p>head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。</p><h2 id="链表初始化"><a href="#链表初始化" class="headerlink" title="链表初始化"></a>链表初始化</h2><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lint</span>&#123; <span class="hljs-comment">//每一个节点其实就是一个结构体，将每个结构体用节点地址关联的方式，进行链接</span><br><span class="hljs-type">int</span> score; <span class="hljs-comment">//数据域，用于存放数据的位置</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lint</span>* next; <span class="hljs-comment">//指针域，定义指向下一个节点地址的指针</span><br>&#125; LinkList;<br></code></pre></td></tr></table></figure><p>采用typedef的方式，能够不用每次使用struct student  a，直接LinkList a的方式对a进行定义</p><p>链表中有一个特殊的结点–头结点。头结点的数据域一般不用来存放和其他节点同类的数据，它的诞生是为了在实际应用过程中存放一些数据+</p><p>*<strong>p代表这个地址上面的值，p代表这个地址，a[]代表这个地址上面的值，a代表这个数组的地址</strong></p><h4 id="无头结点的初始化"><a href="#无头结点的初始化" class="headerlink" title="无头结点的初始化"></a>无头结点的初始化</h4><p>直接从数据节点开始，直接定义第一个数据节点的值和下一个节点的地址</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">Lint * initLint()<br>&#123;<br>    <span class="hljs-comment">// 创建头指针</span><br>    Lint* p = NULL;<br>    <br>  <span class="hljs-comment">// 创建一个临时指针初始化首元结点，并且用于移动和调整后续结点</span><br>Lint* temp = (Lint*)malloc(sizeof(Lint));<span class="hljs-comment">//创建一个结构体，并分配内存空间</span><br>  <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>score = <span class="hljs-number">90</span>;<span class="hljs-comment">//将数据填入数据域当中</span><br>  <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>next = NULL;<span class="hljs-comment">//下一节点地址指向NULL</span><br>  <br>  <span class="hljs-comment">// 头指针需要指向首元结点，这样才能定位这串链表的位置</span><br>  p = temp;<br>  <br>  <span class="hljs-comment">// 手动创建10个元素</span><br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>    &#123;<br>        <span class="hljs-comment">// 从第二个结点开始创建</span><br>        Lint * a = (Lint*) malloc(sizeof(Lint));<br>        <span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>score = i + <span class="hljs-number">91</span>;<br>        <span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>next = NULL;<br>        <br>        <span class="hljs-comment">// 将当前temp指向的结点的next指向下一个结点</span><br>        <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = a; //temp-&gt;</span>next这个的意思是在temp中有一个next地址，将他指向a的地址<br>        <br>        <span class="hljs-comment">// temp移到下一个结点。这样在下次循环运行到上一行(line17)时能持续</span><br>        <span class="hljs-function"><span class="hljs-title">temp</span> = temp-&gt;</span>next;  <span class="hljs-comment">// 或 temp = a;</span><br>    &#125;<br>    return p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有头节点的初始化"><a href="#有头节点的初始化" class="headerlink" title="有头节点的初始化"></a>有头节点的初始化</h4><p>首先定义一个头结点，头结点没有数据域，只有地址域，直接赋值地址域</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">Lint * initLint()<br>&#123;<br>    <span class="hljs-comment">// 创建头指针，并用其创建头结点</span><br>    Lint * p = (Lint*)malloc(sizeof (Lint));<br>    <span class="hljs-comment">// 及时指定指针的指向以确保指针安全</span><br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>next = NULL;<br>    <span class="hljs-comment">// 创建一个临时的指针指向头结点以进行后续的操作</span><br>    Lint * temp = p;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-comment">// 从首元结点开始创建</span><br>        Lint * a = (Lint*) malloc(sizeof(Lint));<br>        <span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>score = i + <span class="hljs-number">90</span>;<br>        <span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>next = NULL;<br>        <span class="hljs-comment">// 将当前temp指向的next指向下一个结点</span><br>        <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>next = a;<br>        <span class="hljs-comment">// temp移到下一个结点</span><br>        <span class="hljs-function"><span class="hljs-title">temp</span> = temp-&gt;</span>next;  <span class="hljs-comment">// 或 temp = a;</span><br>    &#125;<br>    return p;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表数据改变"><a href="#链表数据改变" class="headerlink" title="链表数据改变"></a>链表数据改变</h2><h4 id="输出链表"><a href="#输出链表" class="headerlink" title="输出链表"></a>输出链表</h4><p>输出链表其实就是在遍历结构体中的地址域，到达该地址域之后，将其打印出来，然后再跳转指向下一个地址域</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">void showLint(Lint* p)&#123;<br>  <span class="hljs-regexp">//</span> 一开始p指针在头结点，这个数据域是空的，因此需要检测其指针域中是否有下一个节点的地址。如果为空，则退出循环<br>    <span class="hljs-keyword">while</span> (p-&gt;<span class="hljs-keyword">next</span>)&#123;<br>      <span class="hljs-regexp">//</span> p从头结点移出，到首元结点开始输出<br>        p = p-&gt;<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>\t&quot;</span>, p-&gt;score);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h4><p>增加结点的逻辑是：将新增结点的指针域指向后一个结点，然后将原链表中的前一个结点的指针域指向新增的结点。(<strong>注意顺序不能颠倒，否则会导致插入位置后面的结点全部丢失</strong>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Lint* <span class="hljs-title">insertLint</span><span class="hljs-params">(Lint* p,<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> num)</span></span>&#123;<span class="hljs-comment">// 将num插入到第n个位置</span><br>    Lint * temp = p;<br>    <span class="hljs-comment">// 通过遍历将temp指针移到指向插入位置的直接前驱结点的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-comment">// 防止超过链表现有长度</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置错误!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 创建插入的新结点</span><br>    Lint * a = (Lint*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (Lint));<br>    a-&gt;score = num;<br>  <span class="hljs-comment">// 新节点数据域指向原位置后一个结点</span><br>    a-&gt;next = temp-&gt;next;<br>  <span class="hljs-comment">// temp后移一个结点</span><br>    temp-&gt;next = a;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//main函数输出</span><br>    <span class="hljs-type">int</span> n, num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入插入的位置和数字，用空格隔开:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;num);<br>    <span class="hljs-built_in">insertLint</span>(p, n, num);<br>    <span class="hljs-built_in">showLint</span>(p);<br></code></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>删除链表数据的意思其实也是先找到想要删除的地址域，从节点中一个一个往下遍历，比如想删除第五个节点，那就遍历到第四个节点，然后在第四个节点的地址域上直接指向到第五节点的地址域，这样，第五个节点的地址就在第四个节点上丢失，从而第四个节点地址域获取的就是第六个节点的地址</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Lint* delLint(Lint* p,<span class="hljs-keyword">int</span> n)&#123;<br>    Lint * temp = p;<br>    <span class="hljs-comment">// 用于存储临时删除的结点</span><br>    Lint * back = <span class="hljs-keyword">NULL</span>;<br>    <span class="hljs-comment">// temp移到删除结点的前一个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-comment">// 防止越过链表</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;<span class="hljs-keyword">next</span> == <span class="hljs-keyword">NULL</span>)&#123;<br>            printf(<span class="hljs-string">&quot;位置错误!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-comment">//逐个跳转地址域</span><br>        temp = temp-&gt;<span class="hljs-keyword">next</span>;<br>    &#125;<br>    <span class="hljs-comment">// 临时存储被删除结点,防止丢失</span><br>    back = temp-&gt;<span class="hljs-keyword">next</span>;<br>  <span class="hljs-comment">// 指向下下个结点</span><br>    temp-&gt;<span class="hljs-keyword">next</span> = temp-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>;<br>    <span class="hljs-comment">// 手动释放内存防止泄露</span><br>    free(back);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//main函数输出</span><br>    printf(<span class="hljs-string">&quot;请输入删除第几个元素:&quot;</span>);<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    delLint(p, n);<br>    showLint(p);<br></code></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>修改数据其实跟上面的一样，指到这个数据域之后，直接对其数据进行修改即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Lint* <span class="hljs-title">changeLint</span><span class="hljs-params">(Lint* p,<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> num)</span></span>&#123;  <br><span class="hljs-comment">// temp可以一开始就指向首元结点    </span><br>Lint * temp = p-&gt;next;    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)&#123;        <br><span class="hljs-comment">// 防止越过链表        </span><br><span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>)&#123;            <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置错误!\n&quot;</span>);            <br><span class="hljs-keyword">return</span> p;        <br>&#125;        <br>temp = temp-&gt;next;    <br>&#125;    <br><span class="hljs-comment">// 修改    </span><br>temp-&gt;score = num;    <br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//main函数输出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入修改第几个元素为什么数,空格隔开:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;num);<br>    <span class="hljs-built_in">changeLint</span>(p, n, num);<br>    <span class="hljs-built_in">showLint</span>(p);<br></code></pre></td></tr></table></figure><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><p>查的基本思想是指针进行遍历链表，对每个节点的数据域进行对比，如果相同就可以直接退出返回结果了。如果一直到链表结束还没有匹配成功就说明没有找到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchLint</span><span class="hljs-params">(Lint* p, <span class="hljs-type">int</span> num)</span></span>&#123;<br>    Lint * temp = p;<br>    <span class="hljs-type">int</span> i;  <span class="hljs-comment">// 用于记数</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;temp-&gt;next != <span class="hljs-literal">NULL</span>;i++)&#123;<br>      <span class="hljs-comment">// 因为是从头结点开始的，因此要先移到首元结点</span><br>        temp = temp-&gt;next;<br>        <span class="hljs-keyword">if</span> (temp-&gt;score == num)<span class="hljs-keyword">return</span> i;<span class="hljs-comment">// 返回i表示找到的位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 返回0表示未找到</span><br>&#125;<br><br><span class="hljs-comment">//main函数输出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入需要查询的分数:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">searchLint</span>(p, num))<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未查询到该分数&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在第%d个元素&quot;</span>, <span class="hljs-built_in">searchLint</span>(p, num));<br></code></pre></td></tr></table></figure><p>如果你的头结点直接在数据域上面标记是1，那可以直接利用数据域的数据进行查找数据</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">int searchLint(Lint* p, int num)&#123;<br>    Lint * temp = p;<br>    <span class="hljs-function"><span class="hljs-title">for</span>(p-&gt;</span><span class="hljs-function"><span class="hljs-title">score</span> = 1;temp-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> != NULL;p-&gt;</span>score++)&#123;<br>        <span class="hljs-function"><span class="hljs-title">temp</span> = temp-&gt;</span>next;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (temp-&gt;</span><span class="hljs-function"><span class="hljs-title">score</span> == num)return p-&gt;</span>score;<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言数组学习</title>
    <link href="/YYang.github.io/2024/08/05/Work%20No.14/"/>
    <url>/YYang.github.io/2024/08/05/Work%20No.14/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言数组学习"><a href="#C语言数组学习" class="headerlink" title="C语言数组学习"></a>C语言数组学习</h1><h3 id="感谢博主："><a href="#感谢博主：" class="headerlink" title="感谢博主："></a>感谢博主：</h3><p><a href="https://blog.csdn.net/wkd_007/article/details/134400060">【C语言 | 数组】C语言数组详解(经典，超详细)-CSDN博客</a></p><p><a href="https://www.runoob.com/cprogramming/c-arrays.html">C 数组 | 菜鸟教程 (runoob.com)</a></p><h3 id="计算机基础单位和数据类型"><a href="#计算机基础单位和数据类型" class="headerlink" title="计算机基础单位和数据类型"></a>计算机基础单位和数据类型</h3><p>其中在C语言中的一些特定的数据类型存储也是有一定的范围的：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> <span class="hljs-keyword">char</span> <span class="hljs-comment">-------- 1字节</span><br><span class="hljs-number">2.</span> <span class="hljs-keyword">short</span> <span class="hljs-comment">--------- 2字节</span><br><span class="hljs-number">3.</span> int <span class="hljs-comment">-------- 4字节   </span><br><span class="hljs-number">4.</span> <span class="hljs-keyword">long</span> <span class="hljs-comment">---------- 4字节</span><br><span class="hljs-number">5.</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-comment">-------- 8字节</span><br><span class="hljs-number">6.</span> float <span class="hljs-comment">---------- 4字节</span><br></code></pre></td></tr></table></figure><h3 id="数组的储存空间大小和位置"><a href="#数组的储存空间大小和位置" class="headerlink" title="数组的储存空间大小和位置"></a>数组的储存空间大小和位置</h3><p>数组的储存空间定义上也和数据类型有关，比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>那么，这个数组的数据类型是整数型，一共有五个整数型，所以总占空间为20字节</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>这个字符型所占总空间为5字节</p><p>二维数组的地址其实也是连续性的，就比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-attribute">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><p>这两种的类型和输出结果都是一致的，第一种定义方法采用{}将行进行隔开，更加清晰明了，而且，如果这个行一共需要3个数据，但是我只定义1个数据，这种写法是符合的，第二种就不符合，第二种的写法是因为二维数组的地址也是连续的，所以第一行结束之后自动承接第二行的第一个数据</p><p>当然也可以直接查看他们的地址输出，可以发现地址都是占用四个字节</p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">int arr[2][3] = </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml"></span><br><span class="language-xml">for(int i=0;i&lt;2;i++)</span><br><span class="language-xml">&#123;</span><br><span class="language-xml">for(int j=0;j&lt;3;j++)</span><br><span class="language-xml">&#123;</span><br><span class="language-xml">printf(&quot;%p&quot;,&amp;arr[i][j]);</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml"></span><br><span class="language-xml">//output</span><br><span class="language-xml">    000000000061FE00</span><br><span class="language-xml">    000000000061FE04</span><br><span class="language-xml">    000000000061FE08</span><br><span class="language-xml">    000000000061FE0C</span><br><span class="language-xml">    000000000061FE10</span><br><span class="language-xml">    000000000061FE14</span><br></code></pre></td></tr></table></figure><p>C语言中，在定义数组时，都需要明确的给出数组元素个数。如果要查询数组的大小，可以采用这种方式进行计算</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> arr[<span class="hljs-number">6</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><span class="hljs-comment">//数组的大小：sizeof（数组名）/sizeof（数据类型）</span><br><span class="hljs-built_in">int</span> ret = <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>其中sizeof的使用上也是有区分的</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">sizeof</span>(arr);<span class="hljs-comment">//这个是输出整个数组的大小</span><br><span class="hljs-built_in">sizeof</span>(&amp;arr);<span class="hljs-comment">//这个是输出首地址的大小</span><br><span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);<span class="hljs-comment">//这个是输出首地址的大小</span><br></code></pre></td></tr></table></figure><h3 id="数组定义类型"><a href="#数组定义类型" class="headerlink" title="数组定义类型"></a>数组定义类型</h3><p>如果要定义类似这种数组，那么hello占数组的五个数据还是只是一个数据呢</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char str[] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>我们可以将str的字符进行逐个输出可以发现，我们定义一整串字符串的时候，系统会自动帮我们拆分整个字符串，然后判断这个数组的大小</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> ret = sizeof(<span class="hljs-built_in">str</span>)/sizeof(<span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;ret;k++)<br>&#123;<br>    printf(<span class="hljs-string">&quot;str[%d]=%c\n&quot;</span>,k,<span class="hljs-built_in">str</span>[k]);<br>&#125;<br>    <br><span class="hljs-comment">//output</span><br>    <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>]=H<br>    <span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>]=e<br>    <span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>]=l<br>    <span class="hljs-built_in">str</span>[<span class="hljs-number">3</span>]=l<br>    <span class="hljs-built_in">str</span>[<span class="hljs-number">4</span>]=o<br>    <span class="hljs-built_in">str</span>[<span class="hljs-number">5</span>]=<span class="hljs-string">&quot;\0&quot;</span><span class="hljs-comment">//空字符</span><br></code></pre></td></tr></table></figure><p><strong>数组中必须有元素，不可能为0个元素个数。</strong></p><p><strong>数组里的元素必须相同，不可能出现两种不同类型的元素，如不能同时出现int和char。</strong></p><p>数组的定义分为完全初始化和不完全初始化，完全初始化就是将数据值定义和数组长度相匹配，定义了数组是五个整数型，那填充的也是五个整数型，不完全初始化就是我定义了数据是五个整数型，但是我只填充了三个整数型，那么剩下的两个整数型都是空值，系统默认为0，后续我们可以在往里面写数值</p><p>数组的指定输出可以直接用数组名+[数组位置]，二维数组也是类似，地址也是类似</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arr[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">int</span> arr1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,arr[<span class="hljs-number">1</span>]);//输出是<span class="hljs-number">2</span><br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,arr1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);//输出是<span class="hljs-number">4</span><br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;arr[<span class="hljs-number">1</span>]);//输出是<span class="hljs-number">000000000061</span>FE04<br></code></pre></td></tr></table></figure><h3 id="指针和数组的区别"><a href="#指针和数组的区别" class="headerlink" title="指针和数组的区别"></a>指针和数组的区别</h3><p><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</p><p><strong>指针</strong>：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</p><p><strong>数组</strong>：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。数组的存储空间，不是在静态区就是在栈上。</p><p><strong>指针</strong>：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p><h4 id="数组传参时，会退化为指针"><a href="#数组传参时，会退化为指针" class="headerlink" title="数组传参时，会退化为指针"></a>数组传参时，会退化为指针</h4><p>退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。</p><p>因此，C语言将数组的传参进行了退化。将整个数组拷贝一份传入函数时，将数组名看做常量指针，传数组首元素的地址。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-built_in">int</span> *p = arr;<br>    <span class="hljs-built_in">int</span> sz = <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">//一级指针p，传给函数</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;sz; i++)<br>    &#123;<br>       printf(<span class="hljs-string">&quot;%d\n&quot;</span>, *(p+i));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言结构体学习</title>
    <link href="/YYang.github.io/2024/08/05/Work%20No.15/"/>
    <url>/YYang.github.io/2024/08/05/Work%20No.15/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言结构体学习"><a href="#C语言结构体学习" class="headerlink" title="C语言结构体学习"></a>C语言结构体学习</h1><h3 id="感谢博主："><a href="#感谢博主：" class="headerlink" title="感谢博主："></a>感谢博主：</h3><p><a href="https://blog.csdn.net/yourfriendyo/article/details/119544221">C语言详解：结构体_c语言结构体语法-CSDN博客</a></p><p><a href="https://blog.csdn.net/lyh290188/article/details/104326450">C语言结构体（struct）最全的讲解（万字干货）_struct a *b(const char *name)-CSDN博客</a></p><h3 id="结构体理论知识"><a href="#结构体理论知识" class="headerlink" title="结构体理论知识"></a>结构体理论知识</h3><p>结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。</p><p>研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。</p><p><strong>结构体的大小不是结构体元素单纯相加就行的</strong>，因为我们现在主流的计算机使用的都是32Bit字长的CPU，<strong>对这类型的CPU取4个字节的数要比取一个字节要高效</strong>，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是<strong>内存对齐</strong>的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。<strong>程序员可以通过预编译命令#pragmapack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>&#123;<br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> c2<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span><br>&#123;<br><span class="hljs-type">char</span> c1;<br><span class="hljs-type">char</span> c2;<br><span class="hljs-type">int</span> i;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>S1</code>和<code>S2</code>类型的成员一样，但是<code>S1</code>和<code>S2</code>所占用的空间不一样，<code>S2</code>相较于<code>S1</code>所占空间较小。</p><p><strong>所以，让占用空间小的成员尽量集中在一起，这样会使整个内存空间变小</strong></p><p>在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。</p><p>在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。</p><p>在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。</p><h3 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h3><p>使用匿名结构体类型创建变量就<strong>只能在变量列表中创建，而且只能一次</strong>，不能在<code>main()</code>函数中创建变量了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//匿名结构体类型，不完全声明</span><br><span class="hljs-keyword">struct</span><br>&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">double</span> d;<br>&#125;s1,s2;<span class="hljs-comment">//匿名结构体类型创建变量的唯一方式，就是在变量列表中创建</span><br></code></pre></td></tr></table></figure><p>首先使用关键字struct，它表示接下来是一个结构体。在结构体声明中，struct book所起到的作用就像int等基础数据类型名作用一样。</p><p>后面是一个可选的标志（student），它是用来引用该结构体的快速标记。</p><p>接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；</p><p>在结束花括号后的分号表示结构体设计定义的结束</p><p>封号后面额外添加使用字符例如CXSW，这个变量就包含了其student结构体中的所有元素</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">tag</span> &#123;<span class="hljs-comment">//tag 是结构体标签。</span><br>    <span class="hljs-keyword">member</span><span class="hljs-operator">-</span>list<span class="hljs-comment">//member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。</span><br>    <span class="hljs-keyword">member</span><span class="hljs-operator">-</span>list<br>    <span class="hljs-keyword">member</span><span class="hljs-operator">-</span>list  <br>    <span class="hljs-operator">...</span><br>&#125; variable<span class="hljs-operator">-</span>list ;<span class="hljs-comment">//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</span><br><br><span class="hljs-keyword">struct</span> tag variable<span class="hljs-operator">-</span>list;<span class="hljs-comment">//等效于上面定义</span><br></code></pre></td></tr></table></figure><h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h3><p>结构体变量的<strong>初始化</strong>有2种方式，但是也有区别：</p><p>在结构体变量的创建时，用<code>&#123;&#125;</code>进行初始化。此时必须严格按声明中成员变量的顺序来初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stu</span><br>&#123;<br> <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<span class="hljs-comment">//名字</span><br> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br> <span class="hljs-type">char</span> sex[<span class="hljs-number">5</span>];<span class="hljs-comment">//性别</span><br> <span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<span class="hljs-comment">//学号</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stu</span> s = &#123; <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;20230818001&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>或者在结构体后直接定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Books</span><br>&#123;<br>   <span class="hljs-type">char</span>  title[<span class="hljs-number">50</span>];<br>   <span class="hljs-type">char</span>  author[<span class="hljs-number">50</span>];<br>   <span class="hljs-type">char</span>  subject[<span class="hljs-number">100</span>];<br>   <span class="hljs-type">int</span>   book_id;<br>&#125; book = &#123;<span class="hljs-string">&quot;C 语言&quot;</span>, <span class="hljs-string">&quot;RUNOOB&quot;</span>, <span class="hljs-string">&quot;编程语言&quot;</span>, <span class="hljs-number">123456</span>&#125;;<br></code></pre></td></tr></table></figure><p>用<code>&#123;.成员变量 = , .成员变量 = &#125;</code>(使用到<code>.</code>操作符)来初始化变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stu</span><br>&#123;<br> <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<span class="hljs-comment">//名字</span><br> <span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br> <span class="hljs-type">char</span> sex[<span class="hljs-number">5</span>];<span class="hljs-comment">//性别</span><br> <span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<span class="hljs-comment">//学号</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stu</span> s2 = &#123; .age = <span class="hljs-number">18</span>, .name = <span class="hljs-string">&quot;lisi&quot;</span>, .id = <span class="hljs-string">&quot;20230818002&quot;</span>, .sex = <span class="hljs-string">&quot;⼥&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p><strong>浮点数在内存中有可能是不能精确保存的。</strong>那根据这一点，在我们对浮点数进行比较大小时，我们就不能简单地对2个数据进行 <code>==</code>是否相等的判断，而是有<strong>一定的误差</strong>。</p><h3 id="结构体的引用"><a href="#结构体的引用" class="headerlink" title="结构体的引用"></a>结构体的引用</h3><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//此结构体的声明包含了其他的结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">COMPLEX</span><br>&#123;<br>    char <span class="hljs-keyword">string</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">SIMPLE</span> a;<br>&#125;;<br><br><span class="hljs-comment">//此结构体的声明包含了指向自己类型的指针</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">NODE</span><br>&#123;<br>    char <span class="hljs-keyword">string</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">NODE</span> *next_node;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在结构中包含一个类型为该结构本身的成员</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//错误的定义<br>struct <span class="hljs-keyword">Node</span><span class="hljs-title">//定义了一个节点。节点本身要包涵自己的数据，和指向下一节点</span><br><span class="hljs-title">&#123;</span><br><span class="hljs-title"> int</span> data;<br> struct <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;//“next”使用未定义的 struct“<span class="hljs-keyword">Node</span><span class="hljs-title">”,这是错误的写法</span><br><span class="hljs-title">&#125;;</span><br></code></pre></td></tr></table></figure><p>这个结构体类型的大小我们是否可以得出来,通过<code>sizeof(struct Node)</code>分析可以知道因为<strong>一个结构体中再包含一个同类型的结构体变量</strong>，这样会使得结构体的大小<strong>无穷大</strong>，这是不合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//正确的定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><span class="hljs-comment">//定义了一个节点。节点本身要包涵，自己的数据和指向下一节点的指针</span><br>&#123;<br> <span class="hljs-type">int</span> data;<span class="hljs-comment">//数据域,大小为4个字节</span><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<span class="hljs-comment">//指针域，大小为4或8个字节</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们需要定义一个指针类型，准确的指向所需要的位置，这样的结构体大小是可以进行计算的，就不会出现错误</p><h3 id="typedef-重定义结构体"><a href="#typedef-重定义结构体" class="headerlink" title="typedef 重定义结构体"></a>typedef 重定义结构体</h3><p>该结构体就有了两种创建变量的方式<code>struct human man</code>和<code>hu man</code>都行，只是将<code>struct human</code>重新取个名字叫<code>hu</code>。本质上还是类型是不占用空间的，只有创建变量时才会开辟空间。当然使用<code>typedef</code>就不能在声明结构体的后面直接创建全局变量了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">human</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">char</span> sex[<span class="hljs-number">10</span>];<br><span class="hljs-type">char</span> id[<span class="hljs-number">20</span>];<br>&#125;hu;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">human</span> man;<br><span class="hljs-comment">//2.</span><br>    hu man;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="结构体访问"><a href="#结构体访问" class="headerlink" title="结构体访问"></a>结构体访问</h3><p>有的时候有可能我们得到的是一个指向该结构体的指针。这时候我们就需要操作符<code>-&gt;</code>，同样也是两个操作数，<code>-&gt;</code>是专门在访问结构体时使用指针的方法，更高效。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">struct</span> <span class="hljs-type">S</span> &#123;<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-built_in">char</span> c;<br>double d;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">T</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">S</span> s;<br><span class="hljs-built_in">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-built_in">int</span> num;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">T</span> t = &#123; &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">1.00</span>&#125;, <span class="hljs-string">&quot;yourfriendyo&quot;</span>, <span class="hljs-number">21</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">T</span>* pt = &amp;t;<br>printf(<span class="hljs-string">&quot;%d %c %lf %s %d\n&quot;</span>, pt-&gt;s.a, pt-&gt;s.c, pt-&gt;s.d, pt-&gt;name, pt-&gt;num);<br></code></pre></td></tr></table></figure><h3 id="结构体的位段"><a href="#结构体的位段" class="headerlink" title="结构体的位段"></a>结构体的位段</h3><p>位段就是限制结构体里面每个参数所要占用的字节，比如一个变量<code>age</code>表示一个人的年龄，设定1-100岁，<strong>那么给int变量占4个字节就有点浪费空间了，那么我们可以限制一下</strong>。<code>位段</code>可以在一定程度上减少空间的浪费</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> A1<br>&#123;<br> <span class="hljs-built_in">int</span> _a:<span class="hljs-number">2</span>;<span class="hljs-comment">//数字部分表示变量只占多少个2进制位，也就是占多少比特位</span><br> <span class="hljs-built_in">int</span> _b:<span class="hljs-number">5</span>;<br> <span class="hljs-built_in">int</span> _c:<span class="hljs-number">10</span>;<br> <span class="hljs-built_in">int</span> _d:<span class="hljs-number">30</span>;<br> <span class="hljs-built_in">int</span> _e:<span class="hljs-number">50</span>;<span class="hljs-comment">//这一行是错误的，int类型的比特位数就只有32位，50超出了限制，会报错</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> A2<br>&#123;<br> <span class="hljs-built_in">int</span> _a;<br> <span class="hljs-built_in">int</span> _b;<br> <span class="hljs-built_in">int</span> _c;<br> <span class="hljs-built_in">int</span> _d;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>printf(<span class="hljs-string">&quot;%zd\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> A1));<span class="hljs-comment">//结果为8</span><br>printf(<span class="hljs-string">&quot;%zd\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> A2));<span class="hljs-comment">//结果为16</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举就是一一列举，把所有可能的值都按照顺序罗列，其实也就是统一的宏定义，而且不需要从1输到100，他会自己安装顺序进行排序，并且如果在中间进行取值定义，后面的值也会发送改变，可以从下面看出来整体的变化，<strong>修改了初始值的常量</strong>开始后面的枚举常量表示的数字都递增+1，前面的保持不变</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> Sex<span class="hljs-comment">//性别</span><br>&#123;<br><span class="hljs-comment">//该枚举类型的三种可能取值</span><br><span class="hljs-comment">//它们都是常量，被称为枚举常量,默认从0开始，递增+1</span><br> MALE,<span class="hljs-comment">//0</span><br> FEMALE,<span class="hljs-comment">//1</span><br> SECRET<span class="hljs-comment">//2</span><br>&#125;;<br><span class="hljs-keyword">enum</span> Sex<span class="hljs-comment">//性别</span><br>&#123;<br><br> MALE=<span class="hljs-number">7</span>,<span class="hljs-comment">//7</span><br> FEMALE=<span class="hljs-number">9</span>,<span class="hljs-comment">//9</span><br> SECRET=<span class="hljs-number">6</span><span class="hljs-comment">//6</span><br>&#125;;<br><span class="hljs-keyword">enum</span> Sex<span class="hljs-comment">//性别</span><br>&#123;<br><br> MALE,<span class="hljs-comment">//0</span><br> FEMALE=<span class="hljs-number">8</span>,<span class="hljs-comment">//8</span><br> SECRET<span class="hljs-comment">//9</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>并且，枚举也遵循typedef的重定义，可以利用变量进行对其中的值进行输入或者调整</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef enum &#123;<br><span class="hljs-type">X</span>,<br><span class="hljs-type">Y</span>,<br>    <span class="hljs-type">SIZE</span><br>&#125;t;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针学习</title>
    <link href="/YYang.github.io/2024/08/02/Work%20No.13/"/>
    <url>/YYang.github.io/2024/08/02/Work%20No.13/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言指针学习"><a href="#C语言指针学习" class="headerlink" title="C语言指针学习"></a>C语言指针学习</h1><h3 id="感谢博主："><a href="#感谢博主：" class="headerlink" title="感谢博主："></a>感谢博主：</h3><p><a href="https://blog.csdn.net/weixin_45031801/article/details/127017272">指针基础知识理解（简单、易懂、超详细！！！！）_史上最全指针解释-CSDN博客</a></p><p><a href="https://blog.csdn.net/soonfly/article/details/51131141">让你不再害怕指针——C指针详解(经典,非常详细)_c语言指针-CSDN博客</a></p><h3 id="计算机的语言表示"><a href="#计算机的语言表示" class="headerlink" title="计算机的语言表示"></a>计算机的语言表示</h3><p>在现代的计算机中主要采用的数字集成电路完成，数字电路通过高低电平只能表示<strong>0和1</strong>，所以就出现了，计算机只会识别<strong>0和1</strong>。无论是存储还是计算，计算机均采用二进制体系完成。</p><p>例如：十进制 <strong>4</strong> ———- 用二进制表示为 00000<strong>100</strong></p><p>在C语言中，一个<code>int</code>类型的整数占用的字节数是固定的，并且与具体数值（例如<code>1</code>）无关。通常情况下，<code>int</code>类型的大小是4字节（32位）。不过，这个大小可能会因平台或编译器的不同而有所变化。</p><h3 id="计算机基础单位和数据类型"><a href="#计算机基础单位和数据类型" class="headerlink" title="计算机基础单位和数据类型"></a><strong>计算机基础单位和数据类型</strong></h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">bit</span><span class="hljs-literal">------------</span> <span class="hljs-comment">比特</span> <span class="hljs-literal">-------------</span> <span class="hljs-comment">位</span><br>  <span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">byte</span> <span class="hljs-literal">---------</span> <span class="hljs-comment">字节</span> <span class="hljs-literal">-------------</span> <span class="hljs-comment">1byte = 8bit</span><br>  <span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">KB</span> <span class="hljs-literal">------------</span> <span class="hljs-comment">千字节</span> <span class="hljs-literal">----------</span> <span class="hljs-comment">1KB = 1024byte</span><br>  <span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">MB</span> <span class="hljs-literal">-----------</span> <span class="hljs-comment">兆</span> <span class="hljs-literal">----------------</span> <span class="hljs-comment">1MB = 1024KB</span><br>  <span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">GB</span> <span class="hljs-literal">-----------</span> <span class="hljs-comment">吉字节</span> <span class="hljs-literal">----------</span> <span class="hljs-comment">1GB = 1024MB</span><br>  <span class="hljs-comment">6</span><span class="hljs-string">.</span> <span class="hljs-comment">TB</span>  <span class="hljs-literal">-----------</span> <span class="hljs-comment">太字节</span> <span class="hljs-literal">----------</span> <span class="hljs-comment">1TB = 1024GB</span><br>  <span class="hljs-comment">7</span><span class="hljs-string">.</span> <span class="hljs-comment">PB</span> <span class="hljs-literal">-----------</span> <span class="hljs-comment">拍字节</span> <span class="hljs-literal">-----------</span> <span class="hljs-comment">1PB = 1024TB</span><br></code></pre></td></tr></table></figure><p>其中在C语言中的一些特定的数据类型存储也是有一定的范围的：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> <span class="hljs-keyword">char</span> <span class="hljs-comment">-------- 1字节</span><br><span class="hljs-number">2.</span> <span class="hljs-keyword">short</span> <span class="hljs-comment">--------- 2字节</span><br><span class="hljs-number">3.</span> int <span class="hljs-comment">-------- 4字节   </span><br><span class="hljs-number">4.</span> <span class="hljs-keyword">long</span> <span class="hljs-comment">---------- 4字节</span><br><span class="hljs-number">5.</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-comment">-------- 8字节</span><br><span class="hljs-number">6.</span> float <span class="hljs-comment">---------- 4字节</span><br></code></pre></td></tr></table></figure><h3 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a><strong>二进制数</strong></h3><p>  <strong>1. 二进制数是带符号的，即分正、负数。其中若是正数最高位显示 0 ，若是负数最高位显示 1</strong></p><p>  <strong>2. 二进制位通常也会受到数据类型的限制，比如 char 型 1 个字节 8 个比特位。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">举例：<span class="hljs-type">int</span> <span class="hljs-number">2</span> ;  <span class="hljs-comment">------------------二进制表示：00000000 00000000 00000000 00000010</span><br></code></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>int *p;</strong> – 首先从 p 处开始，先与 ***** 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。</p><p> <strong>int *p[3];</strong> – 首先从 p 处开始, 先与 [] 结合，因为其优先级比 ***** 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。</p><p>*<em>int *<em>p;</em></em> – 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针</p><p>我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；</p><p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念</p><p>只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-number">1</span>、int *ptr; : 指针的类型是 int*<br><span class="hljs-number">2</span>、char *ptr; : 指针的类型是 char*<br><span class="hljs-number">3</span>、int **ptr; : 指针的类型是 int**<br><span class="hljs-number">4</span>、int <span class="hljs-comment">(*ptr)[3]; : 指针的类型是 int(*)</span>[<span class="hljs-number">3</span>]<br><span class="hljs-number">5</span>、int *<span class="hljs-comment">(*ptr)[4]; : 指针的类型是 int*(*)</span>[<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-number">1</span>、<span class="hljs-type">int</span>*<span class="hljs-keyword">ptr</span>; : 指针所指向的类型是 <span class="hljs-type">int</span><br><span class="hljs-number">2</span>、<span class="hljs-type">char</span>*<span class="hljs-keyword">ptr</span>; : 指针所指向的的类型是 <span class="hljs-type">char</span><br><span class="hljs-number">3</span>、<span class="hljs-type">int</span>**<span class="hljs-keyword">ptr</span>; : 指针所指向的的类型是 <span class="hljs-type">int</span>*<br><span class="hljs-number">4</span>、<span class="hljs-type">int</span>(*<span class="hljs-keyword">ptr</span>)[<span class="hljs-number">3</span>]; : 指针所指向的的类型是 <span class="hljs-type">int</span>()[<span class="hljs-number">3</span>]<br><span class="hljs-number">5</span>、<span class="hljs-type">int</span>*(*<span class="hljs-keyword">ptr</span>)[<span class="hljs-number">4</span>]; : 指针所指向的的类型是 <span class="hljs-type">int</span>*()[<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度</p><p>&amp;符号代表地址的符号，是内存地址，然后内存地址上面会存放内容，地址不代表是内存空间</p><p>*代表指向，p代表内存地址，<code>*p</code>指向这片内存地址上面的内容</p><h4 id="指针是什么？"><a href="#指针是什么？" class="headerlink" title="指针是什么？"></a>指针是什么？</h4><p>内存：就是存放东西的空间</p><p><img src="https://s2.loli.net/2024/08/05/NIi8RQXMkglrqeC.png" alt="8eafbb6548c929bc99f94ef018128c1a.png"><img src="https://s2.loli.net/2024/08/05/Si3Oj5NPpr6Lz1h.png" alt="dba3cdc29d8127ee60c8ca0446bf23fe.png"></p><p>左图就是内存，这个内存中有9个空间，一个空间代表一个字节</p><p>右图就是在这个内存空间中，去创建两个变量 int a 和一个 char ch 根据基础知识，可以知道int 占4个字节 char 占1个字节，注意内存中间的每一个小空间（就是1个字节）是有编号的（1，2，3，4，5，6，7，8，9），内存的编号就是地址，地址也叫指针。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 内存的编号就是地址，地址也叫指针。<br><span class="hljs-bullet">2.</span> 指针是内存中最小单元的编号，也就是地址。<br><span class="hljs-bullet">3.</span> 编号--------&gt;地址----------&gt;指针<br></code></pre></td></tr></table></figure><h4 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 指针类型：决定了指针进行解引用操作的时候，访问几个字节（权限）<br><span class="hljs-bullet">2.</span> char * 的指针引用字节访问1个字节<br><span class="hljs-bullet">3.</span> int * 的指针引用字节访问4个字节<br><span class="hljs-bullet">4.</span> double * 的指针引用字节访问8个字节<br></code></pre></td></tr></table></figure><p>0x开头的就表示十六进制，1个十六进制位表示4个二进制位</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0x11223344</span>; <span class="hljs-regexp">//</span>这是一个<span class="hljs-number">16</span>进制数，一共是<span class="hljs-number">8</span>位，所以代表二进制的<span class="hljs-number">32</span>位，换算也就是<span class="hljs-number">4</span>个字节，一个字节<span class="hljs-number">8</span>位<br><span class="hljs-keyword">int</span> *pa=&amp;a; <span class="hljs-regexp">//</span>定义成<span class="hljs-keyword">int</span>类型，就可以访问<span class="hljs-number">4</span>个字节的权限<br>*pa = <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span>重新替换成零，所以结果是<span class="hljs-number">0x00000000</span><br><br>char* pc = &amp;a;  <span class="hljs-regexp">//</span>定义成<span class="hljs-keyword">int</span>类型，就可以访问<span class="hljs-number">1</span>个字节的权限<br>*pc = <span class="hljs-number">0</span>;  <span class="hljs-regexp">//</span>重新替换成零，所以结果是<span class="hljs-number">0x11223300</span>，他只能替换一个字节，也就是八位，两个十六进制位<br></code></pre></td></tr></table></figure><h4 id="指针打印数组"><a href="#指针打印数组" class="headerlink" title="指针打印数组"></a>指针打印数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;  <span class="hljs-comment">//内存中创建了10个整型，所以一个数组所占的空间就是40个字节，40b</span><br><br><span class="hljs-type">int</span>* pa = a;  <span class="hljs-comment">//数组名就是首元素的地址</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>*pa = i + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 数值+1</span><br> pa++;         <span class="hljs-comment">//地址+1</span><br> <span class="hljs-comment">//*(pa+i)=i+1</span><br> <span class="hljs-comment">// pa表示pa中存放的地址  *pa表示：指向存放地址的内容，也就是解用</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br><span class="hljs-comment">//printf(&quot;%d &quot;, *(pa+i));如果要使用这种输出的话，需要考虑的是，在上一个for循环后，*pa就已经不是指向首地址，而是指向尾地址</span><br>&#125;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-comment">//定义一个数组</span><br><span class="hljs-type">int</span>* arr = &amp;a[<span class="hljs-number">4</span>];<span class="hljs-comment">//这个指向的是地址类型上面的内容，也就是数组a的第五个数据</span><br><span class="hljs-comment">//输出结果：9</span><br><br><span class="hljs-type">int</span> *arr = &amp;a;<span class="hljs-comment">//这个指向的是数组a的地址类型上面的内容，也就是数组里面的全部数据</span><br><span class="hljs-comment">//输出结果：5，6，7，8，9</span><br><br><span class="hljs-type">int</span> *arr;<span class="hljs-comment">//定义指针类型为int</span><br>arr = a;<span class="hljs-comment">//指向的是数组a的全部数据地址</span><br><span class="hljs-comment">//输出结果：000000000061FDF0 000000000061FDF4 000000000061FDF8 000000000061FDFC 000000000061FE00</span><br></code></pre></td></tr></table></figure><p><code>void aaaaaa(char* name)</code> 和 <code>void aaaaaa(char *name)</code> 这两种函数声明在 C 语言中实际上是等效的。它们的功能和行为是相同的。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json数据包收发测试</title>
    <link href="/YYang.github.io/2024/08/01/Work%20No.12/"/>
    <url>/YYang.github.io/2024/08/01/Work%20No.12/</url>
    
    <content type="html"><![CDATA[<h1 id="Json收发测试"><a href="#Json收发测试" class="headerlink" title="Json收发测试"></a>Json收发测试</h1><h2 id="Json构建"><a href="#Json构建" class="headerlink" title="Json构建"></a>Json构建</h2><p>首先定义一个Json的创建函数，函数的返回类型要是字符串格式，因为json最后的发送都是以字符串进行发送的</p><p>首先要设计好Json格式的内容层次，然后再去写代码，我的Json包的层次如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">|<span class="hljs-keyword">params</span><br>|mtype：<span class="hljs-number">1</span><br>|buf：<br>|<span class="hljs-keyword">method</span>：<span class="hljs-title function_">BELT_TEST</span><br>|<span class="hljs-title function_">beltNum</span>：<br>|<span class="hljs-title function_">name_1</span>：90<br>|<span class="hljs-title function_">name_2</span>：45<br>|<span class="hljs-title function_">message</span>:<br>|error:<span class="hljs-number">0</span><br>|other：aaaa<br></code></pre></td></tr></table></figure><p>我们需要观察在这个层次里面，哪些是包含多个参数，哪些是只有一个参数的，如果是多个参数的，我们可以把它想成一个小的json包用来装载，如果只是单个参数的，直接进行装载进去就行</p><p><strong>记住json包的顺序定义，观察哪些是多参数的先定义，然后装载单参数，再从里往外装载多参数，最后转换格式进行发送</strong></p><p>根据上面定义的层次定义，首先要使用<code>json_object_new_object()</code>函数创建一个params的json结构，用来装载接下来的内容</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">//创建一个json对象</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span> *params = json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span><span class="hljs-keyword">object</span>();<br><br><span class="hljs-comment">//创建json子对象buf</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span> *buf = json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span><span class="hljs-keyword">object</span>();<br><br><span class="hljs-comment">//创建json子对象beltNum</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span> *beltNum = json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span><span class="hljs-keyword">object</span>();<br><br><span class="hljs-comment">//创建json子对象message</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span> *message = json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span><span class="hljs-keyword">object</span>();<br></code></pre></td></tr></table></figure><p>之后观察哪些是单参数，依次装载进去即可，mtype相对于params是单参数，method相对于buf是单参数，name_1和name_2相对于beltNum是单参数，error和other相对于message是单参数，所以对单参数进行装载</p><p>这里面需要注意的是，如果装载的是字符，需要用json_object_new_string，如果是整数型，则用json_object_new_int</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">//在params对象中加入键位mtype，并写入整数值1</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(params, <span class="hljs-string">&quot;mtype&quot;</span>, json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span>int(<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//在buf对象中加入键位method，并写入字符格式“BELT_TEST”</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(buf, <span class="hljs-string">&quot;method&quot;</span>, json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span>string(<span class="hljs-string">&quot;BELT_TEST&quot;</span>));<br><br><span class="hljs-comment">//在beltNum对象中加入键位name_1，并写入整数值90</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(beltNum, name<span class="hljs-number">_1</span>, json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span>int(<span class="hljs-number">90</span>));<br><br><span class="hljs-comment">//在beltNum对象中加入键位name_2，并写入整数值45</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(beltNum, name<span class="hljs-number">_2</span>, json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span>int(<span class="hljs-number">45</span>));<br><br><span class="hljs-comment">//在message对象中加入键位error，并写入整数值0</span><br><span class="hljs-comment">//json_object_object_add(message, &quot;error&quot;, json_object_new_int(0));</span><br><br><span class="hljs-comment">//在message对象中加入键位other，并写入字符格式“aaaaa”</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(message, <span class="hljs-string">&quot;other&quot;</span>, json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ew<span class="hljs-number">_</span>string(<span class="hljs-string">&quot;aaaaa&quot;</span>));<br></code></pre></td></tr></table></figure><p>之后，我们将多参数从层次最里面的往外进行装载即可</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">//将belt_name的子对象加入到buf中</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(buf, <span class="hljs-string">&quot;beltNum&quot;</span>, beltNum);<br><br><span class="hljs-comment">//将message的子对象加入到buf中</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(buf, <span class="hljs-string">&quot;message&quot;</span>, message);<br><br><span class="hljs-comment">//将buf的子对象加入到params中</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>add(params, <span class="hljs-string">&quot;buf&quot;</span>, buf);<br></code></pre></td></tr></table></figure><p>最后，我们已经完成整个json包的构建，但是在json包的收发必须通过字符串格式，而不是通过json包的格式，所以需要对格式进行转换</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将params转换成字符串格式<br>   const char* cmdJsonStr = json_object_to_json_string_ext(params, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);<br>   <span class="hljs-regexp">//</span>JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。<br>   <span class="hljs-regexp">//</span>JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（<span class="hljs-regexp">/）进行转义。在 JSON 标准中，斜杠可以被转义为 \/，但这个标志会使输出保持为 /</span><br>   <br>   <span class="hljs-regexp">//</span>最后的输出格式为<br>   <span class="hljs-regexp">//</span>cmdJsonStr = &#123;<span class="hljs-string">&quot;mtype&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;buf&quot;</span>:&#123;<span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;BELT_TEST&quot;</span>,<span class="hljs-string">&quot;beltNum&quot;</span>:&#123;<span class="hljs-string">&quot;name_1&quot;</span>:<span class="hljs-number">90</span>,<span class="hljs-string">&quot;name_2&quot;</span>:<span class="hljs-string">&quot;45&quot;</span>&#125;<span class="hljs-string">&quot;message&quot;</span>:&#123;<span class="hljs-string">&quot;error&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;other&quot;</span>:<span class="hljs-string">&quot;aaaaa&quot;</span>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>最终，我们的代码整体如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* Jsontest(<span class="hljs-built_in">char</span> *name)<br>&#123;<br>    <span class="hljs-comment">//创建一个json对象params</span><br>    json_object *<span class="hljs-keyword">params</span> = json_object_new_object();<br>    <br>    <span class="hljs-comment">//创建json子对象buf</span><br>    json_object *buf = json_object_new_object();<br>    <br>    <span class="hljs-comment">//创建json子对象beltNum</span><br>    json_object *beltNum = json_object_new_object();<br>    <br>    <span class="hljs-comment">//创建json子对象message</span><br>    json_object *message = json_object_new_object();<br><br>    <span class="hljs-comment">//在params对象中加入键位mtype，并写入整数值1</span><br>    json_object_object_add(<span class="hljs-keyword">params</span>, <span class="hljs-string">&quot;mtype&quot;</span>, json_object_new_int(<span class="hljs-number">1</span>));<br>    <br>    <span class="hljs-comment">//在buf对象中加入键位method，并写入字符格式“BELT_TEST”</span><br>    json_object_object_add(buf, <span class="hljs-string">&quot;method&quot;</span>, json_object_new_string(<span class="hljs-string">&quot;BELT_TEST&quot;</span>));<br>    <br>    <span class="hljs-comment">//在beltNum对象中加入键位name_1，并写入整数值90</span><br>    json_object_object_add(beltNum, name_1, json_object_new_int(<span class="hljs-number">90</span>));<br>    <br>    <span class="hljs-comment">//在beltNum对象中加入键位name_2，并写入整数值45</span><br>    json_object_object_add(beltNum, name_2, json_object_new_int(<span class="hljs-number">45</span>));<br>    <br>    <span class="hljs-comment">//在message对象中加入键位error，并写入整数值0</span><br>    <span class="hljs-comment">//json_object_object_add(message, &quot;error&quot;, json_object_new_int(0));</span><br>    <br>    <span class="hljs-comment">//在message对象中加入键位other，并写入字符格式“aaaaa”</span><br>    json_object_object_add(message, <span class="hljs-string">&quot;other&quot;</span>, json_object_new_string(<span class="hljs-string">&quot;aaaaa&quot;</span>));<br>    <br>    <span class="hljs-comment">//将belt_name的子对象加入到buf中</span><br>    json_object_object_add(buf, <span class="hljs-string">&quot;beltNum&quot;</span>, beltNum);<br>    <br>    <span class="hljs-comment">//将message的子对象加入到buf中</span><br>    json_object_object_add(buf, <span class="hljs-string">&quot;message&quot;</span>, message);<br>    <br>    <span class="hljs-comment">//将buf的子对象加入到params中</span><br>    json_object_object_add(<span class="hljs-keyword">params</span>, <span class="hljs-string">&quot;buf&quot;</span>, buf);<br>    <br>    <span class="hljs-comment">//将params转换成字符串格式</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* cmdJsonStr = json_object_to_json_string_ext(<span class="hljs-keyword">params</span>, JSON_C_TO_STRING_PLAIN|JSON_C_TO_STRING_NOSLASHESCAPE);<br>    <span class="hljs-comment">//JSON_C_TO_STRING_PLAIN: 生成紧凑的 JSON 字符串，不包含额外的空格或缩进。这有助于减少输出的大小。</span><br>    <span class="hljs-comment">//JSON_C_TO_STRING_NOSLASHESCAPE: 不对斜杠字符（/）进行转义。在 JSON 标准中，斜杠可以被转义为 \/，但这个标志会使输出保持为 /</span><br>    <br>    <span class="hljs-comment">//输出日志作为测试</span><br>    CrLogI(<span class="hljs-string">&quot;cmdJsonStr = %s\n&quot;</span>,cmdJsonStr);<br><br>    <span class="hljs-comment">//返回cmdJsonStr字符</span><br>    <span class="hljs-keyword">return</span> cmdJsonStr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Json的解析"><a href="#Json的解析" class="headerlink" title="Json的解析"></a>Json的解析</h2><p>解析json数据包的时候要找关键信息，因为数据包的有些数据并不会在该函数进行解析，可能会在别的函数去判断，所以我们首先要找准我们要哪些数据</p><p>首先我需要获取这个数据包里面的mtype作为标志位，来判断是否接收到了这个数据包，然后去解析buf中的message的error，看看是否包含了所需的数据，然后进行判断，罗列我们所要的数据</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|params</span><br><span class="hljs-string">|mtype：1</span><br><span class="hljs-string">|buf：</span><br><span class="hljs-string">|message:</span><br><span class="hljs-string">|error:0</span><br></code></pre></td></tr></table></figure><p>根据上面所列，我们开始对json数据进行解析</p><p>首先使用对整个json数据包进行解析，因为发送过来的json包如果不解析的话，无法使用接下来的json语句抓取其中的关键值</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//首先使用上面的发送函数，来获取一个<span class="hljs-type">json</span>包<br>const <span class="hljs-type">char</span>* str_2 = Jsontest(<span class="hljs-type">name</span>);<br><br>//定义一个<span class="hljs-type">json</span>格式的值用来储存<span class="hljs-type">json</span>包<br>json_object *recv = json_tokener_parse(str_2);<br></code></pre></td></tr></table></figure><p>之后我们获得了整个json的数据，我们只需要对里面的内容进行查找即可，解包只需要一次，之后只需要不断查找判断即可</p><p>我们获取的数据需要对他进行验证判断，首先需要判断是否包含该键，之后验证其格式是否正确，其携带的值是什么</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">//定义一个值来储存从recv中查找&quot;mtype&quot;键所携带的值</span><br>json<span class="hljs-number">_</span><span class="hljs-keyword">object</span> *mtype = json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>get(recv,<span class="hljs-string">&quot;mtype&quot;</span>);<br><br><span class="hljs-comment">//判断是否查找到该键，该键的格式是否为整数型，该键的值是否为1，如果有一个不符合，说明解包错误</span><br><span class="hljs-keyword">if</span>(mytpe != NULL &amp;&amp; json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span><span class="hljs-keyword">is</span><span class="hljs-number">_</span>type(mtype, json<span class="hljs-number">_</span>type<span class="hljs-number">_</span>int) &amp;&amp; json<span class="hljs-number">_</span><span class="hljs-keyword">object</span><span class="hljs-number">_</span>get<span class="hljs-number">_</span>int(mytpe) == <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>刚刚的mytpe是单参数的，多参数的也类似，不过也需要一层一层的解开，而不是直接解到最底层</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sas">//定义一个值来储存从recv中查找<span class="hljs-string">&quot;buf&quot;</span>键所携带的值<br>json_object <span class="hljs-comment">*buf = json_object_object_get(recv,&quot;buf&quot;);</span><br><br>//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误<br><span class="hljs-keyword">if</span>(buf != <span class="hljs-keyword">NULL</span> <span class="hljs-variable">&amp;&amp;</span> json_object_is_type(buf, json_type_object))<br>&#123;<br>//完成第一层解包后，需要进行第二层解包，定义一个值来储存从buf中查找<span class="hljs-string">&quot;message&quot;</span>键所携带的值<br>json_object <span class="hljs-comment">*message = json_object_object_get(buf,&quot;message&quot;);</span><br><br>//判断是否查找到该键，该键的格式是否为多参数型，如果有一个不符合，说明解包错误<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">message</span> != <span class="hljs-keyword">NULL</span> <span class="hljs-variable">&amp;&amp;</span> json_object_is_type(<span class="hljs-keyword">message</span>, json_type_object))<br>&#123;<br>//继续解包，定义一个值来储存从<span class="hljs-keyword">message</span>中查找<span class="hljs-string">&quot;error&quot;</span>键所携带的值<br>json_object <span class="hljs-comment">*error = json_object_object_get(message,&quot;error&quot;);</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">error</span> == <span class="hljs-keyword">NULL</span> <span class="hljs-variable">&amp;&amp;</span> json_object_get_<span class="hljs-meta">int</span>(<span class="hljs-keyword">error</span>) == 0)<br>&#123;<br>CrLogI(<span class="hljs-string">&quot;belt tension no match\n&quot;</span>);//有<span class="hljs-keyword">error</span>键值，说明不合格<br>&#125;<br>&#125;<br>json_object_<span class="hljs-meta">put</span>(buf);//释放json空间<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们就完成了整个json的解读，获取关键值进行判断，其中如果多参数的键，我们不能让其输出值，而是需要判断其格式是否符合多参数的格式，如果是单参数的键，可以利用<code>json_object_get_int(error) == 0</code>输出值并进行比较。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习</title>
    <link href="/YYang.github.io/2024/07/31/Work%20No.8/"/>
    <url>/YYang.github.io/2024/07/31/Work%20No.8/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言学习"><a href="#C语言学习" class="headerlink" title="C语言学习"></a>C语言学习</h1><h3 id="void-memset-void-str-int-c-size-t-n-用于将一段内存区域设置为指定的值"><a href="#void-memset-void-str-int-c-size-t-n-用于将一段内存区域设置为指定的值" class="headerlink" title="void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值"></a>void *memset(void *str,int c, size_t n)用于将一段内存区域设置为指定的值</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *str, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>;<br>*str  <span class="hljs-comment">//要指向填充的内存区域指针</span><br>c  <span class="hljs-comment">//代表要填充的值</span><br>n  <span class="hljs-comment">//要被设置的字节数</span><br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">    char str[<span class="hljs-number">10</span>];<br>    memset(str, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">9</span>); <span class="hljs-regexp">//</span>将str字符前九个填入字符a，要注意是<span class="hljs-string">&#x27;&#x27;</span>号，不能是<span class="hljs-string">&quot;&quot;</span>，<span class="hljs-string">&quot;&quot;</span>代表的是字符串<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;output: <span class="hljs-variable">%s</span>\n&quot;</span>,str);<br>    memset(str, <span class="hljs-string">&#x27;\0&#x27;</span> ,<span class="hljs-number">10</span>); <span class="hljs-regexp">//</span>将str字符前九个填入字符<span class="hljs-string">&#x27;\0&#x27;</span>或者<span class="hljs-number">0</span>，可以将字符串进行清零操作<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;output: <span class="hljs-variable">%s</span>\n&quot;</span>,str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br><span class="hljs-regexp">//</span>output: aaaaaaaaa<br>//output:<br></code></pre></td></tr></table></figure><h3 id="return-0"><a href="#return-0" class="headerlink" title="return 0"></a>return 0</h3><p><strong>没有返回值的函数为空类型，用<code>void</code>表示</strong>。一旦函数的返回值类型被定义为 void，就不能再接收它的值，即若函数没有返回值</p><p>返回值的类型必须与函数定义类型一致。例如：在返回类型是<strong>char的函数</strong>中，return后应该是char类型的值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> 表达式; <span class="hljs-keyword">return</span> (表达式); 为了简明，（）一般不写。例如：<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；表示程序正常退出，即当<span class="hljs-keyword">return</span>语句提供了一个值时，这个值就成为函数的返回值。<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>；表示程序异常退出，返回主调函数来处理，继续往下执行。<br></code></pre></td></tr></table></figure><h3 id="void-memcpy-void-str1-const-void-str2-size-t-n-从存储区-str2-复制-n-个字节到存储区-str1"><a href="#void-memcpy-void-str1-const-void-str2-size-t-n-从存储区-str2-复制-n-个字节到存储区-str1" class="headerlink" title="void *memcpy(void *str1, const void *str2, size_t n)从存储区 str2 复制 n 个字节到存储区 str1"></a>void *memcpy(void *str1, const void *str2, size_t n)从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 str1</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">str1  <span class="hljs-comment">//代表用于存储复制内容的目标数组</span><br>str2  <span class="hljs-comment">//代表被复制内容的目标数组</span><br>n  <span class="hljs-comment">//代表需要从str复制n个字节到str1</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-type">char</span> str_1[<span class="hljs-number">256</span>] = <span class="hljs-string">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class="hljs-type">char</span> str_2[<span class="hljs-number">256</span>];<br> <br>    <span class="hljs-built_in">memcpy</span>(&amp;str_2[<span class="hljs-number">0</span>] ,str_1 ,<span class="hljs-built_in">strlen</span>(str_1));<span class="hljs-comment">//strlen(str_1)获取str_1字符串的字节，然后将str_1的字符串复制strlen(str_1)个字节到str_2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output: %s\n&quot;</span>,str_2);<br>    <br><span class="hljs-comment">//output: aaaaaaaaa</span><br><span class="hljs-comment">//output: aa</span><br></code></pre></td></tr></table></figure><h3 id="储存区"><a href="#储存区" class="headerlink" title="储存区"></a>储存区</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs processing">内存分配可分为三种：静态存储区、栈区、堆区。<br><br><span class="hljs-number">1</span>、静态存储区：该内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，它主要存放静态数据、全局数据和常量。<br><br><span class="hljs-number">2</span>、栈区：它的用途是完成函数的调用。在执行函数时，函数内局部变量及函数参数的存储单元在栈上创建，函数调用结束时这些存储单元自动被释放。<br><br><span class="hljs-number">3</span>、堆区：程序在运行时使用库函数为变量申请内存，在变量使用结束后再调用库函数释放内存。动态内存的生存期是由我们决定的，如果我们不释放内存，就会导致内存泄漏。<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-built_in">line</span>[LINE_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//静态变量的生命周期贯穿整个程序运行期间，适合需要长期保存数据的场景</span><br><br>chat *<span class="hljs-built_in">line</span> = <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-comment">//多个指针可以共享相同的字符串字面量，节省内存，字符串字面量是不可变的，试图修改会导致未定义行为。</span><br><br><span class="hljs-type">char</span> <span class="hljs-built_in">str</span>[LINE_SIZE] = <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-comment">//字符数组在声明时可以初始化为一个特定的字符串，数组的其余部分为未初始化（通常是随机值）。对于局部变量，栈空间有限，大数组可能导致栈溢出</span><br></code></pre></td></tr></table></figure><h3 id="char-strchr-const-char-str-int-c-用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置"><a href="#char-strchr-const-char-str-int-c-用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置" class="headerlink" title="char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置"></a>char *strchr(const char *str, int c)用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">str</span>  <span class="hljs-comment">//所要查询的字符</span><br>c  <span class="hljs-comment">//代表所要查找的字符，单个字符需要用&#x27;&#x27;符号，否则警告</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-type">char</span> str_1[<span class="hljs-number">256</span>] = <span class="hljs-string">&quot;asdfghjklzxcvbnm&quot;</span>;<br>    <span class="hljs-type">char</span> str_2[<span class="hljs-number">256</span>];<br><br>    <span class="hljs-type">char</span> *find = <span class="hljs-built_in">strchr</span>(str_1, <span class="hljs-string">&#x27;z&#x27;</span>);  <span class="hljs-comment">//查找str_1里面的z字符，并将指针指向这个位置</span><br>    <span class="hljs-keyword">if</span>(find)&#123;  <span class="hljs-comment">//判断是否找到，如果找到，则将其替换成换行符，等于舍弃后面的内容</span><br>        *find = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(str_2 ,str_1 ,<span class="hljs-built_in">strlen</span>(str_1));  <span class="hljs-comment">//将str_1的字符全部复制给str_2，由于上述指针指的位置替换成了换行符，所以到此字符进行截断</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output: %s\n&quot;</span>,str_2);  <span class="hljs-comment">//所以输出的是z前面的字符</span><br>    <br><span class="hljs-comment">//output</span><br>output: asdfghjkl<br></code></pre></td></tr></table></figure><h4 id="char-strcpy-char-dest-const-char-src-把-src-所指向的字符串复制到-dest"><a href="#char-strcpy-char-dest-const-char-src-把-src-所指向的字符串复制到-dest" class="headerlink" title="char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest"></a>char *strcpy(char *dest, const char *src)把 <strong>src</strong> 所指向的字符串复制到 dest</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">char</span> *strcpy(<span class="hljs-built_in">char</span> *dest, const <span class="hljs-built_in">char</span> *src)<br><br>//dest <span class="hljs-comment">-- 指向用于存储复制内容的目标数组。</span><br>//src <span class="hljs-comment">-- 要复制的字符串。</span><br><br><span class="hljs-built_in">char</span> str_1[<span class="hljs-number">256</span>] = <span class="hljs-string">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class="hljs-built_in">char</span> str_3[<span class="hljs-number">256</span>];<br>    printf(<span class="hljs-string">&quot;output: %s\n&quot;</span>,str_1);<br>    <br>    strcpy(str_3,str_1);<br>    printf(<span class="hljs-string">&quot;output: %s\n&quot;</span>,str_3);<br>    <br>//<span class="hljs-built_in">output</span><br><span class="hljs-built_in">output</span>: <span class="hljs-number">123456</span>sdadasdadasdasda7454589<br><span class="hljs-built_in">output</span>: <span class="hljs-number">123456</span>sdadasdadasdasda7454589<br></code></pre></td></tr></table></figure><p>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等</p><p>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度</p><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。</span></span><br><span class="hljs-function"><span class="hljs-comment">//src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。</span></span><br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//把 str1 所指向的字符串和 str2 所指向的字符串进行比较</span><br><span class="hljs-keyword">int</span> strcmp(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str2) <br><span class="hljs-comment">//str1 -- 要进行比较的第一个字符串。</span><br><span class="hljs-comment">//str2 -- 要进行比较的第二个字符串。</span><br><br><span class="hljs-comment">//返回值</span><br>如果返回值小于 <span class="hljs-number">0</span>，则表示 str1 小于 str2。<br>如果返回值大于 <span class="hljs-number">0</span>，则表示 str1 大于 str2。<br>如果返回值等于 <span class="hljs-number">0</span>，则表示 str1 等于 str2。<br></code></pre></td></tr></table></figure><h3 id="判断式if"><a href="#判断式if" class="headerlink" title="判断式if"></a>判断式if</h3><p>根据上面的内容进行假设，由于strchr如果找到，则返回该值所在的位置，如果没有找到，则返回NULL空值</p><p>如果我想要他返回真值时定义操作，我的函数可以写为</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>)&#123;<br>    *<span class="hljs-built_in">find</span> = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>或者<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span> != <span class="hljs-literal">NULL</span>)&#123;<br>    *<span class="hljs-built_in">find</span> = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我想要发返回空值时定义操作，函数可以写为</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span> = <span class="hljs-literal">NULL</span>)&#123;<br>    *<span class="hljs-built_in">find</span> = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>或者<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">find</span>)&#123;<br>    *<span class="hljs-built_in">find</span> = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式的使用流程</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">编译正则表达式 <span class="hljs-function"><span class="hljs-title">regcomp</span>()</span><br>匹配正则表达式 <span class="hljs-function"><span class="hljs-title">regexec</span>()</span><br>释放正则表达式 <span class="hljs-function"><span class="hljs-title">regfree</span>()</span><br></code></pre></td></tr></table></figure><h4 id="1-regcomp"><a href="#1-regcomp" class="headerlink" title="1.regcomp()"></a>1.regcomp()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">regcomp</span> <span class="hljs-params">(<span class="hljs-type">regex_t</span> *compiled, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pattern, <span class="hljs-type">int</span> cflags)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。</span></span><br><span class="hljs-function"><span class="hljs-comment">//pattern 是指向我们写好的正则表达式的指针。</span></span><br><span class="hljs-function"><span class="hljs-comment">//cflags 有如下4个值或者是它们或运算(|)后的值：</span></span><br><span class="hljs-function"><span class="hljs-comment">//REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。</span></span><br><span class="hljs-function"><span class="hljs-comment">//REG_ICASE 匹配字母时忽略大小写。</span></span><br><span class="hljs-function"><span class="hljs-comment">//REG_NOSUB 不用存储匹配后的结果。</span></span><br><span class="hljs-function"><span class="hljs-comment">//REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配。</span></span><br></code></pre></td></tr></table></figure><h4 id="2-regexec"><a href="#2-regexec" class="headerlink" title="2.regexec()"></a>2.regexec()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在编译正则表达式的时候没有指定cflags的参数REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">regexec</span> <span class="hljs-params">(<span class="hljs-type">regex_t</span> *compiled, <span class="hljs-type">char</span> *string, <span class="hljs-type">size_t</span> nmatch, <span class="hljs-type">regmatch_t</span> matchptr [], <span class="hljs-type">int</span> eflags)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//compiled 是已经用regcomp函数编译好的正则表达式。</span></span><br><span class="hljs-function"><span class="hljs-comment">//string 是目标文本串。</span></span><br><span class="hljs-function"><span class="hljs-comment">//nmatch 是regmatch_t结构体数组的长度。</span></span><br><span class="hljs-function"><span class="hljs-comment">//matchptr regmatch_t类型的结构体数组，存放匹配文本串的位置信息。</span></span><br><span class="hljs-function"><span class="hljs-comment">//eflags 有两个值</span></span><br><span class="hljs-function"><span class="hljs-comment">//REG_NOTBOL 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义；</span></span><br><span class="hljs-function"><span class="hljs-comment">//REG_NOTEOL 和上边那个作用差不多，不过这个指定结束end of line。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">regoff_t</span> rm_so;<br>   <span class="hljs-type">regoff_t</span> rm_eo;<br>&#125; <span class="hljs-type">regmatch_t</span>;<br><span class="hljs-comment">//成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。</span><br><br></code></pre></td></tr></table></figure><h4 id="3-regfree"><a href="#3-regfree" class="headerlink" title="3.regfree()"></a>3.regfree()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果是重新编译的话，一定要先清空regex_t结构体。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">regfree</span> <span class="hljs-params">(<span class="hljs-type">regex_t</span> *compiled)</span></span><br></code></pre></td></tr></table></figure><h4 id="4-regerror"><a href="#4-regerror" class="headerlink" title="4.regerror"></a>4.regerror</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">regerror</span> <span class="hljs-params">(<span class="hljs-type">int</span> errcode, <span class="hljs-type">regex_t</span> *compiled, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//errcode 是由regcomp 和 regexec 函数返回的错误代号。</span></span><br><span class="hljs-function"><span class="hljs-comment">//compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。</span></span><br><span class="hljs-function"><span class="hljs-comment">//buffer 指向用来存放错误信息的字符串的内存空间。</span></span><br><span class="hljs-function"><span class="hljs-comment">//length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。</span></span><br></code></pre></td></tr></table></figure><h3 id="void-bzero-void-s-int-n-将内存块（字符串）的前n个字节清零"><a href="#void-bzero-void-s-int-n-将内存块（字符串）的前n个字节清零" class="headerlink" title="void bzero(void *s, int n);将内存块（字符串）的前n个字节清零"></a>void bzero(void *s, int n);将内存块（字符串）的前n个字节清零</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-type">char</span> str_1[<span class="hljs-number">256</span>] = <span class="hljs-string">&quot;123456sdadasdadasdasda7454589&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str_1:%s\n&quot;</span>,str_1);<br>    <span class="hljs-type">char</span> str_2[<span class="hljs-number">256</span>] = <span class="hljs-built_in">bzero</span>(str_1,<span class="hljs-built_in">sizeof</span>(str_1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str_2:%s\n&quot;</span>,str_2);<br><br><span class="hljs-comment">//bzero不是标准C库，逐渐被memset替代</span><br></code></pre></td></tr></table></figure><h3 id="int-atoi-const-char-str-把参数-str-所指向的字符串转换为一个整数（类型为-int-型）"><a href="#int-atoi-const-char-str-把参数-str-所指向的字符串转换为一个整数（类型为-int-型）" class="headerlink" title="int atoi(const char *str)把参数 str 所指向的字符串转换为一个整数（类型为 int 型）"></a>int atoi(const char *str)把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">char str_1[] = <span class="hljs-string">&quot;2147483647&quot;</span>;<span class="hljs-regexp">//in</span>t的整数值只能是<span class="hljs-number">4</span>字节，所以不能超过<span class="hljs-number">2147483647</span><br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;str_1:<span class="hljs-variable">%s</span>\n&quot;</span>,str_1);<br><br><span class="hljs-keyword">int</span> str_2 = atoi(&amp;str_1);<span class="hljs-regexp">//</span>转换成整数型<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;str_2:<span class="hljs-variable">%d</span>\n&quot;</span>,str_2);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Size of int = <span class="hljs-variable">%ld</span> bytes \n&quot;</span>, sizeof(str_2));<span class="hljs-regexp">//</span>输出字符的字节长度<br></code></pre></td></tr></table></figure><h3 id="位、字节的关系"><a href="#位、字节的关系" class="headerlink" title="位、字节的关系"></a>位、字节的关系</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1 Byte = 8 bit<br>1 KB = 1024 Byte<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br><br>8位无符号的最大值就是1111 1111，最大值是255，即就是 (2^8)<span class="hljs-string">-1</span>。<br>然而有符号只是在此基础上让8位中的第一位充当符号位，0代表正数，1代表负数。<br>8位有符号的最大值就是0111 1111，最大值是<span class="hljs-string">+127</span>，即就是 (2^7)<span class="hljs-string">-1</span>，<br>8位有符号的最小值就是1000 0000，最小值是<span class="hljs-string">-128</span>，即就是 <span class="hljs-string">-2</span>^7，<br><br>4字节（32位）<br>最大值 （2^31）- 1   2147483647<br>最小值 - 2^31  <span class="hljs-string">-2147483648</span><br></code></pre></td></tr></table></figure><h3 id="指针配合while循环函数实现无限循环处理不同消息"><a href="#指针配合while循环函数实现无限循环处理不同消息" class="headerlink" title="指针配合while循环函数实现无限循环处理不同消息"></a>指针配合while循环函数实现无限循环处理不同消息</h3><pre><code class="hljs">// 解析数据，定义*answer指针指向klipperAcceptBuffer接收数据char *answer = klipperAcceptBuffer;//进入字符读取过程循环，读完利用指针指向下一帧，继续开始循环while (answer)&#123;    // 查找数据帧结束符‘0x03’    char *answerEnd = strchr(answer, 0x03);        ......        // 继续处理下一个数据帧    answer = answerEnd + 1;  &#125;</code></pre><h3 id="strstr-查找第一次出现字符串的位置"><a href="#strstr-查找第一次出现字符串的位置" class="headerlink" title="strstr() 查找第一次出现字符串的位置"></a>strstr() 查找第一次出现字符串的位置</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//在字符串 haystack 中查找第一次出现字符串 needle 的位置</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strstr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *haystack, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *needle)</span> </span><br></code></pre></td></tr></table></figure><h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">//将可变参数(...)按照 <span class="hljs-keyword">format</span> 格式化成字符串，并将字符串复制到 str 中，<span class="hljs-built_in">size</span> 为要写入的字符的最大数目，超过 <span class="hljs-built_in">size</span> 会被截断，最多写入 <span class="hljs-built_in">size</span>-<span class="hljs-number">1</span> 个字符。<br><span class="hljs-built_in">int</span> snprintf(<span class="hljs-built_in">char</span> *str, size_t <span class="hljs-built_in">size</span>, const <span class="hljs-built_in">char</span> *<span class="hljs-keyword">format</span>, ...) <br>//str -- 目标字符串，用于存储格式化后的字符串的字符数组的指针。<br>//<span class="hljs-built_in">size</span> -- 字符数组的大小。<br>//<span class="hljs-keyword">format</span> -- 格式化字符串。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D打印机运行逻辑</title>
    <link href="/YYang.github.io/2024/07/26/Work%20No.7/"/>
    <url>/YYang.github.io/2024/07/26/Work%20No.7/</url>
    
    <content type="html"><![CDATA[<h1 id="3D打印机运行逻辑"><a href="#3D打印机运行逻辑" class="headerlink" title="3D打印机运行逻辑"></a>3D打印机运行逻辑</h1><h3 id="打印机初始化"><a href="#打印机初始化" class="headerlink" title="打印机初始化"></a>打印机初始化</h3><p>1.获取机器，连接网络，并且在设置里面打开root权限，获得root的账号和密码</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">root  <span class="hljs-comment">//账号</span><br>root  <span class="hljs-comment">//密码</span><br></code></pre></td></tr></table></figure><p>2.需要获取机器的IP地址，然后用mobaxtem的ssh进行连接，连接时输入IP地址和账号</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">172</span><span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xx</span>  <span class="hljs-comment">//IP地址</span><br></code></pre></td></tr></table></figure><p>3.拷贝所需的文件夹进行安装</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp <span class="hljs-regexp">/tmp/u</span>disk<span class="hljs-regexp">/sda1/</span>fluidd<span class="hljs-regexp">/fluidd.sh /u</span>sr<span class="hljs-regexp">/data  /</span>/拷贝脚本文件<br>cp <span class="hljs-regexp">/tmp/u</span>disk<span class="hljs-regexp">/sda1/</span>fluidd<span class="hljs-regexp">/fluidd.tar /u</span>sr<span class="hljs-regexp">/data  /</span>/拷贝配置文件<br><br>cd <span class="hljs-regexp">/usr/</span>data  <span class="hljs-regexp">//</span>进入该文件夹下<br><br>.<span class="hljs-regexp">/fluidd.sh install  /</span>/执行安装指令<br></code></pre></td></tr></table></figure><p>4.等待结束，即可登录fluidd网站</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">172</span><span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xx</span>:<span class="hljs-number">4408</span>  <span class="hljs-comment">//fluidd的网址</span><br></code></pre></td></tr></table></figure><h3 id="打印机操作"><a href="#打印机操作" class="headerlink" title="打印机操作"></a>打印机操作</h3><p>SET_VELOCITY_LIMIT 改变打印机配置文件中指定的速度限制。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">SET_VELOCITY_LIMIT</span> <span class="hljs-selector-attr">[VELOCITY=&lt;value&gt;]</span> <span class="hljs-selector-attr">[ACCEL=&lt;value&gt;]</span> <span class="hljs-selector-attr">[MINIMUM_CRUISE_RATIO=&lt;value&gt;]</span> <span class="hljs-selector-attr">[SQUARE_CORNER_VELOCITY=&lt;value&gt;]</span><br><br><span class="hljs-selector-attr">[VELOCITY=&lt;value&gt;]</span>  <span class="hljs-comment">//速度</span><br><span class="hljs-selector-attr">[ACCEL=&lt;value&gt;]</span>  <span class="hljs-comment">//加速度</span><br><span class="hljs-selector-attr">[MINIMUM_CRUISE_RATIO=&lt;value&gt;]</span>  <span class="hljs-comment">//最小巡航速度</span><br><span class="hljs-selector-attr">[SQUARE_CORNER_VELOCITY=&lt;value&gt;]</span>  <span class="hljs-comment">//角速度</span><br><span class="hljs-selector-attr">[ACCEL_TO_DECEL]</span>  <span class="hljs-comment">//加速减速</span><br></code></pre></td></tr></table></figure><p>3D打印机Z轴正值是向下，负值是向上</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">G1</span> Z1  //K1-MAX向下位移<span class="hljs-number">1</span>mm<br><span class="hljs-attribute">G1</span> Z-.<span class="hljs-number">5</span>  //K1-MAX向上位移到-<span class="hljs-number">0</span>.<span class="hljs-number">5</span>mm<br></code></pre></td></tr></table></figure><p>3D打印机X轴正值是向右，负值是向左</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">G1</span> X1  //K1-MAX向右位移<span class="hljs-number">1</span>mm<br><span class="hljs-attribute">G1</span> X-.<span class="hljs-number">5</span>  //K1-MAX向左位移到-<span class="hljs-number">0</span>.<span class="hljs-number">5</span>mm<br></code></pre></td></tr></table></figure><p>3D打印机X轴正值是向后，负值是向前</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">G1</span> X1  //K1-MAX向后位移<span class="hljs-number">1</span>mm<br><span class="hljs-attribute">G1</span> X-.<span class="hljs-number">5</span>  //K1-MAX向前位移到-<span class="hljs-number">0</span>.<span class="hljs-number">5</span>mm<br></code></pre></td></tr></table></figure><p>EXCLUDE_OBJECT_START 表示当前层上一个对象的gcode开始</p><p>EXCLUDE_OBJECT_END 表示对象在该层的代码的结束</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">EXCLUDE_OBJECT_START <span class="hljs-attribute">NAME</span>=对象名称<br>EXCLUDE_OBJECT_END [<span class="hljs-attribute">NAME</span>=对象名称]<br></code></pre></td></tr></table></figure><p>EXCLUDE_OBJECT_DEFINE</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">EXCLUDE_OBJECT_DEFINE <span class="hljs-selector-attr">[NAME =对象名称[中心= X, Y]</span><span class="hljs-selector-attr">[多边形= [(X, Y),……[reset =1]</span> <span class="hljs-selector-attr">[json =1]</span>  <span class="hljs-comment">//提供文件中一个对象的摘要。</span><br><span class="hljs-comment">//如果没有提供参数，这将列出Klipper已知的已定义对象。返回字符串列表，除非给出了JSON参数，否则它将以JSON格式返回对象详细信息。</span><br><br>&lt;NAME&gt;  <span class="hljs-comment">//当包含NAME参数时，将定义要排除的对象。</span><br><br>&lt;CENTER&gt;  <span class="hljs-comment">//对象的 X，Y 坐标。</span><br><br>&lt;<span class="hljs-selector-tag">POLYGON</span>&gt;  <span class="hljs-comment">//提供对象轮廓的 X,Y 坐标数组</span><br><br><span class="hljs-comment">//当提供RESET参数时，将清除所有已定义的对象，并重置[exclude_object]模块。</span><br></code></pre></td></tr></table></figure><h3 id="G-code-打印流程"><a href="#G-code-打印流程" class="headerlink" title="G-code 打印流程"></a>G-code 打印流程</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">//这个干嘛没搞明白</span><br><span class="hljs-symbol">EXCLUDE_OBJECT_DEFINE</span>  NAME<span class="hljs-symbol">=Square_columns_Z_axis</span>.stl_id_0_copy_0 CENTER<span class="hljs-number">=163</span>.<span class="hljs-number">166</span>,<span class="hljs-number">143</span>.<span class="hljs-number">573</span> POLYGON=[[<span class="hljs-number">58</span>.<span class="hljs-number">702</span>,<span class="hljs-number">39</span>.<span class="hljs-number">1091</span>],[<span class="hljs-number">267</span>.<span class="hljs-number">631</span>,<span class="hljs-number">39</span>.<span class="hljs-number">1091</span>],[<span class="hljs-number">267</span>.<span class="hljs-number">631</span>,<span class="hljs-number">248</span>.<span class="hljs-number">038</span>],[<span class="hljs-number">58</span>.<span class="hljs-number">702</span>,<span class="hljs-number">248</span>.<span class="hljs-number">038</span>],[<span class="hljs-number">58</span>.<span class="hljs-number">702</span>,<span class="hljs-number">39</span>.<span class="hljs-number">1091</span>]]<br><br><span class="hljs-comment">//报告当前进度给控制器，P0是进度为0%，R1210是当前设定的剩余时间</span><br><span class="hljs-symbol">M73</span> <span class="hljs-built_in">P0</span> R1210<br><br><span class="hljs-comment">//关闭P0风扇，没有P参数，默认P0，S代表风扇的模拟量为0，范围是0~255，</span><br><span class="hljs-symbol">M106</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//关闭P2风扇</span><br><span class="hljs-symbol">M106</span> <span class="hljs-built_in">P2</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//关闭热床温度，不进行等待</span><br><span class="hljs-symbol">M140</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//关闭喷头温度，不进行等待，继续执行</span><br><span class="hljs-symbol">M104</span> <span class="hljs-built_in">S0</span> <br><br><span class="hljs-comment">//执行宏定义，在gcode_macro.cfg配置文件中有宏定义函数，作用为开始打印，对打印机进行自动，调节热床和喷头温度</span><br><span class="hljs-symbol">START_PRINT</span> EXTRUDER_TEMP<span class="hljs-number">=220</span> BED_TEMP<span class="hljs-number">=50</span><br><br><span class="hljs-comment">//设定机箱温度为35摄氏度</span><br><span class="hljs-symbol">M141</span> S35<br><br><span class="hljs-comment">//将打印机三轴设为绝对坐标系</span><br><span class="hljs-symbol">G90</span><br><br><span class="hljs-comment">//设置移动单位为毫米</span><br><span class="hljs-symbol">G21</span><br><br><span class="hljs-comment">//设置挤出头为绝对坐标系</span><br><span class="hljs-symbol">M83</span><br><br><span class="hljs-comment">//关闭P0风扇</span><br><span class="hljs-symbol">M106</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//关闭P2风扇</span><br><span class="hljs-symbol">M106</span> <span class="hljs-built_in">P2</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//设置挤出头当前位置为零点</span><br><span class="hljs-symbol">G92</span> E0<br><br><span class="hljs-comment">//使用G1直线移动方式，将挤出头回抽0.6mm，速度为2400mm/min</span><br><span class="hljs-symbol">G1</span> E-.<span class="hljs-number">6</span> F2400<br><br><span class="hljs-comment">//设置加速度为1000mm/min，加减速速度为1000mm/min</span><br><span class="hljs-symbol">SET_VELOCITY_LIMIT</span> ACCEL<span class="hljs-number">=1000</span> ACCEL_TO_DECEL<span class="hljs-number">=1000</span><br><br><span class="hljs-comment">//设置角加速度为20rad/min</span><br><span class="hljs-symbol">SET_VELOCITY_LIMIT</span> SQUARE_CORNER_VELOCITY<span class="hljs-number">=20</span><br><br><span class="hljs-comment">//表示当前层开始打印</span><br><span class="hljs-symbol">EXCLUDE_OBJECT_START</span> NAME<span class="hljs-symbol">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class="hljs-comment">//开始打印，G1直线位移到坐标为(49.789，32.953)位置，速度为30000mm/min</span><br><span class="hljs-symbol">G1</span> X49.<span class="hljs-number">789</span> Y32.<span class="hljs-number">952</span> F30000<br><br><span class="hljs-comment">//Z轴向下移动0.4mm</span><br><span class="hljs-symbol">G1</span> Z.<span class="hljs-number">4</span><br><br><span class="hljs-comment">//开始重复性打印操作</span><br><span class="hljs-symbol">G1</span> X50.<span class="hljs-number">408</span> Y32.<span class="hljs-number">135</span> E.<span class="hljs-number">037</span><br><span class="hljs-symbol">G1</span> X51.<span class="hljs-number">103</span> Y31.<span class="hljs-number">381</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X51.<span class="hljs-number">866</span> Y30.<span class="hljs-number">696</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X52.<span class="hljs-number">691</span> Y30.<span class="hljs-number">087</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X53.<span class="hljs-number">57</span> Y29.<span class="hljs-number">56</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X54.<span class="hljs-number">494</span> Y29.<span class="hljs-number">119</span> E.<span class="hljs-number">03697</span><br><span class="hljs-symbol">G1</span> X55.<span class="hljs-number">682</span> Y28.<span class="hljs-number">701</span> E.<span class="hljs-number">04545</span><br><span class="hljs-symbol">G1</span> X56.<span class="hljs-number">731</span> Y28.<span class="hljs-number">45</span> E.<span class="hljs-number">03897</span><br><span class="hljs-symbol">G1</span> X57.<span class="hljs-number">747</span> Y28.<span class="hljs-number">311</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X58.<span class="hljs-number">707</span> Y28.<span class="hljs-number">268</span> E.<span class="hljs-number">0347</span><br><span class="hljs-symbol">G1</span> X267.<span class="hljs-number">625</span> Y28.<span class="hljs-number">268</span> E7.<span class="hljs-number">5432</span><br><span class="hljs-symbol">G1</span> X268.<span class="hljs-number">655</span> Y28.<span class="hljs-number">317</span> E.<span class="hljs-number">03721</span><br><span class="hljs-symbol">G1</span> X269.<span class="hljs-number">669</span> Y28.<span class="hljs-number">463</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X270.<span class="hljs-number">665</span> Y28.<span class="hljs-number">706</span> E.<span class="hljs-number">03702</span><br><span class="hljs-symbol">G1</span> X271.<span class="hljs-number">632</span> Y29.<span class="hljs-number">041</span> E.<span class="hljs-number">03696</span><br><span class="hljs-symbol">G1</span> X272.<span class="hljs-number">832</span> Y29.<span class="hljs-number">612</span> E.<span class="hljs-number">04796</span><br><span class="hljs-symbol">G1</span> X273.<span class="hljs-number">788</span> Y30.<span class="hljs-number">196</span> E.<span class="hljs-number">04045</span><br><span class="hljs-symbol">...</span><br><br><span class="hljs-comment">//打印进度和时长标记位</span><br><span class="hljs-symbol">M73</span> <span class="hljs-built_in">P0</span> R1208<br><br><span class="hljs-comment">//表示上一层已经打印结束</span><br><span class="hljs-symbol">EXCLUDE_OBJECT_END</span> NAME<span class="hljs-symbol">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class="hljs-comment">//表示当前层开始打印</span><br><span class="hljs-symbol">EXCLUDE_OBJECT_START</span> NAME<span class="hljs-symbol">=Square_columns_Z_axis</span>.stl_id_0_copy_0<br><br><span class="hljs-comment">//关闭P0、P2风扇</span><br><span class="hljs-symbol">M106</span> <span class="hljs-built_in">S0</span><br><span class="hljs-symbol">M106</span> <span class="hljs-built_in">P2</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//结束打印，在gcode_macro.cfg配置文件中有宏定义函数，表示结束打印</span><br><span class="hljs-symbol">END_PRINT</span><br><br><span class="hljs-comment">//设置机箱温度为0</span><br><span class="hljs-symbol">M141</span> <span class="hljs-built_in">S0</span><br><br><span class="hljs-comment">//上传打印进度</span><br><span class="hljs-symbol">M73</span> P100 <span class="hljs-built_in">R0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>3D打印机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D打印机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32的时钟学习</title>
    <link href="/YYang.github.io/2024/07/25/STM32%E7%9A%84%E6%97%B6%E9%92%9F%E5%AD%A6%E4%B9%A0/"/>
    <url>/YYang.github.io/2024/07/25/STM32%E7%9A%84%E6%97%B6%E9%92%9F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32的时钟学习"><a href="#STM32的时钟学习" class="headerlink" title="STM32的时钟学习"></a>STM32的时钟学习</h1><h2 id="时钟SysTick"><a href="#时钟SysTick" class="headerlink" title="时钟SysTick"></a>时钟SysTick</h2><p>时钟一共有五个部分，重装载寄存器、递减计数器、时钟源、时钟中断控制器、校准数值寄存器（用不到）</p><p><img src="https://s2.loli.net/2024/07/27/mbKvAFMpZEVXnd4.png" alt="SysTick.png"></p><h4 id="重装载寄存器-LOAD"><a href="#重装载寄存器-LOAD" class="headerlink" title="重装载寄存器 LOAD"></a>重装载寄存器 LOAD</h4><p>作用就是当递减计数器递减到零时，重新装载计数器，再次进行递减计数</p><h4 id="递减计数器-VAL"><a href="#递减计数器-VAL" class="headerlink" title="递减计数器 VAL"></a>递减计数器 VAL</h4><p>读取时会返回该递减值，如果在该位写入1，则会清理，同时也会清除时钟中断控制器里面的COUNTFLAG</p><h4 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h4><p>提供递减计数器工作的动力源，有外部晶振提供</p><h4 id="时钟中断控制器"><a href="#时钟中断控制器" class="headerlink" title="时钟中断控制器"></a>时钟中断控制器</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">16</span>-COUNTFLAG：如果上次读取该寄存器后，再递减到<span class="hljs-number">1</span>，则该位置为<span class="hljs-number">1</span><br><br><span class="hljs-attribute">2</span>-CLKSOURCE：时钟源选择，<span class="hljs-number">0</span>=AHB/<span class="hljs-number">8</span>=<span class="hljs-number">72</span>/<span class="hljs-number">8</span>=<span class="hljs-number">9</span>M，<span class="hljs-number">1</span>=AHB=<span class="hljs-number">72</span>M<br><br><span class="hljs-attribute">1</span>-TICKINT：递减计数器到零时发出异常请求<br><br><span class="hljs-attribute">0</span>-ENABLE：控制器的使能位<br></code></pre></td></tr></table></figure><h4 id="代码Demo"><a href="#代码Demo" class="headerlink" title="代码Demo"></a>代码Demo</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_systick.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> __INLINE <span class="hljs-type">uint32_t</span> <span class="hljs-title">SysTick_Config</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> ticks)</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-comment">//判断ticks传入的值是否大于 2^24，如果大于则返回错误值</span><br>  <span class="hljs-keyword">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);            <span class="hljs-comment">/* Reload value impossible */</span><br>  <br><span class="hljs-comment">//初始化寄存器reload的值                                  </span><br>  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class="hljs-number">1</span>;      <span class="hljs-comment">/* set reload register */</span><br><br><span class="hljs-comment">//配置时钟中断优先级，1左移四个位，再减1，配置的是15，最低等级</span><br>  <span class="hljs-built_in">NVIC_SetPriority</span> (SysTick_IRQn, (<span class="hljs-number">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class="hljs-number">1</span>);  <span class="hljs-comment">/* set Priority for Cortex-M0 System Interrupts */</span><br>  <br><span class="hljs-comment">//初始化count的值为0</span><br>SysTick-&gt;VAL   = <span class="hljs-number">0</span>;                                          <span class="hljs-comment">/* Load the SysTick Counter Value */</span><br><br><span class="hljs-comment">//时钟配置成72M，使能中断，使能systick</span><br>  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | <br>                   SysTick_CTRL_TICKINT_Msk   | <br>                   SysTick_CTRL_ENABLE_Msk;                    <span class="hljs-comment">/* Enable SysTick IRQ and SysTick Timer */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                                  <span class="hljs-comment">/* Function successful */</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SysTick_Delay_us</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> us)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uint32_t</span> i;<br><br><span class="hljs-comment">//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒</span><br><span class="hljs-built_in">SysTick_Config</span>(<span class="hljs-number">72</span>);<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;us;i++)<span class="hljs-comment">//进行输入值的循环，循环结束则退出</span><br>&#123;<br><span class="hljs-keyword">while</span> (!((SysTick -&gt; CTRL) &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)));<span class="hljs-comment">//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环</span><br>&#125;<br>SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<span class="hljs-comment">//将使能位关闭，停止计时，退出循环</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SysTick_Delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> ms)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uint32_t</span> j;<br><br><span class="hljs-comment">//T=tick/CLKAHB  CLKAHB是配置为 72M，所以中断的时间就是 72/72M=1us 微秒</span><br><span class="hljs-built_in">SysTick_Config</span>(<span class="hljs-number">72000</span>);<br><br><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;ms;j++)<span class="hljs-comment">//进行输入值的循环，循环结束则退出</span><br>&#123;<br><span class="hljs-keyword">while</span> (!((SysTick -&gt; CTRL) &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>)));<span class="hljs-comment">//使用标志位判断是否完成一次循环，如果该位变成1，代表完成循环</span><br>&#125;<br>SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<span class="hljs-comment">//将使能位关闭，停止计时，退出循环</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Systick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gcode学习</title>
    <link href="/YYang.github.io/2024/07/24/Work%20No.4/"/>
    <url>/YYang.github.io/2024/07/24/Work%20No.4/</url>
    
    <content type="html"><![CDATA[<h1 id="Gcode学习"><a href="#Gcode学习" class="headerlink" title="Gcode学习"></a>Gcode学习</h1><h3 id="一、3D打印机编程"><a href="#一、3D打印机编程" class="headerlink" title="一、3D打印机编程"></a>一、3D打印机编程</h3><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://www.klipper3d.org/zh/Overview.html"><a href="https://www.klipper3d.org/zh/G-Codes.html">G-Codes - Klipper 文档 (klipper3d.org)</a></a></p><p><a href="https://reprap.org/wiki/G-code">G-code - RepRap</a></p><p><a href="https://blog.csdn.net/acktomas/article/details/125552309">3D 打印机 G 代码命令：完整列表和教程_3d打印机g代码-CSDN博客</a></p><p><a href="https://blog.csdn.net/qlexcel/article/details/103466638">3D打印机DIY之六——G代码命令_g代码m300-CSDN博客</a></p><h3 id="G指令"><a href="#G指令" class="headerlink" title="G指令"></a>G指令</h3><h4 id="G0-G1-直线移动"><a href="#G0-G1-直线移动" class="headerlink" title="G0&#x2F;G1: 直线移动"></a>G0&#x2F;G1: 直线移动</h4><p>G0和G1命令完全等价，作用就是让喷头线性移动到一个特定的位置，使用时，不需要所有的参数全部存在，但至少要有一个参数。</p><p>G0 Xnnn Ynnn Znnn Ennn Fnnn Snnn &#x2F; G1 Xnnn Ynnn Znnn Ennn Fnnn Snnn</p><p>Xnnn表示X轴的移动位置；</p><p>Ynnn表示Y轴的移动位置；</p><p>Znnn表示Z轴的移动位置；</p><p>Ennn表示E轴（挤出头步进电机）的移动位置；</p><p>Fnnn表示移动速度，单位是毫米&#x2F;每分钟；</p><p>Snnn表示是否检查限位开关，S0不检查，S1检查，缺省值是S0；</p><h4 id="G28：复位"><a href="#G28：复位" class="headerlink" title="G28：复位"></a>G28：复位</h4><p>打印机复位命令。执行时会让3个轴依次往限位开关的方向运行，碰到限位开关后还会减速做一次1mm左右的往返运动，来保证复位的准确性。如果在命令后面加上坐标值，则只会复位坐标值对应的坐标轴。（坐标值的数字会被忽略）</p><p>G28 X0 Y72.3</p><p>只会复位x轴和y轴。</p><h4 id="G29：Z轴高度三点测试"><a href="#G29：Z轴高度三点测试" class="headerlink" title="G29：Z轴高度三点测试"></a>G29：Z轴高度三点测试</h4><p>这条命令会测试打印平面上三个点的Z轴高度，并在串口上输出结果。参数为Snnn，表示对测试结果的处理方式。S1表示更新内存中的Z轴高度值（重置系统会丢失），S2表示更新内存以及EEPROM中的Z轴高度值（重置系统不会丢失）。</p><p>一般来说，只有使用高位限位开关（也就是说，Z轴的限位开关位于Z轴坐标最大处），且在挤出头上附带有Z轴高度测试微动开关的机型，适合使用G29命令测试Z轴高度。其他机械配置的机型，不适合使用G29命令。G29命令由固件配置</p><h4 id="G30：Z轴高度单点测试（单步）"><a href="#G30：Z轴高度单点测试（单步）" class="headerlink" title="G30：Z轴高度单点测试（单步）"></a>G30：Z轴高度单点测试（单步）</h4><p>这条命令作为一个完整Z轴高度测试过程的一步，测试打印平面上一个点的Z轴高度，并在串口上输出结果。这个完整的Z轴高度测试过程，通常是由3D打印机控制软件连续发出的，通过参数控制G30的执行状态。因此在手动工作方式下，G30命令只适合不带参数运行</p><h4 id="G31：输出Z轴高度测试微动开关状态"><a href="#G31：输出Z轴高度测试微动开关状态" class="headerlink" title="G31：输出Z轴高度测试微动开关状态"></a>G31：输出Z轴高度测试微动开关状态</h4><p>执行后会输出当前Z轴高度测试微动开关的当前状态，其中L表示微动开关没有触发。如果是处于触发状态，这里会输出H。</p><p>G29命令、G30命令、G31命令只进行Z轴的高度测试，并不进行自动调平。</p><h4 id="G32：热床自动调平"><a href="#G32：热床自动调平" class="headerlink" title="G32：热床自动调平"></a>G32：热床自动调平</h4><p>这条命令在G29命令的基础上，不仅测试打印平面上三个点的Z轴高度，而且还会根据测试的结果，对3D打印机的机械参数进行调整，实现热床自动调平。G32命令使用的参数与G29命令是一致的：Snnn，表示测试结果的处理方式。S1表示更新内存中的相关参数值（重置系统会丢失），S2表示更新内存以及EEPROM中的相关参数值（重置系统不会丢失）。</p><p>G32命令执行完成时，不仅Z轴高度参数发生了改变，而且还会根据3D打印机的硬件配置，对热床进行相应的调平处理。</p><p>G32命令会在3D打印机内存中构建一个转换矩阵（Transformation matrix），让未来3D打印机所处理的所有三维空间位置，都先经过这个矩阵的变换，保证在Z&#x3D;0的情况下，正好与热床平面完全吻合</p><h4 id="G4-暂停移动"><a href="#G4-暂停移动" class="headerlink" title="G4: 暂停移动"></a>G4: 暂停移动</h4><p>让喷头在当前位置停留一段时间。参数可以为：G4 Pnnn或G4 Snnn。Pnnn表示以毫秒为单位，Snnn表示以秒为单位。</p><p>G4 P2000与G4 S2完全等价，都表示停顿2秒。</p><p>在停顿过程中机器仍可以被控制，如挤出头温度。</p><h4 id="G20-使用英寸作为单位"><a href="#G20-使用英寸作为单位" class="headerlink" title="G20:使用英寸作为单位"></a>G20:使用英寸作为单位</h4><p>执行这条命令后，后面的命令都以英寸作为单位。</p><h4 id="G21-使用毫米作为单位"><a href="#G21-使用毫米作为单位" class="headerlink" title="G21: 使用毫米作为单位"></a>G21: 使用毫米作为单位</h4><p>执行这条命令后，后面的命令都以毫米作为单位。</p><h4 id="G90-G91：设置坐标模式"><a href="#G90-G91：设置坐标模式" class="headerlink" title="G90&#x2F;G91：设置坐标模式"></a>G90&#x2F;G91：设置坐标模式</h4><p>这两条命令用于设置当前坐标模式为绝对坐标模式(G90)或者相对坐标模式(G91)。没有参数。未设置时缺省值是绝对坐标模式</p><h4 id="G92-设置当前位置为某个坐标值"><a href="#G92-设置当前位置为某个坐标值" class="headerlink" title="G92:设置当前位置为某个坐标值"></a>G92:设置当前位置为某个坐标值</h4><p>把当前位置设定为某个坐标值，可以用来设置零点，如果参数为空表示把当前位置设置为所有轴的的零点。</p><p>如：G92 X10 E90    ;表示把当前位置设置为x&#x3D;10，喷头坐标&#x3D;90</p><p>再如：G92 E0       ；表示把当前喷头坐标设置为0</p><h4 id="G94-G95-进给速率单位"><a href="#G94-G95-进给速率单位" class="headerlink" title="G94&#x2F;G95:进给速率单位"></a>G94&#x2F;G95:进给速率单位</h4><p>使用了G94指令之后，所有的进给都是以mm&#x2F;min为单位，即F100指刀具每分钟移动100毫米（默认的）</p><p>使用了G95指令之后，所有的进给都是以mm&#x2F;r为单位，即F100指主轴每转一转，刀具移动100毫米</p><h4 id="G17-G18-G19：选择加工平面"><a href="#G17-G18-G19：选择加工平面" class="headerlink" title="G17&#x2F;G18&#x2F;G19：选择加工平面"></a>G17&#x2F;G18&#x2F;G19：选择加工平面</h4><p>G17–XY平面；</p><p>G18–XZ平面；</p><p>G19–YZ平面；</p><h3 id="M指令"><a href="#M指令" class="headerlink" title="M指令"></a>M指令</h3><h4 id="M0-打印机停止"><a href="#M0-打印机停止" class="headerlink" title="M0:打印机停止"></a>M0:打印机停止</h4><p>打印机会终止任何动作，然后关机。所有的电机和加热器都会被关掉，这个时候只能通过reset按钮来重启控制器。</p><h4 id="M1-打印机休眠"><a href="#M1-打印机休眠" class="headerlink" title="M1: 打印机休眠"></a>M1: 打印机休眠</h4><p>打印机会终止任何动作，然后休眠。所有的马达和加热器都会被关掉，但是接收到G或M命令时，打印机可以被唤醒并进入工作状态。</p><h4 id="M17-启动所有步进电机"><a href="#M17-启动所有步进电机" class="headerlink" title="M17:启动所有步进电机"></a>M17:启动所有步进电机</h4><h4 id="M18-关闭所有步进电机"><a href="#M18-关闭所有步进电机" class="headerlink" title="M18:关闭所有步进电机"></a>M18:关闭所有步进电机</h4><h4 id="M20-读取SD卡根目录中的文件"><a href="#M20-读取SD卡根目录中的文件" class="headerlink" title="M20:读取SD卡根目录中的文件"></a>M20:读取SD卡根目录中的文件</h4><p>读取SD卡根目录的文件，并通过串口输出文件名。</p><h4 id="M21-初始化SD卡"><a href="#M21-初始化SD卡" class="headerlink" title="M21:初始化SD卡"></a>M21:初始化SD卡</h4><p>初始化SD卡。如果在机器通电时插入SD卡，会默认初始化SD卡。开始其他SD卡功能时，SD卡一定要先初始化。本命令相当于文件系统中执行Mount动作。</p><h4 id="M22-卸载SD卡"><a href="#M22-卸载SD卡" class="headerlink" title="M22:卸载SD卡"></a>M22:卸载SD卡</h4><p>卸载SD卡，也就是执行Unmount动作。没有相关的参数。</p><h4 id="M23-选择SD卡中的文件"><a href="#M23-选择SD卡中的文件" class="headerlink" title="M23:选择SD卡中的文件"></a>M23:选择SD卡中的文件</h4><p>选择一个SD卡上的文件。文件选择之后，可以执行打印、删除等动作。</p><p>如：M23 filename.gcode   ;选中filename.gcode文件</p><h4 id="M24-开始打印SD卡中选中的文件"><a href="#M24-开始打印SD卡中选中的文件" class="headerlink" title="M24:开始打印SD卡中选中的文件"></a>M24:开始打印SD卡中选中的文件</h4><p>开始打印通过M23命令选中的文件。</p><h4 id="M25-暂停SD卡打印"><a href="#M25-暂停SD卡打印" class="headerlink" title="M25:暂停SD卡打印"></a>M25:暂停SD卡打印</h4><p>暂停打印通过M23命令选定的文件。</p><h4 id="M27-报告SD卡打印进度"><a href="#M27-报告SD卡打印进度" class="headerlink" title="M27:报告SD卡打印进度"></a>M27:报告SD卡打印进度</h4><p>获取SD卡打印进度。没有相关参数。</p><p>M27命令的输出，格式为：SD printing byte 11518&#x2F;1127578</p><p>这条命令供上位机获取当前的3D打印进度信息，用于显示在电脑界面上。</p><h4 id="M28-开始往SD卡文件中写入数据"><a href="#M28-开始往SD卡文件中写入数据" class="headerlink" title="M28:开始往SD卡文件中写入数据"></a>M28:开始往SD卡文件中写入数据</h4><p>接收到此命令后，后续接收到的命令（除了M29）都会被当成数据写入该文件。</p><p>命令后面会跟着文件名，如果文件不存在则会被创建，如果存在则会被覆盖。接收到这条命令后，后续接收到的命令都会被写入该文件中，直到接收到M29命令。如：M28 filename.gcode  </p><h4 id="M29-停止往SD卡文件中写入数据"><a href="#M29-停止往SD卡文件中写入数据" class="headerlink" title="M29:停止往SD卡文件中写入数据"></a>M29:停止往SD卡文件中写入数据</h4><p>接收到此命令后，后续接收到的命令要开始正常执行。</p><h4 id="M30-删除SD卡中的文件"><a href="#M30-删除SD卡中的文件" class="headerlink" title="M30:删除SD卡中的文件"></a>M30:删除SD卡中的文件</h4><p>如：M30 filename.gcode     ;删除filename.gcode文件</p><h4 id="M32：创建子目录"><a href="#M32：创建子目录" class="headerlink" title="M32：创建子目录"></a>M32：创建子目录</h4><p>在SD卡上创建一个子目录。参数为：filename，表示待创建的子目录（包含目录名，以&#x2F;分隔）；</p><h4 id="M82-M83：设置挤出头步进电机坐标模式"><a href="#M82-M83：设置挤出头步进电机坐标模式" class="headerlink" title="M82&#x2F;M83：设置挤出头步进电机坐标模式"></a>M82&#x2F;M83：设置挤出头步进电机坐标模式</h4><p>与G90&#x2F;G91命令类似，这两条命令用于设置挤出头当前坐标模式为绝对坐标模式(M82)或者相对坐标模式(M83)。没有参数。未设置时缺省值是绝对坐标模式。需要注意的是，G90&#x2F;G91设置的坐标模式，同时对XYZE四个轴起作用，但M82&#x2F;M83设置的坐标模式，只对E轴（挤出头步进电机）起作用。</p><h4 id="M84：设置步进电机自动关闭时间"><a href="#M84：设置步进电机自动关闭时间" class="headerlink" title="M84：设置步进电机自动关闭时间"></a>M84：设置步进电机自动关闭时间</h4><p>当3D打印机一段时间没有接收到步进电机运动指令之后，3D打印机（为了节能）会自动关闭步进电机。使用M84指令，可以设置这个自动关闭步进电机的时间。</p><p>Snnn，表示步进电机关闭的时间，以秒为单位。</p><p>如果使用M85时没有指定S参数，或者使用了S0参数，则代表取消3D打印机自动关闭功能，挤出头、热床等在工作完成之后，一直会处于当前状态，而不会被自动关闭。</p><h4 id="M73：获取当前打印进度"><a href="#M73：获取当前打印进度" class="headerlink" title="M73：获取当前打印进度"></a>M73：获取当前打印进度</h4><p>告诉固件当前的构建进度百分比。预计这台机器会在显示屏上显示出来。如果百分比恰好为0，则向主机发送“构建开始”通知。如果百分比恰好为100，则向主机发送“构建结束”通知。</p><h4 id="M105-获取当前温度（单位：℃）"><a href="#M105-获取当前温度（单位：℃）" class="headerlink" title="M105: 获取当前温度（单位：℃）"></a>M105: 获取当前温度（单位：℃）</h4><p>获取当前温度值，包括挤出头和热床的温度。</p><p>X，表示输出ADC测量的原始值；</p><p>M105命令的输出，格式为：T:18.97 &#x2F;0 B:18.75 &#x2F;0 B@:0 @:0</p><p>T:之后的部分，代表挤出头的当前温度&#x2F;目标温度；</p><p>B:之后的部分代表热床的当前温度&#x2F;目标温度。</p><p>在PID温度控制模式下，B@:后面的数字代表热床当前的输出强度，是一个0<del>255的值，@:后面的数字，代表挤出头当前的输出强度，也是一个0</del>255的值。例子中，挤出头、热床都处于关闭状态，所以这个位置的值都是0。</p><h4 id="M104-设置挤出机（喷头）温度"><a href="#M104-设置挤出机（喷头）温度" class="headerlink" title="M104:设置挤出机（喷头）温度"></a>M104:设置挤出机（喷头）温度</h4><p>设置挤出头的目标温度。执行这条命令后，不需要等待达到这个温度，控制板继续执行下一条G-code语句。</p><p>Snnn，表示目标温度；</p><p>Tnnn，表示对应的挤出头；</p><p>P，表示要等待前面的指令完成之后，再开始设置挤出头温度；</p><p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。F1表示要触发；</p><p>如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。</p><p>如：M104 S190         ;将挤出机的温度设置为190度 </p><h4 id="M106-打开风扇"><a href="#M106-打开风扇" class="headerlink" title="M106: 打开风扇"></a>M106: 打开风扇</h4><p>如：M106 S127    ;打开风扇（半速）。</p><p>‘S’表示 PWM值 (0-255). 可简单理解为：风扇有0-255级强度可选，其中 M106 S0 意味着风扇将被关掉。</p><p>P表示风扇的数目，P0是第一个风扇，P1是第二个风扇</p><h4 id="M109-等待挤出头加热达到目标温度"><a href="#M109-等待挤出头加热达到目标温度" class="headerlink" title="M109: 等待挤出头加热达到目标温度"></a>M109: 等待挤出头加热达到目标温度</h4><p>设置挤出头的目标温度，并等待达到这个温度。</p><p>Snnn，表示目标温度；</p><p>Tnnn，表示对应的挤出头；</p><p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。</p><p>F1表示要触发；</p><p>如果执行命令时没有带T参数，则针对当前挤出头设置目标温度。如： M109 S185      ;等待挤出头加热到185度</p><h4 id="M114-获取挤出头当前位置"><a href="#M114-获取挤出头当前位置" class="headerlink" title="M114: 获取挤出头当前位置"></a>M114: 获取挤出头当前位置</h4><p>输出挤出头当前位置。没有相关的参数。</p><p>M114命令的输出，格式为：</p><p>M114 X:20.00 Y:30.00 Z:10.000 E:0.0000</p><h4 id="M115-获取3D打印机信息"><a href="#M115-获取3D打印机信息" class="headerlink" title="M115: 获取3D打印机信息"></a>M115: 获取3D打印机信息</h4><p>输出3D打印机信息。没有相关的参数。</p><p>M115命令的输出，格式为：FIRMWARE_NAME:Repetier_0.92.3FIRMWARE_URL:…Printedfilament:0.00mPrintingtime:0days0hours0minSpeedMultiply:100FlowMultiply:100</p><p>第一行是固件的版本信息，很长，没有列完整。第二行是已经打印了多少米耗材，打印时间是几天几小时几分钟。第三行是速度系数，参考M220命令。第四行是流率系数，参考M221命令。</p><h4 id="M140-设置热床目标温度"><a href="#M140-设置热床目标温度" class="headerlink" title="M140 设置热床目标温度"></a>M140 设置热床目标温度</h4><p>设置热床的目标温度。执行这条命令后，不需要等待达到这个温度，立即开始执行下一条G-code语句。</p><p>Snnn表示目标温度；</p><p>Fnnn表示到达目标温度之后，是否触发蜂鸣器。</p><p>F1表示要触发；</p><h4 id="M141-设置构建平台的温度"><a href="#M141-设置构建平台的温度" class="headerlink" title="M141:设置构建平台的温度"></a>M141:设置构建平台的温度</h4><p>可能用于特定的温控策略或多热床系统</p><p>M141 S60将加热床设置为60摄氏度</p><h4 id="M190-等待热床加热达到目标温度"><a href="#M190-等待热床加热达到目标温度" class="headerlink" title="M190: 等待热床加热达到目标温度"></a>M190: 等待热床加热达到目标温度</h4><p>设置热床的目标温度，并等待达到这个温度。</p><p>Snnn，表示目标温度；</p><p>Fnnn，表示到达目标温度之后，是否触发蜂鸣器。</p><p>F1表示要触发；</p><h4 id="M204：设置PID参数"><a href="#M204：设置PID参数" class="headerlink" title="M204：设置PID参数"></a>M204：设置PID参数</h4><p>设置挤出头温度控制的PID参数，</p><p>Snnn表示对应的挤出头，无S参数表示使用当前挤出头；</p><p>Xnnn表示P参数；</p><p>Ynnn表示I参数；</p><p>Znnn表示D参数；</p><h4 id="M220：设置速度"><a href="#M220：设置速度" class="headerlink" title="M220：设置速度"></a>M220：设置速度</h4><p>设置3D打印机运行速度系数。</p><p>命令参数为Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；</p><p>3D打印机运行速度系数，是一个在25%到500%范围内变化的值。这个系数值在3D打印机运行过程中，与切片器给出的3D打印机运动速度基础值相乘，得到最终的3D打印机实际运动速度值。</p><p>M220命令的输出，格式为：SpeedMultiply:100</p><h4 id="M221：设置流率"><a href="#M221：设置流率" class="headerlink" title="M221：设置流率"></a>M221：设置流率</h4><p>设置3D打印机的流率系数（Flow rate）。</p><p>命令参数为：Snnn表示系数，是一个百分数，如果S参数不存在，则使用缺省值100；</p><p>3D打印机流率系数，是在上位机切片软件通过耗材直径、喷头直径、层高以及3D打印速度等因素综合计算得到的E轴运动速度的基础上，叠加的一个E轴运动速度系数。简单地说，就是控制挤出头耗材挤出量的多少。这个系数可以在25%到500%范围内变化。</p><p>M221命令的输出，格式为：FlowMultiply:100</p><h3 id="T指令"><a href="#T指令" class="headerlink" title="T指令"></a>T指令</h3><h4 id="T0-T1-T2-T3-命令，选择不同的工具或挤出机"><a href="#T0-T1-T2-T3-命令，选择不同的工具或挤出机" class="headerlink" title="T0&#x2F;T1&#x2F;T2&#x2F;T3 命令，选择不同的工具或挤出机"></a>T0&#x2F;T1&#x2F;T2&#x2F;T3 命令，选择不同的工具或挤出机</h4><p>T0 选择第一个挤出机；T1 选择第二个挤出机；T2 选择第三个挤出机；T3 选择第四个挤出机</p><h4 id="节选注释"><a href="#节选注释" class="headerlink" title="节选注释"></a>节选注释</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dns">M106 P2 S204    //打开第三个风扇，PWM值为<span class="hljs-number">204</span><br><span class="hljs-comment">;LAYER_CHANGE</span><br><span class="hljs-comment">;Z:16.8</span><br><span class="hljs-comment">;HEIGHT:0.199999</span><br><span class="hljs-comment">;BEFORE_LAYER_CHANGE</span><br><span class="hljs-comment">;16.8</span><br>G92 E0    //设置喷头当前位置为零点<br>M106 P2 S0    //关闭第二个风扇<br><br>G1 E-.<span class="hljs-number">35</span> F2400  //挤出机回抽挤出<span class="hljs-number">0</span>.<span class="hljs-number">35m</span>m，速度设置为<span class="hljs-number">2400m</span>m/min<br><span class="hljs-comment">;WIPE_START</span><br>G1 F<span class="hljs-number">9473.877</span>    //速度设置为<span class="hljs-number">9473</span>.<span class="hljs-number">877m</span>m/min<br>G1 X<span class="hljs-number">320.911</span> Y<span class="hljs-number">304.914</span> E-.<span class="hljs-number">11658</span>    //直线插补，移动到（<span class="hljs-number">320.911</span>，<span class="hljs-number">304.914</span>）位置，并回抽<span class="hljs-number">0.11658</span><br>G1 X<span class="hljs-number">321.066</span> Y<span class="hljs-number">304.753</span> E-.<span class="hljs-number">03342</span>    //直线插补，移动到（<span class="hljs-number">321.066</span>，<span class="hljs-number">304.753</span>）位置，并回抽<span class="hljs-number">0.03342</span><br><span class="hljs-comment">;WIPE_END</span><br>EXCLUDE_OBJECT_END NAME=ksr_fdmtest_w4.stl_id_0_copy_0<br><span class="hljs-comment">;_SET_FAN_SPEED_CHANGING_LAYER</span><br>EXCLUDE_OBJECT_START NAME=ksr_fdmtest_w4.stl_id_0_copy_0<br>G17    //选择XY平面<br>G3 Z17 I.<span class="hljs-number">035</span> J-<span class="hljs-number">1</span>.<span class="hljs-number">216</span> P1  F30000    //圆弧插补，Z轴位置为<span class="hljs-number">17m</span>m，圆心坐标为（<span class="hljs-number">321.066</span>+<span class="hljs-number">0</span>.<span class="hljs-number">035，304</span>.<span class="hljs-number">753-1.216</span>）,P1表示为顺时针，速度为<span class="hljs-number">30000m</span>m/min<br>G1 X43.<span class="hljs-number">587</span> Y<span class="hljs-number">296.746</span> Z17    //直线插补，移动到（<span class="hljs-number">321.066</span>，<span class="hljs-number">304.753</span>，<span class="hljs-number">17</span>）位置<br>G1 Z16.<span class="hljs-number">8</span>    //直线插补，移动到（<span class="hljs-number">321.066</span>，<span class="hljs-number">304.753</span>，<span class="hljs-number">16</span>.<span class="hljs-number">8</span>）位置<br>G1 E.<span class="hljs-number">5</span> F2400    //挤出机挤出<span class="hljs-number">0</span>.<span class="hljs-number">5m</span>m，速度设置为<span class="hljs-number">2400m</span>m/min<br></code></pre></td></tr></table></figure><h3 id="二、CNC数控编程"><a href="#二、CNC数控编程" class="headerlink" title="二、CNC数控编程"></a>二、CNC数控编程</h3><h4 id="学习资料-1"><a href="#学习资料-1" class="headerlink" title="学习资料"></a>学习资料</h4><p><a href="http://blog.hubwiz.com/2021/06/26/g-code-tutorial/">数控机床编程入门【G-code】 | 学习软件编程 (hubwiz.com)</a></p><h4 id="G00–快速定位"><a href="#G00–快速定位" class="headerlink" title="G00–快速定位"></a>G00–快速定位</h4><p>G00命令以最大速度将机器从当前位置移动到指定的坐标。机器将同时移动所有轴，以便同时完成行程。 结果是直线移动到新的位置点。</p><h4 id="G01–线性插值"><a href="#G01–线性插值" class="headerlink" title="G01–线性插值"></a>G01–线性插值</h4><p>G01 命令指示机器以设定速度直线移动。我们用X、Y和Z值指定最终位置，用F值指定速度。 CNC控制器计算（插值）要经过的中间点的坐标，以获得直线。</p><h4 id="G02–顺时针环形插值"><a href="#G02–顺时针环形插值" class="headerlink" title="G02–顺时针环形插值"></a>G02–顺时针环形插值</h4><p>G02命令要求机器以圆形模式顺时针移动。它与 G01 命令的概念相同，在执行适当的加工过程时使用。除了 终点参数，在这里我们还需要定义旋转中心，或弧线起点与弧线中心点的距离。起点实际上是上一个命令的 终点或当前点。</p><h4 id="G03–逆时针环形插值"><a href="#G03–逆时针环形插值" class="headerlink" title="G03–逆时针环形插值"></a>G03–逆时针环形插值</h4><p>与 G02 一样，G03 命令指示机器以圆形模式移动，区别在于G03是逆时针运动。所有其他功能和规则与 G02 命令相同。</p><h4 id="G20-G21-–-单位选择"><a href="#G20-G21-–-单位选择" class="headerlink" title="G20&#x2F;G21 – 单位选择"></a>G20&#x2F;G21 – 单位选择</h4><p>G20 和 G21 命令定义 G-code单位，英寸或毫米。G20 &#x3D; 英寸；G21 &#x3D; 毫米</p><h4 id="G17-G18-G18-–-工作面选择"><a href="#G17-G18-G18-–-工作面选择" class="headerlink" title="G17&#x2F;G18&#x2F;G18 – 工作面选择"></a>G17&#x2F;G18&#x2F;G18 – 工作面选择</h4><p>G17–XY平面；G18–XZ平面；G19–YZ平面</p><h4 id="G28–返回home"><a href="#G28–返回home" class="headerlink" title="G28–返回home"></a>G28–返回home</h4><p>G28命令要求机器将移动到其参考点或home位置。为了避免碰撞，我们可以包括一个带有 X、Y 和 Z 参数的 中间点。该工具将在转到参考点之前通过该点。</p><h4 id="G90-G91-–-定位模式"><a href="#G90-G91-–-定位模式" class="headerlink" title="G90&#x2F;G91 – 定位模式"></a>G90&#x2F;G91 – 定位模式</h4><p>使用 G90 和 G91 命令，我们告诉机器如何解析坐标值。G90为绝对模式，G91为相对模式。</p><h4 id="其他代码"><a href="#其他代码" class="headerlink" title="其他代码"></a>其他代码</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>M00–程序停止<br><span class="hljs-bullet">- </span>M02–程序结束<br><span class="hljs-bullet">- </span>M03–主轴打开–顺时针<br><span class="hljs-bullet">- </span>M04–主轴打开–逆时针<br><span class="hljs-bullet">- </span>M05–主轴停止<br><span class="hljs-bullet">- </span>M06–工具更改<br><span class="hljs-bullet">- </span>M08–启用Flood Colant<br><span class="hljs-bullet">- </span>M09–禁用Flood Colant<br><span class="hljs-bullet">- </span>M30 – 程序结束<br><span class="hljs-bullet">- </span>M104–启动挤出加热<br><span class="hljs-bullet">- </span>M109–等到挤出器到达T0<br><span class="hljs-bullet">- </span>M140–开始底板加热<br><span class="hljs-bullet">- </span>M190–等到底板到达T0<br><span class="hljs-bullet">- </span>M106–设置风扇速度<br></code></pre></td></tr></table></figure><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade">%<br>G21 G17 G90 F100                     <span class="hljs-comment">//G21单位选择毫米，G17选择XY平面，G90选择绝对模式，F100代表转速</span><br>M03 S1000                            <span class="hljs-comment">//主轴打开-顺时针，速度为1000转</span><br>G00 X5 Y5                 ; <span class="hljs-built_in">point</span> B  <span class="hljs-comment">//快速移动到（5，5）</span><br>G01 X5 Y5 Z<span class="hljs-number">-1</span>             ; <span class="hljs-built_in">point</span> B  <span class="hljs-comment">//直线插补移动到（5，5，-1）</span><br>G01 X5 Y15 Z<span class="hljs-number">-1</span>            ; <span class="hljs-built_in">point</span> C  <span class="hljs-comment">//直线插补移动到（5，15，-1）</span><br>G02 X9 Y19 Z<span class="hljs-number">-1</span> I4 J0      ; <span class="hljs-built_in">point</span> D  <span class="hljs-comment">//顺时针环形插补移动到（9，19，-1），圆心为（9，15）</span><br>G01 X23 Y19 Z<span class="hljs-number">-1</span>           ; <span class="hljs-built_in">point</span> E  <span class="hljs-comment">//直线插补移动到（23，19，-1）</span><br>G01 X32 Y5 Z<span class="hljs-number">-1</span>            ; <span class="hljs-built_in">point</span> F  <span class="hljs-comment">//直线插补移动到（32，5，-1）</span><br>G01 X21 Y5 Z<span class="hljs-number">-1</span>            ; <span class="hljs-built_in">point</span> G  <span class="hljs-comment">//直线插补移动到（21，5，-1）</span><br>G01 X21 Y8 Z<span class="hljs-number">-1</span>            ; <span class="hljs-built_in">point</span> H  <span class="hljs-comment">//直线插补移动到（21，8，-1）</span><br>G03 X19 Y10 Z<span class="hljs-number">-1</span> I<span class="hljs-number">-2</span> J0    ; <span class="hljs-built_in">point</span> I  <span class="hljs-comment">//逆时针环形插补移动到（19，10，-1），圆心为（19，8）</span><br>G01 X13 Y10 Z<span class="hljs-number">-1</span>           ; <span class="hljs-built_in">point</span> J  <span class="hljs-comment">//直线插补移动到（13，10，-1）</span><br>G03 X11 Y8 Z<span class="hljs-number">-1</span> I0 J<span class="hljs-number">-2</span>     ; <span class="hljs-built_in">point</span> K  <span class="hljs-comment">//逆时针环形插补移动到（11，8，-1），圆心为（13，8）</span><br>G01 X11 Y5 Z<span class="hljs-number">-1</span>            ; <span class="hljs-built_in">point</span> L  <span class="hljs-comment">//直线插补移动到（11，5，-1）</span><br>G01 X5 Y5 Z<span class="hljs-number">-1</span>             ; <span class="hljs-built_in">point</span> B  <span class="hljs-comment">//直线插补移动到（5，5，-1）</span><br>G01 X5 Y5 Z0                         <span class="hljs-comment">//直线插补移动到（5，5，0）</span><br>G28  X0 Y0                           <span class="hljs-comment">//返回零点（0，0，0）</span><br>M05                                  <span class="hljs-comment">//关闭主轴</span><br>M30                                  <span class="hljs-comment">//程序结束</span><br>%<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>3D打印机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32的中断使用</title>
    <link href="/YYang.github.io/2024/07/23/STM32%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BD%BF%E7%94%A8/"/>
    <url>/YYang.github.io/2024/07/23/STM32%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32的中断使用"><a href="#STM32的中断使用" class="headerlink" title="STM32的中断使用"></a>STM32的中断使用</h1><h3 id="内部中断NVIC"><a href="#内部中断NVIC" class="headerlink" title="内部中断NVIC"></a>内部中断NVIC</h3><p>配置过程中，首先初始化 NVIC_InitTypeDef 结构体，配置内部中断线、配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求，最后写入初始化结构体。</p><p>在启动文件 startup_stm32f10x_hd.s 中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在 stm32f10x_it.c 这个库文件中。</p><p>NVIC_IROChannel：用来设置中断源，不同的中断中断源不一样</p><p>系统就在中断向量表中找不到中断服务函数的入口，直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。</p><p>NVIC_PriorityGroupConfig 是整个程序中只需要设置一次，多次设置无效，他只是一种配置方式，具体的分类有主优先级和子优先级有关，他只是提供不同的组合方式，需要根据项目需求进行设计</p><p>从代码布局逻辑来说,NVIC_PriorityGroupConfig 适合放在 main() 函数中。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//定义结构体</span><br>NVIC_InitTypeDef  NVIC_InitStruct<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//NVIC初始化</span><br>NVIC_PriorityGroupConfig<span class="hljs-punctuation">(</span>NVIC_PriorityGroup<span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><span class="hljs-comment">//配置组优先级（0，1，2，3，4，5）</span><br>NVIC_InitStruct.NVIC_IRQChannel <span class="hljs-punctuation">=</span> KEY_INT_EXTI_IRQ<span class="hljs-punctuation">;</span><span class="hljs-comment">//配置内部中断线</span><br>NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority <span class="hljs-punctuation">=</span> PreemptionPriority<span class="hljs-punctuation">;</span><span class="hljs-comment">//配置抢占优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelSubPriority <span class="hljs-punctuation">=</span> SubPriority<span class="hljs-punctuation">;</span><span class="hljs-comment">//配置子优先级</span><br>NVIC_InitStruct.NVIC_IRQChannelCmd <span class="hljs-punctuation">=</span> ENABLE<span class="hljs-punctuation">;</span><span class="hljs-comment">//使能中断通道</span><br>NVIC_Init<span class="hljs-punctuation">(</span><span class="hljs-meta">&amp;NVIC_InitStruct);<span class="hljs-comment">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure><h3 id="外部中断EXTI"><a href="#外部中断EXTI" class="headerlink" title="外部中断EXTI"></a>外部中断EXTI</h3><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。 EXTI 可以实现对每个中断&#x2F;事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。</p><p>所以EXTI的配置，首先需要中断结构体初始化、打开AFIO中断线管理器的时钟、配置中断&#x2F;事件线（20条）、选择中断屏蔽器输入位，并使能、选择中断&#x2F;事件触发类型、选择上升沿或下降沿检测，最后写入初始化结构体</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//定义结构体</span><br>GPIO_InitTypeDef  GPIO_InitStruct<span class="hljs-punctuation">;</span><br>EXTI_InitTypeDef  EXTI_InitStruct<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//配置中断优先级</span><br>EXTI_NVIC_Config<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//按键引脚初始化</span><br>RCC_APB2PeriphClockCmd<span class="hljs-punctuation">(</span>KEY_INT_GPIO_CLK<span class="hljs-punctuation">,</span> ENABLE<span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><span class="hljs-comment">//打开按键时钟</span><br>GPIO_InitStruct.GPIO_Pin <span class="hljs-punctuation">=</span> KEY_INT_GPIO_PIN<span class="hljs-punctuation">;</span><span class="hljs-comment">//按键引脚定义</span><br>GPIO_InitStruct.GPIO_Mode <span class="hljs-punctuation">=</span> GPIO_Mode_IN_FLOATING<span class="hljs-punctuation">;</span><span class="hljs-comment">//选择输入输出模式（浮空输入）</span><br>GPIO_Init<span class="hljs-punctuation">(</span>KEY_INT_GPIO_PORT<span class="hljs-punctuation">,</span><span class="hljs-meta">&amp;GPIO_InitStruct);<span class="hljs-comment">//将结构体进行定义</span></span><br><br><span class="hljs-comment">//中断配置初始化</span><br>RCC_APB2PeriphClockCmd<span class="hljs-punctuation">(</span>KEY_INT_EXTI_CLK<span class="hljs-punctuation">,</span> ENABLE<span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><span class="hljs-comment">//打开AFIO时钟</span><br>GPIO_EXTILineConfig<span class="hljs-punctuation">(</span>KEY_INT_EXTI_PORTSOURCE<span class="hljs-punctuation">,</span> KEY_INT_EXTI_PINSOURCE<span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><span class="hljs-comment">//产生中断的事件线（Px0属于Line0，Px1属于Line1...）</span><br><br>EXTI_InitStruct.EXTI_Line <span class="hljs-punctuation">=</span> KEY_INT_EXTI_LINE<span class="hljs-punctuation">;</span><span class="hljs-comment">//中断屏蔽器输入位的选择，以供EXTI_LineCmd精准使能</span><br>EXTI_InitStruct.EXTI_LineCmd <span class="hljs-punctuation">=</span> ENABLE<span class="hljs-punctuation">;</span><span class="hljs-comment">//中断屏蔽器使能（控制中断接受IMR/EMR）</span><br>EXTI_InitStruct.EXTI_Mode <span class="hljs-punctuation">=</span> EXTI_Mode_Interrupt<span class="hljs-punctuation">;</span><span class="hljs-comment">//选择触发类型（中断触发和事件触发）</span><br>EXTI_InitStruct.EXTI_Trigger <span class="hljs-punctuation">=</span> EXTI_Trigger_Rising<span class="hljs-punctuation">;</span><span class="hljs-comment">//选择模式（上升沿和下降沿）</span><br>EXTI_Init<span class="hljs-punctuation">(</span><span class="hljs-meta">&amp;EXTI_InitStruct);<span class="hljs-comment">//将结构体进行定义</span></span><br></code></pre></td></tr></table></figure><p>前面 4 个线路有单独的中断函数，后面 5 至 9 和 10 至 15 线路使用 复用的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines 在寄存器中都是一一对应状态标位, 中断函数复用，<strong>因此在 EXTI9_5_IRQHandler 和 EXTI15_10_IRQHandler 的中断函数里面使用多次EXTI_GetITStatus 函数来判断出线路。</strong>  </p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">if(EXTI_GetITStatus(EXTI_Line10) != RESET)<br>&#123;<br>LED_TOGGLE;<br>&#125;<br>if(EXTI_GetITStatus(EXTI_Line14) != RESET)<br>&#123;<br>LED_TOGGLE;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中断函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github+HEXO实现网站DIY</title>
    <link href="/YYang.github.io/2024/07/23/Work%20No.6/"/>
    <url>/YYang.github.io/2024/07/23/Work%20No.6/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-HEXO实现网站DIY"><a href="#Github-HEXO实现网站DIY" class="headerlink" title="Github+HEXO实现网站DIY"></a>Github+HEXO实现网站DIY</h1><h3 id="创建github-page网页"><a href="#创建github-page网页" class="headerlink" title="创建github.page网页"></a>创建github.page网页</h3><p>点击Repositories，选择新建Repositories仓库</p><p>在仓库名字Repository name栏填写网页的网址，后缀需要添加 .github.io</p><p>例如 webname.github.io</p><p><img src="https://s2.loli.net/2024/07/25/CagbJOAwjnGZl5h.png" alt="image-20240724153741084.png"></p><p>之后点击 Create repository ，创建该仓库，其他无需调整</p><p>之后需要创建一个 index.html 文件，用于后续能够选取分支</p><p><img src="https://s2.loli.net/2024/07/25/fCE81aVXuvQHwkK.png" alt="image-20240724154237430.png"></p><p>文件名字输入 index.html，内容为 <code>&lt;hl&gt; hello &lt;/hl&gt;</code> 这个文件会初始化成一个网页，网页的内容只有 hello，这个随便填就行，后续会用模板，不用考虑这个</p><p><img src="https://s2.loli.net/2024/07/25/xcCAzGZfilE8pXI.png" alt="image-20240724154427037.png"></p><p>进入仓库，选择 Setting ，点击 pages ，在 branch 上选择 main 分支（刚刚创建文件也是为了创建这个分支），点击 save 保存，之后等待几分钟，就会出现创建的网址，点击 visit site 即可进入建立的网页</p><p><img src="https://s2.loli.net/2024/07/25/iJS68ZOUrkLHKBo.png" alt="image-20240724155135615.png"></p><p>完成这一步之后，就可以得到一个”hello“的网页，该网页没有任何排版和格式</p><h3 id="配置HEXO并进行部署"><a href="#配置HEXO并进行部署" class="headerlink" title="配置HEXO并进行部署"></a>配置HEXO并进行部署</h3><p>打开git bash，执行如下命令安装hexo</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span> <span class="hljs-meta"># 此命令完成对 hexo 的安装</span><br></code></pre></td></tr></table></figure><p>如果没有安装npm、git、node.js的话</p><p>node.js参考<a href="https://blog.csdn.net/yaorongke/article/details/119084295">https://blog.csdn.net/yaorongke/article/details/119084295</a></p><p>git安装参考<a href="https://blog.csdn.net/mukes/article/details/115693833">https://blog.csdn.net/mukes/article/details/115693833</a></p><p>之后随便在想要的地方建一个文件夹，这个文件夹的作用是用于博客文章存放和仓库交互，例如<blog></p><p>进入该文件，将该文件初始化</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> blog <span class="hljs-comment"># 进入该文件夹</span><br><span class="hljs-variable">$</span> hexo init <span class="hljs-comment"># 该命令完成 hexo 在本地博客目录的初始化</span><br></code></pre></td></tr></table></figure><p>之后生成网页的静态文件，如果需要更新网页的配置，需要先清理，在重新生成</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g <span class="hljs-comment"># 生成静态文件，生成的文件在public文件夹里面</span><br><br><span class="hljs-variable">$ </span>hexo clean <span class="hljs-comment"># 清除生成的静态文件</span><br></code></pre></td></tr></table></figure><p>可以进行本地预览，本地预览的ctrl+c会退出运行，所以用右键复制网址到网页上预览</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo s <span class="hljs-comment"># 开启本地预览</span><br></code></pre></td></tr></table></figure><p>安装部署插件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> hexo-deployer-git --save <span class="hljs-comment"># 安装部署插件</span><br></code></pre></td></tr></table></figure><p><code>hexo</code> 有 2 种 <code>_config.yml</code> 文件，一个是根目录下的全局的 <code>_config.yml</code>，一个是各个主体 <code>theme</code> 下的 <code>_config.yml</code>。将前者称为站点配置文件， 后者称为主题配置文件。打开根目录下站点配置文件 <code>_config.yml</code>，配置有关 <code>deploy</code>和<code>url </code>的部分：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"># URL<br>## <span class="hljs-keyword">Set</span> your site url here. <span class="hljs-keyword">For</span> example, <span class="hljs-keyword">if</span> you use GitHub Page, <span class="hljs-keyword">set</span> url <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;https://username.github.io/project&#x27;</span><br>url: GitHub pages的网址，例如https:<span class="hljs-comment">//GitHub用户名/仓库名               //修改这个地方，需要把网址改对，否则网页没有格式</span><br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br>pretty_urls:<br>  trailing_index: <span class="hljs-keyword">true</span> # <span class="hljs-keyword">Set</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">false</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">remove</span> trailing <span class="hljs-string">&#x27;index.html&#x27;</span> <span class="hljs-keyword">from</span> permalinks<br>  trailing_html: <span class="hljs-keyword">true</span> # <span class="hljs-keyword">Set</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">false</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">remove</span> trailing <span class="hljs-string">&#x27;.html&#x27;</span> <span class="hljs-keyword">from</span> permalinks<br><br># Deployment<br>## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span><br>deploy:<br>  <span class="hljs-keyword">type</span>: git<br>  repo: git@github.com:GitHub账户名/仓库名.github.io.git<br>  branch: master #如果分支是main记得修改，需要推送到哪个分支，就选择哪个分支<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/25/Us5zgjtJm8fKQ6X.png" alt="image-20240724161404111.png"></p><p>部署到 GitHub</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo d <span class="hljs-comment"># 将public里面的文件发送到云端GitHub上面</span><br></code></pre></td></tr></table></figure><p>之后就可以刷新网页看到上传上去的网页，就拥有了自己的网页</p><h3 id="主题更换和选择"><a href="#主题更换和选择" class="headerlink" title="主题更换和选择"></a>主题更换和选择</h3><p>我们上面用的是系统默认的主题，比较丑，所以我们可以使用hexo去挑选我们想要的主题类型</p><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98">开始使用 | Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p><p><a href="https://hexo.io/themes/">Themes | Hexo</a>可以在这个网址里面挑选自己喜欢的</p><p>本文挑选了fluid进行下载，选择直接下载zip包或者<code>git clone https://github.com/fluid-dev/hexo-theme-fluid.git</code></p><p>将下载的包解压放到 themes 文件夹里面，文件夹的名字改成fluid，最好不要文件夹套娃，如果出现，则将里面的文件全部移出来</p><p>继续修改博客根目录下的 _config.yml 文件，注意，不是fluid里面的_config.yml文件</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br><br><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br></code></pre></td></tr></table></figure><p>首次使用主题的「关于页」需要手动创建，打开git，输入代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> page about<br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性，<code>layout: about</code> 必须存在，并且不能修改成其他值，否则不会显示头像等样式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>之后重复上面的步骤先进行静态页面清除，再生成，之后上传到GitHub仓库中进行页面更新，等待几分钟后，如下图所示</p><p><img src="https://s2.loli.net/2024/07/25/2wTjGbtilvdkBpW.png" alt="image-20240724162639684.png"></p><h3 id="文档上传"><a href="#文档上传" class="headerlink" title="文档上传"></a>文档上传</h3><p>使用Typora进行.md文档的编写，非常好用的一个编辑器，绿色版可以网上搜索</p><p>之后将md文件放到博客文件夹下面<code>source/_posts/</code>文件夹下面</p><p>之后使用vim编辑器对文档进行title和tag的编辑</p><p><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi&#x2F;vim | 菜鸟教程 (runoob.com)</a></p><p>进入md文件，首先点击 i 进入编辑模式，在开头位置输入，其中title为文章的名字，tag为文章的标签，方便进行检索</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-string">title：</span> <span class="hljs-string">hello</span> <span class="hljs-string">word</span><br><span class="hljs-string">tag：</span> <span class="hljs-string">write</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>编辑完成点击 Esc 退出报错，直接输入 :wq 保存编辑并且退出，完成文件的标记修改</p><p>之后回到git bash中输入</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g <span class="hljs-comment"># 生成静态文件，生成的文件在public文件夹里面</span><br><br><span class="hljs-variable">$ </span>hexo d <span class="hljs-comment"># 将生成的文件导入GitHub站点</span><br></code></pre></td></tr></table></figure><p>到此，等待几分钟后，你的文章就在你的网页上面出现了</p>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github_Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用</title>
    <link href="/YYang.github.io/2024/07/19/Work%20No.5/"/>
    <url>/YYang.github.io/2024/07/19/Work%20No.5/</url>
    
    <content type="html"><![CDATA[<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="git基本了解"><a href="#git基本了解" class="headerlink" title="git基本了解"></a>git基本了解</h2><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://blog.csdn.net/qq_37883866/article/details/105349257">超详细的Git使用教程(图文)-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35206244/article/details/97698815">Git基本使用教程（一）：入门及第一次基本完整操作_git的使用-CSDN博客</a></p><p><a href="https://www.cnblogs.com/Jing-Wang/p/10991008.html">git–一文弄懂git的工作区、索引区、本地仓库、远程仓库以及add、commit、push三个操作 - at_today - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/cposture/p/git.html">【原创】Git删除暂存区或版本库中的文件 - cposture - 博客园 (cnblogs.com)</a></p><p><a href="https://geek-docs.com/git/git-questions/611_git_how_to_remove_a_file_from_the_staging_area_index_cache_in_git.html">Git如何从暂存区（index&#x2F;cache）中移除文件|极客教程 (geek-docs.com)</a></p><p><a href="https://blog.csdn.net/weixin_44567318/article/details/119701438">git status 状态命令——查看文件状态_git status 看非新增文件-CSDN博客</a></p><p><a href="https://www.cnblogs.com/feeland/p/4500721.html">Git 学习（三）本地仓库操作——git add &amp; commit - feesland - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/chaogu94/article/details/111057918">git branch的详细使用，10个常见用法_git branch -vv-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39505245/article/details/124705850">Git基础 - git tag 一文真正的搞懂git标签的使用-CSDN博客</a></p><h3 id="git下载"><a href="#git下载" class="headerlink" title="git下载"></a>git下载</h3><p><strong>官网：</strong> <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h2 id="git使用方法"><a href="#git使用方法" class="headerlink" title="git使用方法"></a>git使用方法</h2><h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><p>账号：1</p><p>密码：1</p><h3 id="git注册"><a href="#git注册" class="headerlink" title="git注册"></a>git注册</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>设置账号，如果去掉 <span class="hljs-params">--global</span> 参数只对当前仓库有效。<br>$ git config <span class="hljs-params">--global</span> user.name <span class="hljs-string">&quot;zhengyiyang&quot;</span><br><br><span class="hljs-string">//</span>设置邮箱，如果去掉 <span class="hljs-params">--global</span> 参数只对当前仓库有效。<br>$ git config <span class="hljs-params">--global</span> user.email <span class="hljs-string">&quot;903372205@qq.com&quot;</span><br><br><span class="hljs-string">//</span>设置SSH，如果去掉 <span class="hljs-params">--global</span> 参数只对当前仓库有效。<br>$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;903372205@qq.com&quot;</span><br><br>储存位置：<span class="hljs-string">/c/Users/114008/.ssh/id_rsa</span><br><br>id_rsa.pub为公共密钥<br>id_rsa为私人密钥<br></code></pre></td></tr></table></figure><h3 id="github配置SSH"><a href="#github配置SSH" class="headerlink" title="github配置SSH"></a>github配置SSH</h3><p><strong>打开id_rsa.pub文件，全选，复制全文</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">ssh</span></span>-rsa AAAAB3NzaC1yc2EA...<br></code></pre></td></tr></table></figure><p><strong>github-&gt;账户-&gt;setting</strong></p><p>Title：1</p><p>Key type：Authentication Key</p><h3 id="测试是否成功连接"><a href="#测试是否成功连接" class="headerlink" title="测试是否成功连接"></a>测试是否成功连接</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ ssh -T git@github.com<br>//代表成功连接<br>Hi yangyangdeyi0119! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.  <br></code></pre></td></tr></table></figure><h3 id="建立Github云端仓库"><a href="#建立Github云端仓库" class="headerlink" title="建立Github云端仓库"></a>建立Github云端仓库</h3><p><a href="https://blog.csdn.net/qq_44722674/article/details/117200397">github仓库建立及配置教程新手教程_github创建仓库-CSDN博客</a></p><p>修改用户名</p><p><a href="https://blog.csdn.net/weixin_44285445/article/details/107833418">GitHub修改昵称和用户名（图解详细教程）_github改名-CSDN博客</a></p><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//首先需要新建一个文件夹作为本地仓库</span><br><span class="hljs-comment">//初始化该文件为本地仓库</span><br><span class="hljs-symbol">$</span> git init  <br><br><span class="hljs-comment">//下载下来的test文件夹也是本地仓库</span><br><span class="hljs-symbol">$</span> git clone https:<span class="hljs-comment">//github.com/yangyangdeyi0119/test.git  </span><br></code></pre></td></tr></table></figure><h3 id="将文件加入暂存区"><a href="#将文件加入暂存区" class="headerlink" title="将文件加入暂存区"></a>将文件加入暂存区</h3><p>文件本身在工作区，需要通过文件锁定，将其加入暂存区</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">//可以同时添加多个文件夹</span><br>$ git <span class="hljs-keyword">add</span> /test /test1<br><br><span class="hljs-comment">//添加单个文件</span><br>$ git <span class="hljs-keyword">add</span> README.md <br>   <br>   <span class="hljs-comment">//将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除  </span><br>$ git <span class="hljs-keyword">add</span> .   <br><br><span class="hljs-comment">//将文件包的所有文件加入暂存区</span><br>$ git <span class="hljs-keyword">add</span> -f .<br>   <br>   <span class="hljs-comment">//将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 </span><br>$ git <span class="hljs-keyword">add</span> -u <br><br><span class="hljs-comment">//表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</span><br>$ git <span class="hljs-keyword">add</span> -A<br><br><span class="hljs-comment">//暂存区各类状态</span><br>- untracked 未跟踪（未被纳入版本控制）<br>- tracked 已跟踪（被纳入版本控制）<br>- Unmodified 未修改状态<br>- Modified 已修改状态<br>- Staged 已暂存状态<br></code></pre></td></tr></table></figure><h3 id="将文件移除暂存区"><a href="#将文件移除暂存区" class="headerlink" title="将文件移除暂存区"></a>将文件移除暂存区</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//仅删除暂存区的文件，不影响工作区的文件</span><br><span class="hljs-symbol">$</span> git rm --cache &lt;<span class="hljs-keyword">file</span>/aaa&gt;<br><br><span class="hljs-comment">//删除暂存区和工作区的文件</span><br><span class="hljs-symbol">$</span> git rm -f &lt;<span class="hljs-keyword">file</span>/aaa&gt;<br><br><span class="hljs-comment">//撤销对暂存区的修改。这个命令主要用于丢弃或还原文件的更改(测试未成功)</span><br><span class="hljs-symbol">$</span> git restore --staged &lt;<span class="hljs-keyword">file</span>/aaa&gt;<br><br><span class="hljs-comment">//将分支回退到之前的提交，并且还可以选择是否保留暂存区的更改</span><br><span class="hljs-symbol">$</span> git reset<br><br><span class="hljs-comment">//撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件file；这个命令改变的是工作区</span><br><span class="hljs-symbol">$</span> git checkout 文件名<br><br></code></pre></td></tr></table></figure><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//获取文件状态-完整</span><br><span class="hljs-symbol">$</span> git status<br><br><span class="hljs-comment">//获取文件状态-简洁</span><br><span class="hljs-symbol">$</span> git status -s 更加简洁<br><span class="hljs-string">&#x27; &#x27;</span> （空格）表示文件未发生更改<br>M 表示文件发生改动。<br>A 表示新增文件。<br>D 表示删除文件。<br>R 表示重命名。<br>C 表示复制。<br>U 表示更新但未合并。<br>? 表示未跟踪文件。<br>! 表示忽略文件。<br><br><span class="hljs-comment">//显示分支和跟踪信息 --branch</span><br><span class="hljs-symbol">$</span> git status -s -b<br><br><span class="hljs-comment">//显示变更的文本内容，在不使用 -s 选项时才会显示变更内容</span><br><span class="hljs-comment">//只有一个 -v 选项时，显示版本库和暂存区之间比较发生变更的内容。</span><br><span class="hljs-symbol">$</span> git status -v<br><span class="hljs-comment">//而有两个 -v 选项时，显示暂存区和工作区之间比较发生变更的内容。</span><br><span class="hljs-symbol">$</span> git status -v -v<br><br><span class="hljs-comment">//显示未跟踪文件</span><br><span class="hljs-symbol">$</span> git status -s -u[&lt;mode&gt;]<br><span class="hljs-keyword">no</span> —— 不显示未跟踪的文件<br><span class="hljs-built_in">normal</span> —— 显示未跟踪的文件和目录。<br><span class="hljs-keyword">all</span> —— 还显示了未跟踪目录下的文件<br><br><span class="hljs-comment">//用来查看暂存区中文件信息</span><br><span class="hljs-symbol">$</span> git ls-<span class="hljs-keyword">files</span> -参数<br>--cached(-c)显示暂存区中的文件，git ls-<span class="hljs-keyword">files</span>命令默认的参数<br>--deleted(-d)显示删除的文件<br>--modified(-m) 显示修改过的文件<br>--other(-o)显示没有被git跟踪的文件<br>--stage(-s) 显示mode以及文件对应的Blob对象，进而我们可以获取暂存区中对应文件里面的内容。<br></code></pre></td></tr></table></figure><h3 id="文件加入分支"><a href="#文件加入分支" class="headerlink" title="文件加入分支"></a>文件加入分支</h3><p>提交更改，实际上就是把暂存区的所有内容提交到当前分支，需要提交的文件修改通通放到暂存区；然后，一次性提交暂存区的所有修改</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 把暂存区的所有修改提交到分支，须输入描述信息</span><br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&quot;描述信息&quot;</span><br><br><span class="hljs-comment">//更改之前一次commit的描述信息</span><br><span class="hljs-symbol">$</span> git commit --amend<br><br><span class="hljs-comment">//提交暂存区的指定文件到仓库区（不行，最好单个提交git add，然后在git commit）</span><br><span class="hljs-symbol">$</span> git commit &lt;file1&gt; &lt;file2&gt; ... -m <span class="hljs-string">&quot;message&quot;</span><br><br><span class="hljs-comment">//-a 参数设置修改文件后不需要执行 git add 命令，直接来提交（不好用）</span><br><span class="hljs-symbol">$</span> git commit -a<br><br>出现报错<span class="hljs-string">&quot;nothing to commit, working tree clean&quot;</span><br>   只需要修改该文件夹下的任意一个文件，因为检测到版本未发生改变<br>   <br>   <span class="hljs-comment">//查找推送版本号</span><br>   <span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> <br>   <br>   <span class="hljs-comment">//选择回退版本，回退后，版本之后的将会丢失</span><br>   git reset --hard &lt;目标版本号&gt;<br>   <br>   <span class="hljs-comment">//软回退，不修改代码，回到暂存区</span><br>   git reset --soft HEAD~n<br>   <br>   <span class="hljs-comment">//只显示一行信息</span><br>   git <span class="hljs-built_in">log</span> --oneline<br></code></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//创建分支命令</span><br><span class="hljs-symbol">$</span> git branch &lt;branchname&gt;<br><br><span class="hljs-comment">//切换分支命令</span><br><span class="hljs-symbol">$</span> git checkout &lt;branchname&gt;<br><br><span class="hljs-comment">//列出分支</span><br>git branch<br><span class="hljs-comment">//查看本地分支+上次提交的信息</span><br><span class="hljs-symbol">$</span> git branch -v<br><span class="hljs-comment">//查看本地分支+远程分支</span><br><span class="hljs-symbol">$</span> git branch -a<br>- 红色代表云端仓库分支<br>- 白色代表本地仓库分支<br>- 绿色代表目前所在分支<br><span class="hljs-comment">//查看本地分支+上次提交的信息+本地和远程分支的关系</span><br><span class="hljs-symbol">$</span> git branch -vv<br><span class="hljs-comment">//查看本地分支+上次提交的信息+本地和远程分支的关系+远程分支</span><br><span class="hljs-symbol">$</span> git branch -vv -a<br><span class="hljs-comment">//只查看远程分支</span><br><span class="hljs-symbol">$</span> git branch -r<br><br><span class="hljs-comment">//创建新分支并立即切换到该分支下</span><br><span class="hljs-symbol">$</span> git checkout -b &lt;branchname&gt;<br><br><span class="hljs-comment">//删除本地分支</span><br><span class="hljs-symbol">$</span> git branch -d &lt;branchname&gt;<br><span class="hljs-comment">//强制删除分支</span><br><span class="hljs-symbol">$</span> git branch -D aaa<br><br><span class="hljs-comment">//合并分支</span><br><span class="hljs-symbol">$</span> git merge &lt;branchname&gt;<br><br><span class="hljs-comment">//删除远程分支</span><br><span class="hljs-symbol">$</span> git push &lt;主机名&gt; -d &lt;分支名&gt;<br><br><span class="hljs-comment">//将本地分支推送到远程分支，如果远程分支不存在，则创建。</span><br><span class="hljs-symbol">$</span> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br><span class="hljs-symbol">$</span> git push --<span class="hljs-keyword">set</span>-upstream <span class="hljs-comment">origin dev</span><br></code></pre></td></tr></table></figure><h3 id="将文件推送到云端仓库"><a href="#将文件推送到云端仓库" class="headerlink" title="将文件推送到云端仓库"></a>将文件推送到云端仓库</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">//第一次推送代码指令<br>$ git push -u origin &lt;branchname&gt;<span class="hljs-comment"></span><br><span class="hljs-comment">//-u参数可以在推送的同时,将origin仓库的master分支设置为本地仓库当前分支的upstream(上游)。添加了这个参数,将来运行git pull命令从远程仓库获取内容时,本地仓库的的这个分支就可以直接从origin的master分支获取内容,省去了另外添加参数的麻烦。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">//之后推送</span><br>$ git push origin master<br><span class="hljs-comment"></span><br><span class="hljs-comment">//不同分支之间推送</span><br>$ git push -u origin &lt;branchname1&gt;:origin/&lt;branchname2&gt;<br><span class="hljs-comment"></span><br><span class="hljs-comment">//云端仓库分支更新到本地仓库</span><br>$ git remote update origin<br>后缀加上 <span class="hljs-comment">--prune则可以与云端仓库分支一致，多余的会被删除</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">//报错</span><br>error: failed <span class="hljs-built_in">to</span> push some refs <span class="hljs-built_in">to</span> <span class="hljs-string">&#x27;https://github.com/yangyangdeyi0119/Learning.git&#x27;</span><br>hint: Updates were rejected because <span class="hljs-keyword">the</span> remote <span class="hljs-keyword">contains</span> work that you <span class="hljs-built_in">do</span> <span class="hljs-keyword">not</span><br>hint: have locally. This is usually caused <span class="hljs-keyword">by</span> another repository pushing <span class="hljs-built_in">to</span><br>hint: <span class="hljs-keyword">the</span> same ref. If you want <span class="hljs-built_in">to</span> integrate <span class="hljs-keyword">the</span> remote changes, use<br>hint: <span class="hljs-string">&#x27;git pull&#x27;</span> <span class="hljs-keyword">before</span> pushing again.<br>hint: See <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br>直接git pull之后就可以了<br><span class="hljs-comment"></span><br><span class="hljs-comment">//删除现有远程仓库</span><br>$ git remote rm origin<br><span class="hljs-comment"></span><br><span class="hljs-comment">//添加新远程仓库</span><br>$ git remote <span class="hljs-built_in">add</span> origin url<br><span class="hljs-comment"></span><br><span class="hljs-comment">//查看远程仓库的地址</span><br>$ git remote -v<br><span class="hljs-comment"></span><br><span class="hljs-comment">//更换远程仓库地址，URL为新地址</span><br>$ git remote <span class="hljs-built_in">set</span>-url origin <span class="hljs-built_in">URL</span><br></code></pre></td></tr></table></figure><h3 id="暂存空间使用"><a href="#暂存空间使用" class="headerlink" title="暂存空间使用"></a>暂存空间使用</h3><p>stash是本地的，不会通过git push命令上传到git server上</p><p>发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑git stash。</p><p>使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用git stash就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用git stash apply将以前一半的工作应用回来。</p><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//将未提交的修改保存至堆栈中</span><br><span class="hljs-symbol">$</span> git stash<br><br><span class="hljs-comment">//为此次stash添加说明信息，便于以后查看</span><br><span class="hljs-symbol">$</span> git stash save <span class="hljs-string">&quot;stash message info&quot;</span>  <br><br><span class="hljs-comment">//查看stash栈中的内容</span><br><span class="hljs-symbol">$</span> git stash list<br><br><span class="hljs-comment">//将stash中的内容弹出，并应用到当前分支对应的工作目录上，该命令将堆栈中最近保存的内容删除（出栈操作）</span><br><span class="hljs-symbol">$</span> git stash pop<br><br><span class="hljs-comment">//将指定id的内容应用到当前分支的工作目录，内容不会删除，可以在多个分支上重复进行操作</span><br><span class="hljs-symbol">$</span> git stash apply stash名称<br><br><span class="hljs-comment">//从堆栈中移除某个指定的stash</span><br><span class="hljs-symbol">$</span> git stash drop stash名称<br><br><span class="hljs-comment">//清除堆栈中的所有内容</span><br><span class="hljs-symbol">$</span> git stash clear<br><br><span class="hljs-comment">//查看堆栈中最新保存的stash和当前目录的差异。</span><br><span class="hljs-symbol">$</span> git stash show<br><br><span class="hljs-comment">//从最新的stash创建分支。</span><br><span class="hljs-symbol">$</span> git stash branch<br></code></pre></td></tr></table></figure><h3 id="代码标签"><a href="#代码标签" class="headerlink" title="代码标签"></a>代码标签</h3><p>tag 中文我们可以称它为标签，tag 就是 对某次 commit 的一个标识，相当于起了一个别名。</p><p>【轻量标签 】： 只是某个commit 的引用，可以理解为是一个commit的别名；</p><p>【附注标签】 ：是存储在git仓库中的一个完整对象，包含打标签者的名字、电子邮件地址、日期时间以及其他的标签信息。它是可以被校验的，可以使用 GNU Privacy Guard (GPG) 签名并验证。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//直接列出所有的标签</span><br><span class="hljs-symbol">$</span> git tag<br><br><span class="hljs-comment">//可以根据&lt;tagname&gt;进行标签的筛选</span><br><span class="hljs-symbol">$</span> git tag -l &lt;tagname*&gt;<br><br><span class="hljs-comment">//查看标签的提交信息</span><br><span class="hljs-symbol">$</span> git show 标签名<br><br><span class="hljs-comment">//在提交历史中查看标签</span><br><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --online --graph<br><br><span class="hljs-comment">//创建轻量标签</span><br><span class="hljs-symbol">$</span> git tag 标签名<br><span class="hljs-symbol">$</span> git tag 标签名 提交版本<br><br><span class="hljs-comment">//创建附注标签</span><br><span class="hljs-symbol">$</span> git tag -a 标签名称 -m 附注信息<br><span class="hljs-symbol">$</span> git tag -a 标签名称 提交版本号 -m 附注信息<br>-a : 理解为 annotated 的首字符，表示 附注标签<br><br><span class="hljs-comment">//删除标签</span><br>git tag -d 标签名称<br><br><span class="hljs-comment">//将指定的标签上传到远程仓库</span><br><span class="hljs-symbol">$</span> git push origin &lt;tagname&gt;<br><br><span class="hljs-comment">//将所有不在远程仓库中的标签上传到远程仓库</span><br><span class="hljs-symbol">$</span> git push origin --tags<br><br><span class="hljs-comment">//删除远程仓库中的 指定标签</span><br><span class="hljs-symbol">$</span> git push origin  :regs/tags/&lt;tagname&gt;<br><span class="hljs-symbol">$</span> git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32程序逻辑及GPIO使用</title>
    <link href="/YYang.github.io/2024/07/10/STM32%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%8F%8AGPIO%E4%BD%BF%E7%94%A8/"/>
    <url>/YYang.github.io/2024/07/10/STM32%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%8F%8AGPIO%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32程序逻辑及GPIO使用"><a href="#STM32程序逻辑及GPIO使用" class="headerlink" title="STM32程序逻辑及GPIO使用"></a>STM32程序逻辑及GPIO使用</h1><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><h4 id="1-创建在USER文件夹中创建想要的文件夹，例如bsp-led，主要用来存放C文件和h文件"><a href="#1-创建在USER文件夹中创建想要的文件夹，例如bsp-led，主要用来存放C文件和h文件" class="headerlink" title="1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件"></a>1.创建在USER文件夹中创建想要的文件夹，例如bsp_led，主要用来存放C文件和h文件</h4><h4 id="bsp-led-c"><a href="#bsp-led-c" class="headerlink" title="bsp_led.c"></a>bsp_led.c</h4><p>主要用来构建所需程序的函数体（比如配置、驱动等等）</p><p>#include “bsp_led.h”用来调用各种东西</p><h4 id="bsp-led-h"><a href="#bsp-led-h" class="headerlink" title="bsp_led.h"></a>bsp_led.h</h4><p>主要用来给bsp_led.c文件提供库函数支持</p><p>以及bsp_led.c所需的宏定义，都可以放在该文件夹中</p><p>将bsp_led.c中的函数放入</p><p>采用#ifndef和#endif的方式，实现头文件的判断编译，防止多次编译报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __BSP_LED_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __BSP_LED_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_G_PIN         GPIO_Pin_0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_G_PORT        GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_G_CLK         RCC_APB2Periph_GPIOB</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LED_GPIO_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __BSP_LED_H */</span></span><br></code></pre></td></tr></table></figure><h4 id="2-在主函数中调用-include-“bsp-led-h”即可使用bsp-led-c中编写的各类函数"><a href="#2-在主函数中调用-include-“bsp-led-h”即可使用bsp-led-c中编写的各类函数" class="headerlink" title="2.在主函数中调用#include “bsp_led.h”即可使用bsp_led.c中编写的各类函数"></a>2.在主函数中调用#include “bsp_led.h”即可使用bsp_led.c中编写的各类函数</h4><h2 id="GPIO设置"><a href="#GPIO设置" class="headerlink" title="GPIO设置"></a>GPIO设置</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//定义关键字</span><br>GPIO_InitTypeDef  GPIO_InitS<span class="hljs-attr">truct</span><span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//选择引脚，将硬件部分定义成宏，方便移植</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_G_PIN         GPIO_Pin_0</span><br>GPIO_InitStruct.GPIO_P<span class="hljs-attr">in</span> <span class="hljs-operator">=</span> GPIO_G_PIN<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//选择输出方式</span><br>GPIO_InitStruct.GPIO_M<span class="hljs-attr">ode</span> <span class="hljs-operator">=</span> GPIO_Mode_Out_PP<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//选择速度</span><br>GPIO_InitStruct.GPIO_S<span class="hljs-attr">peed</span> <span class="hljs-operator">=</span> GPIO_Speed_50MHz<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//配置引脚</span><br>GPIO_Init(GPIO_G_PORT,<span class="hljs-variable">&amp;</span>GPIO_InitStruct)<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//启动时钟</span><br>RCC_APB2PeriphClockCmd(GPIO_G_CLK, ENABLE)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境安装和配置</title>
    <link href="/YYang.github.io/2024/07/09/Work%20No.1/"/>
    <url>/YYang.github.io/2024/07/09/Work%20No.1/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux环境安装和配置"><a href="#Linux环境安装和配置" class="headerlink" title="Linux环境安装和配置"></a>Linux环境安装和配置</h1><h2 id="一、安装VMware（16-17）"><a href="#一、安装VMware（16-17）" class="headerlink" title="一、安装VMware（16&#x2F;17）"></a>一、安装VMware（16&#x2F;17）</h2><p>安装版本：VMware® Workstation 16 Pro</p><p>安装保姆链接：<a href="https://blog.csdn.net/weixin_74195551/article/details/127288338">安装虚拟机（VMware）保姆级教程（附安装包）_vmware虚拟机-CSDN博客</a></p><p>破解链接：<a href="https://www.52pojie.cn/thread-1804571-1-1.html">VMware Workstation虚拟机合集+激活密钥_Win+Linux_10∕11∕12∕14∕15∕16∕17 - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p>破解码：ZF3R0-FHED2-M80TY-8QYGC-NPKYF</p><p>MobaXtem链接：<a href="https://blog.csdn.net/qq_42578036/article/details/107710339">VMware虚拟机配置、连接MobaXterm_mobaxtem怎么连接虚拟机-CSDN博客</a></p><p>终极链接：<a href="https://blog.csdn.net/lhl_blog/article/details/123406322">保姆级教程|VMware安装Ubuntu20.04(系统安装+网络配置+open-vm-tools安装+国内软件源更新)-CSDN博客</a></p><p>报错：</p><p>VMware Workstation 无法连接到虚拟机</p><p>点开虚拟机“属性”，在“兼容性”里面设置为以管理员身份运行此程序。</p><p>VMware创建新的虚拟机，弹出“您已输入用户名，客户机操作将保留此用户名”错误提示</p><p>【root】被系统占用了，让用户新建一个低权限的账户，修改用户名，不要再使用【root】，如：改为【user】或【your_name】</p><p>VMware Ubuntu ping 百度不通</p><p>选择 虚拟机-&gt;设置-&gt;网络适配器-&gt;自定义特定虚拟网络-&gt;选择VMnet1(桥接网络)-&gt;确定</p><p>目的是确定我们使用的是VMnet1(桥接网络)，之后就可以ping通</p><p>安装磁盘管理工具gparted并运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gparted<br><span class="hljs-built_in">sudo</span> gparted<br></code></pre></td></tr></table></figure><p>报错是权限不足,那么修改挂载点的权限即可(注:所谓”挂载”的概念体现的是Linux”一切皆文件”的思想,物理世界中的一块硬盘在Linux系统的逻辑中也被映射为一个文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mount -o remount -rw / <br><span class="hljs-built_in">sudo</span> mount -o remount -rw /var/snap/firefox/common/host-hunspell<br></code></pre></td></tr></table></figure><h2 id="二、安装Ubuntu（22-04）"><a href="#二、安装Ubuntu（22-04）" class="headerlink" title="二、安装Ubuntu（22.04）"></a>二、安装Ubuntu（22.04）</h2><p>安装版本：Linux Ubuntu22.04.4</p><p>安装保姆链接：<a href="https://blog.csdn.net/weixin_42640280/article/details/128351105">ubuntu 22.04下载安装_ubuntu22.04下载-CSDN博客</a></p><p>清华源：<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>步骤指令</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo su <span class="hljs-comment">//进入管理者模式</span><br><br>apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span> <span class="hljs-comment">//更新apt</span><br><br>apt-<span class="hljs-built_in">get</span> install net-tools <span class="hljs-comment">//安装ifconfig相关配件</span><br><br>apt-<span class="hljs-built_in">get</span> install openssh-server <span class="hljs-comment">//下载和安装ssh</span><br><br>service ssh restart <span class="hljs-comment">//启动ssh</span><br></code></pre></td></tr></table></figure><h2 id="三、安装应用依赖第三方库"><a href="#三、安装应用依赖第三方库" class="headerlink" title="三、安装应用依赖第三方库"></a>三、安装应用依赖第三方库</h2><p>将工程导入虚拟机中，tar -xvf 解压工程包</p><p>git clone 的所有包的位置可以随机放置，但是需要对每个包进行编译，编译参照readme文件或者网上查找，如果下载不下来，可以直接去官网直接下载zip格式，使用unzip xxx.zip进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install -y build-essential libsdl2-dev<br><br>git <span class="hljs-built_in">clone</span> http://172.23.88.26:3333/zhangyufeng/libcrlog.git  //按照readme文档可以编译<br><br><span class="hljs-built_in">sudo</span> apt-get install  libjson-c-dev<br><br>git <span class="hljs-built_in">clone</span> https://github.com/protocolbuffers/protobuf.git<br>//没安装成功，bash: ./autogen.sh: No such file or directory<br>//在晚上的时候安装成功了，原因是高版本的缺失了./autogen.sh脚本，进行降版本就可以了，花费4小时<br>//终极感谢博主：https://blog.csdn.net/jax_fanyang/article/details/135937002<br><br>    1.11 点击链接下载3.21.12版本源码。https://github.com/protocolbuffers/protobuf/releases/tag/v2<br>    1.12 <span class="hljs-built_in">cd</span> protobuf-21.12/<br>    1.13 ./autogen.sh<br>    1.14 ./configure --prefix=/usr/local/protobuf<br>    1.15 make<br>    1.16 <span class="hljs-built_in">sudo</span> make install<br>    1.17 <span class="hljs-built_in">sudo</span> vim /etc/profile<br>    1.18 <span class="hljs-comment">#添加以下内容：</span><br><br>    <span class="hljs-comment">#(动态库搜索路径) 程序加载运⾏期间查找动态链接库时指定除了系统默认路径之外的其他路径</span><br>    <span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/usr/local/protobuf/lib/<br>    <span class="hljs-comment">#(静态库搜索路径) 程序编译期间查找动态链接库时指定查找共享库的路径</span><br>    <span class="hljs-built_in">export</span> LIBRARY_PATH=<span class="hljs-variable">$LIBRARY_PATH</span>:/usr/local/protobuf/lib/<br>    <span class="hljs-comment">#执⾏程序搜索路径</span><br>    <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/protobuf/bin/<br>    <span class="hljs-comment">#c程序头⽂件搜索路径</span><br>    <span class="hljs-built_in">export</span> C_INCLUDE_PATH=<span class="hljs-variable">$C_INCLUDE_PATH</span>:/usr/local/protobuf/include/<br>    <span class="hljs-comment">#c++程序头⽂件搜索路径</span><br>    <span class="hljs-built_in">export</span> CPLUS_INCLUDE_PATH=<span class="hljs-variable">$CPLUS_INCLUDE_PATH</span>:/usr/local/protobuf/include/<br>    <span class="hljs-comment">#pkg-config 路径</span><br>    <span class="hljs-built_in">export</span> PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/<br>    1.18 <span class="hljs-built_in">source</span> /etc/profile<br>    1.19  protoc --version <br>    执行之后应该看到==libprotoc 3.21.12==如果出现这个版本信息则安装成功<br>    <br>git <span class="hljs-built_in">clone</span> https://github.com/protobuf-c/protobuf-c  //按照readme文档可以编译<br><br>git <span class="hljs-built_in">clone</span> https://github.com/eclipse/paho.mqtt.c.git<br><br>bash<br>    <span class="hljs-built_in">cd</span> paho.mqtt.c<br>    <span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>    cmake ..<br>    make<br>    <span class="hljs-built_in">sudo</span> make install<br><br>git <span class="hljs-built_in">clone</span> https://github.com/eclipse/paho.mqtt.cpp.git（1.3.10）  //安装失败<br><br>git <span class="hljs-built_in">clone</span> https://github.com/aliyun/aliyun-oss-cpp-sdk.git<br><br>    <span class="hljs-built_in">cd</span> &lt;path/to/aliyun-oss-cpp-sdk&gt;<br>    <span class="hljs-built_in">mkdir</span> build<br>    <span class="hljs-built_in">cd</span> build<br>    cmake ..<br>    <br>    <span class="hljs-built_in">sudo</span> apt-get install libcurl4-openssl-dev libssl-dev<br>    make<br><br>git <span class="hljs-built_in">clone</span> https://github.com/open-source-parsers/jsoncpp.git<br><br>    <span class="hljs-built_in">mkdir</span> -p build/debug<br>    <span class="hljs-built_in">cd</span> build/debug<br>    cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G <span class="hljs-string">&quot;Unix Makefiles&quot;</span> ../..<br>    make<br><br><span class="hljs-built_in">sudo</span> apt install libapr1-dev<br><br><span class="hljs-built_in">sudo</span> apt install libaprutil1-dev<br><br><span class="hljs-built_in">sudo</span> apt install libmxml-dev<br><br><span class="hljs-built_in">sudo</span> apt-get install uuid-dev <br><br>git <span class="hljs-built_in">clone</span> https://github.com/aliyun/aliyun-oss-c-sdk.git //好像安装有点问题<br><br>    ./configure<br>    make<br>    make install<br><br>https://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/attach/102787/cn_zh/1558078831675/VodSDK-C_1.0.0.tar.gz?spm=a2c4g.11186623.0.0.65c71cd50vaal4&amp;file=VodSDK-C_1.0.0.tar.gz //不知道怎么安装<br><br>//找阿里云帮忙实现：[使用C/C++ SDK上传文件_视频点播(VOD)-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/vod/developer-reference/upload-sdk-for-c-or-cpp?spm=a2c4g.11186623.0.0.61dd2c16XPqrTn#multiTask7060)<br><br>    cmake .<br>    make<br>    make install<br><br>git <span class="hljs-built_in">clone</span> https://github.com/ithewei/libhv<br><br>    <span class="hljs-built_in">mkdir</span> build<br>    <span class="hljs-built_in">cd</span> build<br>    cmake ..<br>    cmake --build .<br><br><span class="hljs-built_in">sudo</span> apt-get install libboost-all-dev<br><br>git <span class="hljs-built_in">clone</span> https://github.com/inotify-tools/inotify-tools.git//安装不知道成没成功<br><br><span class="hljs-built_in">sudo</span> apt-get install libfreeimage3 libfreeimage-dev<br><br>git <span class="hljs-built_in">clone</span> https://github.com/dpilger26/NumCpp.git<br><br><span class="hljs-built_in">sudo</span> apt-get install libavformat-dev<br><br><span class="hljs-built_in">sudo</span> apt-get install libswscale-dev<br></code></pre></td></tr></table></figure><h2 id="四、在PC上编译运行应用"><a href="#四、在PC上编译运行应用" class="headerlink" title="四、在PC上编译运行应用"></a>四、在PC上编译运行应用</h2><p>make 编译程序</p><p>make clean 清除编译</p><p>头文件所在位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/i</span>nclude/<br><br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/include/</span><br><br>cp  -r <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/include/</span>vod_sdk<span class="hljs-regexp">/ /u</span>sr<span class="hljs-regexp">/include/</span>vod_sdk<span class="hljs-regexp">/  /</span><span class="hljs-regexp">/缺失upload.h头文件，将他进行复制到usr/i</span>nclude/文件夹当中<br><br>- 安装依赖<br>  sudo apt install libjson-c-dev<br><br>- 编译<br>  make<br><br>- 安装<br>  sudo make install<br><br>- 更新系统动态库<br>  sudo ldconfig<br></code></pre></td></tr></table></figure><p>运行项目</p><p>先获得虚拟设备参数，导入config中”&#x2F;home&#x2F;user&#x2F;creality&#x2F;userdata&#x2F;config&#x2F;“</p><p>开始编译主程序  make clean &amp;&amp; make -j4（j4、j8代表进程速度，越高越快）</p><p>获得各个文件的单独运行包，在vscode中运行.&#x2F;master-server，即可跑通实体机</p><p>linux中&#x2F;opt目录用来<strong>安装附加软件包</strong>，是用户级的程序目录，可以理解为D:&#x2F;Software。 安装到&#x2F;opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。</p><h2 id="五、交叉编译到目标板运行"><a href="#五、交叉编译到目标板运行" class="headerlink" title="五、交叉编译到目标板运行"></a>五、交叉编译到目标板运行</h2><p>交叉编译讲解：<a href="https://blog.csdn.net/lc315yuhuofei/article/details/103782049">交叉编译入门及必要配置方法总结_gcc-manifest.txt-CSDN博客</a></p><p>虚拟机交叉编译教程：<a href="https://www.cnblogs.com/zblblog/p/18136017">立创泰山派学习05-虚拟机ubuntu安装交叉编译工具 - zbl1118 - 博客园 (cnblogs.com)</a></p><h2 id="六、知识点总结"><a href="#六、知识点总结" class="headerlink" title="六、知识点总结"></a>六、知识点总结</h2><h4 id="1-交叉编译知识点"><a href="#1-交叉编译知识点" class="headerlink" title="1.交叉编译知识点"></a>1.交叉编译知识点</h4><p>交叉编译的目的是在一台架构A主机平台上编译另一种架构B目标平台的二进制文件或者库，交叉编译在目标系统平台（开发出来的应用程序序所运行的平台）难以或不容易编译时非常有用。 完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上</p><p>主机平台：PC端 Windows 10 专业工作站版</p><p>目标平台：Linux Ubuntu22.04.4&#x2F;VMware® Workstation 16 Pro</p><p>通常交叉编译工具链命名规则为：arch-core-kernel-system</p><p>arch：目标平台架构，如上文提到的arm，mips等；</p><p>core：有两种种情况，第一是CPU Core，如Cortex A8；第二是指定工具链的供应商。如果没有特殊指定，则留空不填。这一组命名比较灵活，有以厂家名称命名的，有以开发者命名的，也有以开发板命名的，或者直接是none或cross的；</p><p>kernel： 目标平台的OS，见过的有linux，uclinux，bare-metal（无OS）；</p><p>system：嵌入式应用二进制接口（Embedded Application Binary Interface），交叉编译工具链所选择的库函数和目标映像的规范，如gnu，gnueabi等。其中gnu等价于glibc+oabi；gnueabi等价于glibc+eabi。若不指定，则也可以留空不填；</p><p>上述命名规则并不是统一的规范，使用的时候作为参考就行。我使用的交叉编译工具链名称为：gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu。</p><p>获取交叉编译工具链两个途径：</p><p>直接下载知名厂家已经编译好的工具链。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.linaro.org<span class="hljs-regexp">/downloads/</span><br>http:<span class="hljs-regexp">//</span>ftp.arm.linux.org.uk<span class="hljs-regexp">/pub/</span>armlinux<span class="hljs-regexp">/toolchain/</span><br>http:<span class="hljs-regexp">//</span>www.denx.de<span class="hljs-regexp">/en/</span>Software/WebHome<br>https:<span class="hljs-regexp">//</span>launchpad.net/gcc-arm-embedded<br></code></pre></td></tr></table></figure><p>自己编译交叉编译工具链</p><p>编译交叉编译工具链的工具：crosstool-NG、Buildroot、Embedded Linux Development Kit (ELDK)</p><h4 id="2-Linux-系统编程知识点"><a href="#2-Linux-系统编程知识点" class="headerlink" title="2.Linux 系统编程知识点"></a>2.Linux 系统编程知识点</h4><p><a href="https://developer.aliyun.com/article/1457993">Linux 系统编程从入门到进阶 学习指南-阿里云开发者社区 (aliyun.com)</a></p><p>什么是库函数？</p><p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p><p><a href="https://www.cnblogs.com/realjimmy/p/12844359.html">Linux C函数库大全 - 一觉醒来写程序 - 博客园 (cnblogs.com)</a></p><p>参考手册：<a href="https://wizardforcel.gitbooks.io/linux-c-api-ref/content/index.html">介紹 | Linux C API 参考手册 (gitbooks.io)</a></p><p><strong>进程究竟是什么？</strong></p><p>每当你启动一个程序，Linux 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p><p><strong>1.管道 （Pipe）</strong></p><p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p><p><strong>2.信号 (Signals)</strong></p><p>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p><p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p><p><strong>3.文件(Files)</strong></p><p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p><p><strong>4.信号量(Semaphores)</strong><br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p><p><strong>5.共享内存(Shared Memory)</strong><br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p><p><strong>6.消息队列 (Message Queues)</strong></p><p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p><p><strong>7.套接字 (Sockets)</strong></p><p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p><h2 id="七、常用指令"><a href="#七、常用指令" class="headerlink" title="七、常用指令"></a>七、常用指令</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br>uname <span class="hljs-operator">-</span>m <span class="hljs-comment">/*查看系统架构*/</span><br>lscpu <span class="hljs-comment">/*查看更多CPU情况*/</span><br><br>tar <span class="hljs-operator">-</span>vxf [xxx.tar.gz压缩包]<br>mv [现在的位置] [将要移动的位置]<br><br>pip list <span class="hljs-comment">/*罗列所有的安装包*/</span><br><br>make clean  <span class="hljs-comment">/*清理编译*/</span><br>make <span class="hljs-operator">&amp;&amp;</span> make install  <span class="hljs-comment">/*开始编译*/</span><br><br>cp  <span class="hljs-operator">-</span>r <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/include/</span>vod_sdk<span class="hljs-operator">/</span> <span class="hljs-regexp">/usr/</span>include<span class="hljs-regexp">/vod_sdk/</span>  <span class="hljs-comment">/*复制文件夹到另一个文件夹上*/</span><br><br>sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> autoremove xxx  <span class="hljs-comment">/*卸载*/</span><br></code></pre></td></tr></table></figure><p>常用指令汇总：<a href="https://developer.aliyun.com/article/1561151?spm=a2c6h.12873639.article-detail.33.657a1be0lxiKr4&scm=20140722.ID_community@@article@@1561151._.ID_community@@article@@1561151-OR_rec-V_1-RL_community@@article@@1457993">linux 常用命令【编程必备】-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32固件库及工程文件概念</title>
    <link href="/YYang.github.io/2024/06/30/STM32%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%8F%8A%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E6%A6%82%E5%BF%B5/"/>
    <url>/YYang.github.io/2024/06/30/STM32%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%8F%8A%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32固件库及工程文件概念"><a href="#STM32固件库及工程文件概念" class="headerlink" title="STM32固件库及工程文件概念"></a>STM32固件库及工程文件概念</h1><h2 id="STM32固件库整体结构"><a href="#STM32固件库整体结构" class="headerlink" title="STM32固件库整体结构"></a>STM32固件库整体结构</h2><pre><code class="hljs"> 1-汇编编写的启动文件 startup_stm32f10x_hd.s:设置堆栈指针、设置PC指针、初始化中断向量表、配置系统时钟、调用c库函数_main最终去到c的世界  2-时钟配置文件 system_stm32f10x.c:把外部时钟HSE=8M，经过PLL倍频为72M。  3-外设相关的 stm32f10x.h:实现了内核之外的外设的寄存器映射xxx:GPIO、USRAT、I2c、SPI、FSMC stm32f10x_xx.c:外设的驱动函数库文件 stm32f10x_xx.h:存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库函数的声明  4-内核相关的 CMSIs - Cortex 微控制器软件接口标准 core_cm3.h:实现了内核里面外设的寄存器映射 core_cm3.c NVIC(嵌套向量中断控制器)、sysTick(系统滴答定时器)  ST公司裁剪后的内核文件 misc.h misc.c  5-头文件的配置文件 stm32f10x_conf.h:头文件的头文件 / / stm32f10x_usart.h / / stm32f10x_i2c.h / / stm32f10x_spi.h / / stm32f10x_adc.h / / stm32f10x_fsmc.h  6-专门存放中断服务函数的c文件 stm32f10x_it.c stm32f10x_it.h  中断服务函数你可以随意放在其他的地方，并不是一定要放在stm32f10x_it.c  #include &quot;stm32f10x.h&quot;//相当于51单片机中的#include &lt;reg51.h&gt; int main (void) &#123;     //来到这里的时候，系统的时钟已经被配置成72M &#125;</code></pre><h3 id="文件设置"><a href="#文件设置" class="headerlink" title="文件设置"></a>文件设置</h3><h4 id="1-设置创建项目文件夹，并在文件夹内设置四个文件"><a href="#1-设置创建项目文件夹，并在文件夹内设置四个文件" class="headerlink" title="1.设置创建项目文件夹，并在文件夹内设置四个文件"></a>1.设置创建项目文件夹，并在文件夹内设置四个文件</h4><h4 id="①Libraries："><a href="#①Libraries：" class="headerlink" title="①Libraries："></a>①Libraries：</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">内核相关文件（core_c<span class="hljs-name">m3.</span>c、core_c<span class="hljs-name">m3.</span>h）<br><br>启动文件（startup_st<span class="hljs-name">m32</span>f<span class="hljs-number">10</span>x_hd）<br><br>时钟配置文件（system_st<span class="hljs-name">m32</span>f<span class="hljs-number">10</span>x.c、system_st<span class="hljs-name">m32</span>f<span class="hljs-number">10</span>x.h）<br><br>外设文件（st<span class="hljs-name">m32</span>f<span class="hljs-number">10</span>x.h和固件库h.c文件）<br></code></pre></td></tr></table></figure><h4 id="②Project"><a href="#②Project" class="headerlink" title="②Project"></a>②Project</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">KEIL工程文件<br><br>输出<span class="hljs-built_in">HEX</span>文件，用于准备烧录<br></code></pre></td></tr></table></figure><h4 id="③User"><a href="#③User" class="headerlink" title="③User"></a>③User</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">用户程序放置<br><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>文件<br></code></pre></td></tr></table></figure><h4 id="④Doc"><a href="#④Doc" class="headerlink" title="④Doc"></a>④Doc</h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">README.<span class="hljs-built_in">md</span>文档<br></code></pre></td></tr></table></figure><h4 id="2-打开工程，创建五个文件夹"><a href="#2-打开工程，创建五个文件夹" class="headerlink" title="2.打开工程，创建五个文件夹"></a>2.打开工程，创建五个文件夹</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">STARTUP：导入启动文件<br><br>CMSIS：导入内核文件和时钟配置文件<br><br>FWLIB：导入固件库<br><br>USER：导入<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>文件和用户文件<br><br>DOC：导入README文件<br></code></pre></td></tr></table></figure><h4 id="3-所有设计到头文件的文件夹配置到系统环境中"><a href="#3-所有设计到头文件的文件夹配置到系统环境中" class="headerlink" title="3.所有设计到头文件的文件夹配置到系统环境中"></a>3.所有设计到头文件的文件夹配置到系统环境中</h4><h4 id="4-开始编译全文件"><a href="#4-开始编译全文件" class="headerlink" title="4.开始编译全文件"></a>4.开始编译全文件</h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>keil软件芯片包：<a href="https://www.keil.arm.com/packs/stm32f1xx_dfp-keil/boards/">Arm Keil | Keil STM32F1xx_DFP</a></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>Reason: Pack <a href="https://so.csdn.net/so/search?q=schema&spm=1001.2101.3001.7020">schema</a> version ‘1.4.0’ is not supported. Maximum supported <a href="https://so.csdn.net/so/search?q=version&spm=1001.2101.3001.7020">version</a> is’1.3’. Please update to a newer version of MDK-ARM. 使用keil5 MDK安装芯片包时出错（软件版本过低）</p><p><img src="https://s2.loli.net/2024/07/25/HgserB9cVJfObdM.png" alt="image-20240531210625344.png"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>根据弹窗的内容我们可知我们需要对MDK进行升级，在升级时我们直接覆盖安装。</p><p>官方下载渠道：<a href="https://www.keil.com/download/product/">https://www.keil.com/download/product/</a><br>填写相关信息便可进行下载。</p><p>破解keil出现出现you are not logged in as an administrator….的问题，请退出软件，右击软件图标，以管理员身份运行，重新进行安装操作！然后就安装成功了！</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>固件库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP通信</title>
    <link href="/YYang.github.io/2024/05/27/20240529ZYY-1_TCP%E9%80%9A%E4%BF%A1/"/>
    <url>/YYang.github.io/2024/05/27/20240529ZYY-1_TCP%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h1><h2 id="一、QT服务端构建"><a href="#一、QT服务端构建" class="headerlink" title="一、QT服务端构建"></a>一、QT服务端构建</h2><ul><li>该模块将采用上位机作为服务端，下位机作为客户端进行连接，前提需要保证服务端、客户端处于同一局域网内，处于同一个端口号，IPv4地址一样，服务端的IPv4需要查阅该电脑本身IP，无法进行修改，选用默认方式。</li></ul><h3 id="①TCP的概念"><a href="#①TCP的概念" class="headerlink" title="①TCP的概念"></a>①TCP的概念</h3><ul><li><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。消息是没有边界的，所以无论消息大小都可以进行传输。消息是有序的，当前一个消息没有收到，即使先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。</p></li><li><p>TCP传输里面，需要Socket，上位机需要设置Socket，就好像找了一把锁，下位机需要上报Socket，就好像插上钥匙开锁，如果一样，那就可以进行连接，Socket：由IP地址和端口号组成</p></li></ul><h3 id="②代码实现"><a href="#②代码实现" class="headerlink" title="②代码实现"></a>②代码实现</h3><ul><li>首先在mainwindow.h头文件函数里面添加所需头文件，如果报错，检查配置环境是否缺失，问网上教程，不赘述。之后还需要定义TCP通信对象，用于数据的读取和调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//TCP服务端</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QTcpServer&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QTcpSocket&gt;</span></span><br><br><span class="hljs-comment">//创建TCP通讯对象</span><br>QTcpSocket *socket;<br>QTcpServer *server;<br></code></pre></td></tr></table></figure><ul><li>之后在mainwindow.cpp主函数里面进行TCP的初始化定义，将头文件定义的对象指向接下来要读取的函数，并采用connect函数，将新的客户端于newConnection_SLOT()槽函数连接</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs axapta">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>    , ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>    <br><span class="hljs-comment">//TCP通讯定义</span><br>    socket = <span class="hljs-keyword">new</span> QTcpSocket();<br>    <span class="hljs-keyword">server</span> = <span class="hljs-keyword">new</span> QTcpServer();<br><br>    <span class="hljs-comment">//信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据</span><br>    connect(<span class="hljs-keyword">server</span>,SIGNAL(newConnection()),<span class="hljs-keyword">this</span>,SLOT(newConnection_SLOT()));<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>newConnection_SLOT()槽函数用于初始化设置，并监听客户端信息，如果接收到缓存信息，触发readyRead_SLOT()槽函数进行数据的读取和打印</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::newConnection_SLOT</span><span class="hljs-params">()</span><span class="hljs-comment">//定义TCP</span></span><br><span class="hljs-function"></span>&#123;<br>    socket = server-&gt;<span class="hljs-built_in">nextPendingConnection</span>(); <span class="hljs-comment">//获取已经连接的客户端套接字</span><br>    <span class="hljs-built_in">connect</span>(socket,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">readyRead</span>()),<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">readyRead_SLOT</span>()));<span class="hljs-comment">//如果socket中有缓存消息，触发槽函数</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>readyRead_SLOT()函数主要进行读取客户端发来的缓存消息，并写入Receive_text当中</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> MainWindow::readyRead_SLOT()<span class="hljs-comment">//接收消息并显示到接收框</span><br>&#123;<br>    qDebug() &lt;&lt; <span class="hljs-string">&quot;Server Received!&quot;</span>;<br>    QString <span class="hljs-built_in">buffer</span>;<br>    <span class="hljs-comment">//读取缓冲区数据</span><br>    <span class="hljs-built_in">buffer</span> = socket-&gt;readAll();<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">isEmpty</span>())<br>    &#123;<br>        <span class="hljs-comment">//刷新显示</span><br>        ui-&gt;Receive_text-&gt;appendPlainText(<span class="hljs-built_in">buffer</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该类型函数配置完，基本上可以实现监听、读写功能，但是缺少用户对它的触发，所以再编写一个触发函数，按下on_Monitor_OPEN_clicked(bool checked)函数，既可以将PORT_TEXT文本中用户定义的端口号写入socket中，并进行发送，如果未连接成功，将按键复位。如果连接成功，再次点击该按钮，则停止监听，断开TCP连接。</li></ul><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs zephir">void MainWindow::on_Monitor_OPEN_clicked(<span class="hljs-keyword">bool</span> checked)<span class="hljs-comment">//打开TCP监听</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(checked)<br>    &#123;<br>        <span class="hljs-keyword">int</span> port = ui-&gt;PORT_TEXT-&gt;text().toUInt();<br>        <span class="hljs-comment">//如果未监听到</span><br>        <span class="hljs-keyword">if</span>(!server-&gt;listen(QHostAddress::Any, port))<br>        &#123;<br>            qDebug() &lt;&lt; server-&gt;errorString();<br>            <span class="hljs-comment">//连接失败，再次点击则重新连接，将checked恢复为true</span><br>            ui-&gt;Monitor_OPEN-&gt;toggle();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;Listen Successfully! Message from port:&quot;</span> &lt;&lt; port;<br>        <span class="hljs-comment">//修改按钮文字</span><br>        ui-&gt;Monitor_OPEN-&gt;setText(<span class="hljs-string">&quot;停止监听&quot;</span>);<br>        <span class="hljs-comment">//发送键使能</span><br>        ui-&gt;Send_Button-&gt;setEnabled(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>         qDebug() &lt;&lt; <span class="hljs-string">&quot;Stop Listening!&quot;</span>;<br>        <span class="hljs-comment">//如果已经连接则断开连接</span><br>        <span class="hljs-keyword">if</span>(socket-&gt;state() == QAbstractSocket::ConnectedState)<br>        &#123;<br>            <span class="hljs-comment">//断开连接</span><br>            socket-&gt;disconnectFromHost();<br>        &#125;<br>        <span class="hljs-comment">//关闭倾听服务</span><br>        server-&gt;close();<br>        <span class="hljs-comment">//修改按钮文字&amp;发送键静默</span><br>        ui-&gt;Monitor_OPEN-&gt;setText(<span class="hljs-string">&quot;开始监听&quot;</span>);<br>        ui-&gt;Send_Button-&gt;setEnabled(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、TCP服务端-客户端通信"><a href="#二、TCP服务端-客户端通信" class="headerlink" title="二、TCP服务端-客户端通信"></a>二、TCP服务端-客户端通信</h2><ul><li>基于上述设置后，用户就可以根据自己的想法去定义端口号，并随时打开和关闭监听端口，我们还需要设置一些Debug窗口来进行发送和接收内容的打印及调试。首先在mainwindow.h头文件函数里面添加所需头文件。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//文本编辑</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QLineEdit&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>之后撰写发送槽函数，该槽函数主要是读取输入框的内容，写入socket中，并利用socket-&gt;write()函数，将内容通过TCP通信传输到下位机当中，并利用 socket-&gt;flush()函数刷新重置缓冲区</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void MainWindow::on_Send_Button_clicked()<span class="hljs-comment">//发送数据</span><br>&#123;<br><span class="hljs-comment">//主要用于调试</span><br>    <span class="hljs-function"><span class="hljs-title">qDebug</span>() &lt;&lt; &quot;Server Send: &quot; &lt;&lt; ui-&gt;</span>S<span class="hljs-function"><span class="hljs-title">end_text</span>-&gt;</span>toPlainText().toLatin1();<br>    <span class="hljs-comment">//将输入框的内容写入socket缓冲区</span><br>    <span class="hljs-function"><span class="hljs-title">socket</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">write</span>(ui-&gt;</span>S<span class="hljs-function"><span class="hljs-title">end_text</span>-&gt;</span>toPlainText().toLatin1());<br>    <span class="hljs-comment">//刷新socket缓冲区</span><br>    <span class="hljs-function"><span class="hljs-title">socket</span>-&gt;</span>flush();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>而后定义两个简单的槽函数，利用clear()函数对发送区和接收区进行清空</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void MainWindow::on_Receive_CLEAR_clicked()<span class="hljs-comment">//回收框清屏</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-title">ui</span>-&gt;</span>R<span class="hljs-function"><span class="hljs-title">eceive_text</span>-&gt;</span>clear();<br>&#125;<br><br>void MainWindow::on_Send_CLEAR_clicked()<span class="hljs-comment">//发送框清屏</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-title">ui</span>-&gt;</span>S<span class="hljs-function"><span class="hljs-title">end_text</span>-&gt;</span>clear();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hi3861开发</title>
    <link href="/YYang.github.io/2024/05/17/20240429ZYY-Hi3861%E5%BC%80%E5%8F%91/"/>
    <url>/YYang.github.io/2024/05/17/20240429ZYY-Hi3861%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Hi3861开发"><a href="#Hi3861开发" class="headerlink" title="Hi3861开发"></a>Hi3861开发</h1><h2 id="一、学习资料"><a href="#一、学习资料" class="headerlink" title="一、学习资料"></a>一、学习资料</h2><ul><li><p>【UART串口使用】<a href="https://blog.csdn.net/qq_36347513/article/details/121603716">HI3861学习笔记（18）——UART串口使用_hi3861 uart-CSDN博客</a></p></li><li><p>【开发环境搭建】[2.1 Pegasus开发环境搭建.md · HiSpark&#x2F;HiSpark_NICU2023 - Gitee.com](<a href="https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1">https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/2.1</a> Pegasus开发环境搭建.md)</p></li><li><p>【入门demo】<a href="https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/quick-start/quickstart-ide-3861-helloworld.md">编写 Hello World”程序 (openharmony.cn)</a></p></li><li><p>【UART串口读取】<a href="https://bbs.huaweicloud.com/blogs/detail/281809">HarmonyOS小熊派 | HarmonyOS基础外设开发–UART数据读写-云社区-华为云 (huaweicloud.com)</a></p></li><li><p>【QT转EXE格式】<a href="https://www.cnblogs.com/JinShanCheShen/p/16194526.html">QT打包成exe详细步骤 - 西北小蚂蚁 - 博客园 (cnblogs.com)</a></p></li><li><p>【QT转EXE格式编译报错】<a href="https://blog.csdn.net/weijifen000/article/details/102537640">Qt软件打包后报错“无法定位程序输入点_ZN10QArrayData10deallocateEPs_jj于动态链接库….. .exe上。”解决办法-CSDN博客</a></p></li></ul><h2 id="二、QT开发"><a href="#二、QT开发" class="headerlink" title="二、QT开发"></a>二、QT开发</h2><ul><li><p>geometry里的宽度、高度是分辨率，比如geometry设置为宽<em>高为1920</em>1080</p></li><li><p>【窗口自适应】<a href="https://cloud.tencent.com/developer/article/2286080">【QT】QT Designer控件随窗口大小自适应-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li><li><p>【串口发送】<a href="https://blog.csdn.net/qq_26904271/article/details/132646641">QT串口助手：识别串口号，发送，接收，十六进制_qt串口发送16进制数据-CSDN博客</a></p></li><li><p>foreach是QT中的一个关键字，其作用是对第二个参数中的对象进行遍历，把遍历过程中的每个对象依次赋给第一个参数，并执行花括号中的内容。在这里，就是把可获取的串口列表availablePorts()中的串口，逐个将其串口号添加到combobox中。</p></li></ul><h3 id="1-串口设定"><a href="#1-串口设定" class="headerlink" title="1.串口设定"></a>1.串口设定</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl"> <span class="hljs-comment">//mainwindow.h文件调用串口头文件</span><br> <span class="hljs-comment">//串口头文件</span><br> #include &lt;QSerialPort&gt;<br>#include &lt;QSerialPortInfo&gt;<br> <br> <span class="hljs-comment">//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br> <span class="hljs-comment">//使用foreach函数查找串口信息</span><br>foreach (const QSerialPortInfo &amp;portInfo,QSerialPortInfo::availablePorts()) <br> &#123;<br>     <span class="hljs-comment">//将所有搜索的值写入serialport端口当中</span><br>     <span class="hljs-function"><span class="hljs-title">ui</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">serialport</span>-&gt;</span>addItem(portInfo.portName());<br> &#125;<br> <span class="hljs-comment">//打开串口</span><br> <span class="hljs-function"><span class="hljs-title">serialPort</span>-&gt;</span>open();<br> <span class="hljs-comment">//关闭串口</span><br> <span class="hljs-function"><span class="hljs-title">serialPort</span>-&gt;</span>close();<br> <br> <span class="hljs-comment">//串口写入</span><br> <span class="hljs-function"><span class="hljs-title">serialPort</span>-&gt;</span>write(<span class="hljs-string">&quot;*****&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-读取下拉选项内容并赋予"><a href="#2-读取下拉选项内容并赋予" class="headerlink" title="2.读取下拉选项内容并赋予"></a>2.读取下拉选项内容并赋予</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//mainwindow.cpp文件中，自定义函数设定</span><br><br><span class="hljs-comment">//定义参数格式为QString</span><br>QString mBaudrate;<span class="hljs-comment">//波特率</span><br>QString mStopBits;<span class="hljs-comment">//停止位字节</span><br>   QString mDataBits;<span class="hljs-comment">//数据字节</span><br>   QString mParity;<span class="hljs-comment">//奇偶校验</span><br>   <br><span class="hljs-comment">//读取baudrate槽中currentText()所选定的内容，后续类似</span><br><span class="hljs-function"><span class="hljs-title">mBaudrate</span> = ui-&gt;</span><span class="hljs-function"><span class="hljs-title">baudrate</span>-&gt;</span>currentText();<br><span class="hljs-function"><span class="hljs-title">mStopBits</span> = ui-&gt;</span><span class="hljs-function"><span class="hljs-title">stopbits</span>-&gt;</span>currentText();<br>   <span class="hljs-function"><span class="hljs-title">mDataBits</span> = ui-&gt;</span><span class="hljs-function"><span class="hljs-title">databits</span>-&gt;</span>currentText();<br>   <span class="hljs-function"><span class="hljs-title">mParity</span> = ui-&gt;</span><span class="hljs-function"><span class="hljs-title">parity</span>-&gt;</span>currentText();<br><br><span class="hljs-comment">//判断起选定内容是否符合需求，并赋予相应操作</span><br><span class="hljs-keyword">if</span>(mBaudrate == <span class="hljs-string">&quot;9600&quot;</span>) <br>&#123;<br><span class="hljs-comment">//将串口波特率设定为9600</span><br>       mSerialPort.setBaudRate(QSerialPort::Baud9600);<span class="hljs-comment">//Baud9600、Baud115200</span><br>       mSerialPort.setStopBits(QSerialPort::OneStop);<span class="hljs-comment">//OneStop-1、OneAndHalfStop-1.5、TwoStop-2</span><br>       mSerialPort.setDataBits(QSerialPort::Data5);<span class="hljs-comment">//Data5、Data6、Data7、Data8</span><br>       mSerialPort.setParity(QSerialPort::OddParity);<span class="hljs-comment">//OddParity-奇校验、EvenParity-偶校验、NoParity无校验</span><br>   &#125; <br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mBaudrate == <span class="hljs-string">&quot;115200&quot;</span>) <br>   &#123;<br>   <span class="hljs-comment">//将串口波特率设定为115200</span><br>       mSerialPort.setBaudRate(QSerialPort::Baud19200);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-摄像头设定"><a href="#3-摄像头设定" class="headerlink" title="3.摄像头设定"></a>3.摄像头设定</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//***.pro格式文件加入multimediawidgets</span><br>QT       += core gui multimediawidgets<br><br><span class="hljs-comment">//mainwindow.h文件调用摄像头头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QCameraImageCapture&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QCamera&gt;</span></span><br><br><span class="hljs-comment">//mainwindow.cpp文件中的MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br><span class="hljs-comment">//获取系统的所有可用的摄像头</span><br>foreach(const QCameraInfo <span class="hljs-variable">&amp;</span>cameraInfo , QCameraInfo::availableCameras())<br>   <span class="hljs-punctuation">&#123;</span><br>       <span class="hljs-comment">//将所有搜索的值写入cameraBox端口当中</span><br>       ui-&gt;cameraBox-&gt;addItem(cameraInfo.deviceName())<span class="hljs-punctuation">;</span><br>   <span class="hljs-punctuation">&#125;</span><br>   <br>   <span class="hljs-comment">//打开摄像头</span><br>   cameraPort-&gt;start()<span class="hljs-punctuation">;</span><br>   <span class="hljs-comment">//关闭摄像头</span><br>   cameraPort-&gt;stop()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h3 id="4-QT中setCheckable-的作用"><a href="#4-QT中setCheckable-的作用" class="headerlink" title="4.QT中setCheckable()的作用"></a>4.QT中setCheckable()的作用</h3><p>setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。</p><h3 id="5-TCP通讯"><a href="#5-TCP通讯" class="headerlink" title="5.TCP通讯"></a>5.TCP通讯</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">//***.pro格式文件加入network</span><br>QT       += network<br><br><span class="hljs-comment">//mainwindow.h头文件中引用</span><br>#include &lt;QTcpServer&gt;<br>#include &lt;QTcpSocket&gt;<br><span class="hljs-comment">//定义*socket和*server用来存放服务器的套接字和监听，用于与客户端进行通信</span><br>QTcpSocket *socket;<br>   QTcpServer *server;<br><br><span class="hljs-comment">//mainwindow.cpp文件中MainWindow::MainWindow(QWidget *parent)初始化函数内设定，打开即设定查找</span><br><span class="hljs-comment">//setCheckable()设置为True时才有可能使得status为True（即设置后按钮想点灯开关一样，能够按一下保持一直开，再按下保持一直关），否则开关点击一下后仍为关闭状态，status一直为False。</span><br>ui-&gt;Monitor_OPEN-&gt;setCheckable(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//简而言之就是按键的常开和常闭切换</span><br><span class="hljs-comment">//创建服务器的套接字，用于与客户端进行通信</span><br>socket = <span class="hljs-keyword">new</span> QTcpSocket();<br><span class="hljs-comment">//声明一个QTcpserver的对象，用于监听</span><br>   server = <span class="hljs-keyword">new</span> QTcpServer();<br>   <span class="hljs-comment">//信号：新的客户端连接建立 槽函数：获取客户端套接字，允许写入数据</span><br>   connect(server,SIGNAL(newConnection()),this,SLOT(newConnection_SLOT()));<br>   <br>   <span class="hljs-comment">//定义新函数MainWindow::newConnection_SLOT()，用于新的客户端连接建立槽函数：获取客户端套接字，允许写入数据</span><br>   void MainWindow::newConnection_SLOT()<br>   &#123;<br>       socket = server-&gt;nextPendingConnection(); <span class="hljs-comment">//获取已经连接的客户端套接字</span><br>       connect(socket,SIGNAL(readyRead()),this,SLOT(readyRead_SLOT()));<span class="hljs-comment">//如果socket中有缓存消息，触发槽函数</span><br>   &#125;<br>   <br>   <span class="hljs-comment">//定义新函数MainWindow::readyRead_SLOT()，用于接收消息并显示到接收框</span><br>   void MainWindow::readyRead_SLOT()<br>   &#123;<br>       qDebug() &lt;&lt; <span class="hljs-string">&quot;Server Received!&quot;</span>;<br>       QString buffer;<span class="hljs-comment">//定义容器</span><br>       <span class="hljs-comment">//读取缓冲区数据</span><br>       buffer = socket-&gt;readAll();<br>       <span class="hljs-keyword">if</span>(!buffer.isEmpty())<br>       &#123;<br>           <span class="hljs-comment">//刷新显示，写入Receive_text组件，组件类型为Plain Text Line</span><br>           ui-&gt;Receive_text-&gt;appendPlainText(buffer);<br>       &#125;<br>   &#125;<br>   <br>   <span class="hljs-comment">//连接组件函数，按下开始监听组件Monitor_OPEN，类型为clicked(bool checked)，执行监听程序</span><br>   void MainWindow::on_Monitor_OPEN_clicked(<span class="hljs-keyword">bool</span> checked)<br>   &#123;<br>       <span class="hljs-keyword">if</span>(checked)<span class="hljs-comment">//如果按下了</span><br>       &#123;<br>           <span class="hljs-keyword">int</span> port = ui-&gt;PORT_TEXT-&gt;text().toUInt();<br>           <span class="hljs-comment">//如果未监听到</span><br>           <span class="hljs-keyword">if</span>(!server-&gt;listen(QHostAddress::Any, port))<br>           &#123;<br>               qDebug() &lt;&lt; server-&gt;errorString();<br>               <span class="hljs-comment">//连接失败，再次点击则重新连接，将checked恢复为true</span><br>               ui-&gt;Monitor_OPEN-&gt;toggle();<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>           qDebug() &lt;&lt; <span class="hljs-string">&quot;Listen Successfully! Message from port:&quot;</span> &lt;&lt; port;<br>           <span class="hljs-comment">//修改按钮文字</span><br>           ui-&gt;Monitor_OPEN-&gt;setText(<span class="hljs-string">&quot;停止监听&quot;</span>);<br>           <span class="hljs-comment">//发送键使能</span><br>           ui-&gt;Send_Button-&gt;setEnabled(<span class="hljs-keyword">true</span>);<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>            qDebug() &lt;&lt; <span class="hljs-string">&quot;Stop Listening!&quot;</span>;<br>           <span class="hljs-comment">//如果已经连接则断开连接</span><br>           <span class="hljs-keyword">if</span>(socket-&gt;state() == QAbstractSocket::ConnectedState)<br>           &#123;<br>               <span class="hljs-comment">//断开连接</span><br>               socket-&gt;disconnectFromHost();<br>           &#125;<br>           <span class="hljs-comment">//关闭倾听服务</span><br>           server-&gt;close();<br>           <span class="hljs-comment">//修改按钮文字&amp;发送键静默</span><br>           ui-&gt;Monitor_OPEN-&gt;setText(<span class="hljs-string">&quot;开始监听&quot;</span>);<br>           ui-&gt;Send_Button-&gt;setEnabled(<span class="hljs-keyword">false</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="6-滑动槽设定"><a href="#6-滑动槽设定" class="headerlink" title="6.滑动槽设定"></a>6.滑动槽设定</h3><ul><li>首先使用setRange()方法设置了滑动条的范围为0到100，然后使用setValue()方法设置了滑动条的当前值为50。通过value()方法可以获取当前滑动条的值。最后，使用connect()方法监听了滑动条的值变化，当值发生变化时，会调用onSliderValueChanged()槽函数。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">// 假设有一个QSlider对象名为slider<br>// 设置滑动条的范围<br>slider-&gt;setRange(-180, 180);<br><br>// 设置滑动条的当前值<br>slider-&gt;setValue(0);<br><br>// 获取滑动条的当前值<br>int currentValue = slider-&gt;value();<br><br>// 监听滑动条的值变化<br>connect(slider, SIGNAL(valueChanged(int)), this, SLOT(onSliderValueChanged(int)));<br></code></pre></td></tr></table></figure><ul><li>slider 提供了两个自然的步长；较大的步长用 pageStep 表示，相当于按下键盘上的 PageDown 和 PageUp，也相当于鼠标点击时移动的步进值:；较小的步长用 singleStep 表示，相当于按下键盘上的上、下键；</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 设置移动每页的步长，滑块提供的两个自然步长中较大的那一个，相当于键盘上的 PageUp 和 PageDown；</span><br><span class="hljs-function"><span class="hljs-title">horizontalSlider</span>-&gt;</span>setPageStep(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 获取 每页的步长</span><br><span class="hljs-function"><span class="hljs-title">int</span> step = horizontalSlider-&gt;</span>pageStep();<br><br><span class="hljs-comment">// 设置移动单步的步长，滑块提供的两个自然步长中较小的那一个，相当于键盘上的上、下箭头；</span><br><span class="hljs-function"><span class="hljs-title">horizontalSlider</span>-&gt;</span>setSingleStep(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 获取 单步的步长</span><br><span class="hljs-function"><span class="hljs-title">int</span> step =horizontalSlider-&gt;</span>singleStep();<br></code></pre></td></tr></table></figure><ul><li>设置是否启用滑块追踪：</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 设置是否启动滑块追踪：true 表示启动追踪；false 表示禁用追踪；</span><br><span class="hljs-comment">// 如果启用了滑块追踪，则滑块在拖动过程中会一直触发 valueChanged 信号；</span><br><span class="hljs-comment">// 如果禁用了滑块追踪，则滑块在拖动过程中不会触发 valueChanged 信号，</span><br><span class="hljs-comment">// 只有在用户释放滑块时，才触发 valueChanged 信号。</span><br><span class="hljs-function"><span class="hljs-title">horizontalSlider</span>-&gt;</span>setTracking(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 可以通过 hasTracking 属性获取是否启用了追踪：</span><br><span class="hljs-function"><span class="hljs-title">bool</span> isTrack = horizontalSlider-&gt;</span>hasTracking();<br></code></pre></td></tr></table></figure><ul><li>槽函数设定</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">valueChanged</span>()<span class="hljs-comment">//值被改变</span><br><span class="hljs-built_in">sliderPressed</span>()<span class="hljs-comment">//滑块被点击</span><br><span class="hljs-built_in">sliderMoved</span>()<span class="hljs-comment">//滑块移动</span><br><span class="hljs-built_in">sliderReleased</span>();<span class="hljs-comment">//滑块被释放</span><br></code></pre></td></tr></table></figure><h2 id="三、TCP通讯"><a href="#三、TCP通讯" class="headerlink" title="三、TCP通讯"></a>三、TCP通讯</h2><p>【TCP通信】<a href="https://blog.csdn.net/qq_36347513/article/details/123099617">HI3861学习笔记（20）——TCP客户端_hi3861 at tcp 指令 erre-CSDN博客</a></p><p>【TCP通信】<a href="https://blog.csdn.net/baidu_29900103/article/details/117970891">教你动手写TCP上位机与小熊派通信_小熊派设备的tcp通信-CSDN博客</a></p><h2 id="四、下位机代码"><a href="#四、下位机代码" class="headerlink" title="四、下位机代码"></a>四、下位机代码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iot_gpio_ex.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ohos_init.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cmsis_os2.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iot_gpio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iot_uart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hi_uart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iot_watchdog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iot_errno.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hal_bsp_pcf8574.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hal_bsp_wifi.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wifi_device.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lwip/netifapi.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lwip/sockets.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lwip/api_shell.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>    ABS(x)    ((x) &gt; 0 ? (x) : -(x))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_BUFF_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> U_SLEEP_TIME   500000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_TIMEOUT_MS 20   <span class="hljs-comment">// 设置超时时间为100毫秒</span></span><br><br>osThreadId_t Task1_ID; <span class="hljs-comment">// 任务1设置为低优先级任务</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_STACK_SIZE (1024 * 10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TCP_SERVER_IP <span class="hljs-string">&quot;192.168.245.23&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TCP_SERVER_PORT 8888</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIR_pos 1 <span class="hljs-comment">// 正方向</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIR_neg 0 <span class="hljs-comment">// 反方向</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Speed_acc 1000 <span class="hljs-comment">// 加速度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Speed_dec 1000 <span class="hljs-comment">// 减速度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Speed_max 2000.0f <span class="hljs-comment">// 最大速度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> motor_raf_0 0 <span class="hljs-comment">// 相位位置标志</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> motor_raf_1 1 <span class="hljs-comment">//绝对位置标志</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> motor_snf_0 0 <span class="hljs-comment">// 多机同步运动标志</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> motor_snf_1 0 <span class="hljs-comment">// 单机运动标志</span></span><br><br><span class="hljs-comment">//读取数据的枚举值</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>  S_VER   = <span class="hljs-number">0</span>,      <span class="hljs-comment">/* 读取固件版本和对应的硬件版本 */</span><br>  S_RL    = <span class="hljs-number">1</span>,      <span class="hljs-comment">/* 读取读取相电阻和相电感 */</span><br>  S_PID   = <span class="hljs-number">2</span>,      <span class="hljs-comment">/* 读取PID参数 */</span><br>  S_ORG   = <span class="hljs-number">3</span>,      <span class="hljs-comment">/* 读取回零参数 */</span><br>  S_VBUS  = <span class="hljs-number">4</span>,      <span class="hljs-comment">/* 读取总线电压 */</span><br>  S_CBUS  = <span class="hljs-number">5</span>,      <span class="hljs-comment">/* 读取总线电流 */</span><br>  S_CPHA  = <span class="hljs-number">6</span>,      <span class="hljs-comment">/* 读取相电流 */</span><br>  S_ENC   = <span class="hljs-number">7</span>,      <span class="hljs-comment">/* 读取编码器原始值 */</span><br>  S_CPUL  = <span class="hljs-number">8</span>,      <span class="hljs-comment">/* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */</span><br>  S_ENCL  = <span class="hljs-number">9</span>,      <span class="hljs-comment">/* 读取经过线性化校准后的编码器值 */</span><br>  S_TPUL  = <span class="hljs-number">10</span>,     <span class="hljs-comment">/* 读取输入脉冲数 */</span><br>  S_TPOS  = <span class="hljs-number">11</span>,     <span class="hljs-comment">/* 读取电机目标位置 */</span><br>  S_OPOS  = <span class="hljs-number">12</span>,     <span class="hljs-comment">/* 读取电机实时设定的目标位置（开环模式的实时位置） */</span><br>  S_VEL   = <span class="hljs-number">13</span>,     <span class="hljs-comment">/* 读取电机实时转速 */</span><br>  S_CPOS  = <span class="hljs-number">14</span>,     <span class="hljs-comment">/* 读取电机实时位置（基于角度编码器累加的电机实时位置） */</span><br>  S_PERR  = <span class="hljs-number">15</span>,     <span class="hljs-comment">/* 读取电机位置误差 */</span><br>  S_TEMP  = <span class="hljs-number">16</span>,     <span class="hljs-comment">/* 读取电机实时温度 */</span><br>  S_SFLAG = <span class="hljs-number">17</span>,     <span class="hljs-comment">/* 读取状态标志位 */</span><br>  S_OFLAG = <span class="hljs-number">18</span>,     <span class="hljs-comment">/* 读取回零状态标志位 */</span><br>  S_Conf  = <span class="hljs-number">19</span>,     <span class="hljs-comment">/* 读取驱动参数 */</span><br>  S_State = <span class="hljs-number">20</span>,     <span class="hljs-comment">/* 读取系统状态参数 */</span><br>&#125;SysParams_t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Uart1GpioInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//对UART和LED引脚进行初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">IoTGpioInit</span>(IOT_IO_NAME_GPIO_6);<br>    <span class="hljs-comment">// 设置GPIO0的管脚复用关系为UART1_TX Set the pin reuse relationship of GPIO0 to UART1_ TX</span><br>    <span class="hljs-built_in">IoSetFunc</span>(IOT_IO_NAME_GPIO_6, IOT_IO_FUNC_GPIO_6_UART1_TXD);<br>    <br>    <span class="hljs-built_in">IoTGpioInit</span>(IOT_IO_NAME_GPIO_5);<br>    <span class="hljs-comment">// 设置GPIO1的管脚复用关系为UART1_RX Set the pin reuse relationship of GPIO1 to UART1_ RX</span><br>    <span class="hljs-built_in">IoSetFunc</span>(IOT_IO_NAME_GPIO_5, IOT_IO_FUNC_GPIO_5_UART1_RXD);<br><br>    <span class="hljs-comment">// LED3的GPIO初始化 GPIO initialization of LED3</span><br>    <span class="hljs-built_in">IoTGpioInit</span>(IOT_IO_NAME_GPIO_2);<br>    <span class="hljs-comment">// 设置GPIO9的管脚复用关系为GPIO Set the pin reuse relationship of GPIO9 to GPIO</span><br>    <span class="hljs-built_in">IoSetFunc</span>(IOT_IO_NAME_GPIO_2, IOT_IO_FUNC_GPIO_2_GPIO);<br>    <span class="hljs-comment">// GPIO方向设置为输出 GPIO direction set to output</span><br>    <span class="hljs-built_in">IoTGpioSetDir</span>(IOT_IO_NAME_GPIO_2, IOT_GPIO_DIR_OUT);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Uart1Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//对UART配置初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> ret;<br>    <span class="hljs-comment">/* 初始化UART配置，波特率 115200，数据bit为8,停止位1，奇偶校验为NONE */</span><br>    <span class="hljs-comment">/* Initialize UART configuration, baud rate is 9600, data bit is 8, stop bit is 1, parity is NONE */</span><br>    IotUartAttribute uart_attr = &#123;<br>        .baudRate = <span class="hljs-number">115200</span>,<br>        .dataBits = <span class="hljs-number">8</span>,<br>        .stopBits = <span class="hljs-number">1</span>,<br>        .parity = <span class="hljs-number">0</span>,<br>    &#125;;<br><br>    <span class="hljs-comment">//uart初始化返回值</span><br>    ret = <span class="hljs-built_in">IoTUartInit</span>(HI_UART_IDX_1, &amp;uart_attr);<br>    <span class="hljs-comment">//判断uart是否连接成功</span><br>    <span class="hljs-keyword">if</span> (ret != IOT_SUCCESS) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Init Uart1 Falied Error No : %d\n&quot;</span>, ret);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZDT_X42_V2_En_Control</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">int</span> state, <span class="hljs-type">uint8_t</span> snF)</span><span class="hljs-comment">//电机使能控制函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义接收值以及数据长度</span><br>    <span class="hljs-type">uint32_t</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">//定义发送命令数组</span><br>    <span class="hljs-type">uint8_t</span> cmd[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <br>    <span class="hljs-comment">// 装载命令</span><br>    cmd[<span class="hljs-number">0</span>] =  addr;                       <span class="hljs-comment">// 地址</span><br>    cmd[<span class="hljs-number">1</span>] =  <span class="hljs-number">0xF3</span>;                       <span class="hljs-comment">// 功能码</span><br>    cmd[<span class="hljs-number">2</span>] =  <span class="hljs-number">0xAB</span>;                       <span class="hljs-comment">// 辅助码</span><br>    cmd[<span class="hljs-number">3</span>] =  (<span class="hljs-type">uint8_t</span>)state;             <span class="hljs-comment">// 使能状态</span><br>    cmd[<span class="hljs-number">4</span>] =  snF;                        <span class="hljs-comment">// 多机同步运动标志</span><br>    cmd[<span class="hljs-number">5</span>] =  <span class="hljs-number">0x6B</span>;                       <span class="hljs-comment">// 校验字节</span><br><br>    <span class="hljs-comment">//通过UART的Write函数发送cmd的参数</span><br>    <span class="hljs-built_in">IoTUartWrite</span>(HI_UART_IDX_1, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)cmd, <span class="hljs-number">6</span>);<br>&#125;<br><br><span class="hljs-comment">//电机驱动函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZDT_X42_V2_Traj_Position_Control</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> dir, <span class="hljs-type">uint16_t</span> acc, <span class="hljs-type">uint16_t</span> dec, <span class="hljs-type">float</span> velocity, <span class="hljs-type">float</span> position, <span class="hljs-type">uint8_t</span> raf, <span class="hljs-type">uint8_t</span> snF)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义接收值以及数据长度</span><br>    <span class="hljs-type">uint32_t</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-comment">//定义发送命令数组</span><br>    <span class="hljs-type">uint8_t</span> cmd[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">uint16_t</span> vel = <span class="hljs-number">0</span>; <span class="hljs-type">uint32_t</span> pos = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将速度和位置放大10倍发送过去</span><br>    vel = (<span class="hljs-type">uint16_t</span>)<span class="hljs-built_in">ABS</span>(velocity * <span class="hljs-number">10.0f</span>); <br>    pos = (<span class="hljs-type">uint32_t</span>)<span class="hljs-built_in">ABS</span>(position * <span class="hljs-number">10.0f</span>);<br><br>    <span class="hljs-comment">// 装载命令</span><br>    cmd[<span class="hljs-number">0</span>]  =  addr;                      <span class="hljs-comment">// 地址</span><br>    cmd[<span class="hljs-number">1</span>]  =  <span class="hljs-number">0xFD</span>;                      <span class="hljs-comment">// 功能码</span><br>    cmd[<span class="hljs-number">2</span>]  =  dir;                       <span class="hljs-comment">// 符号（方向）</span><br>    cmd[<span class="hljs-number">3</span>]  =  (<span class="hljs-type">uint8_t</span>)(acc &gt;&gt; <span class="hljs-number">8</span>);       <span class="hljs-comment">// 加速加速度(RPM/s)高8位字节</span><br>    cmd[<span class="hljs-number">4</span>]  =  (<span class="hljs-type">uint8_t</span>)(acc &gt;&gt; <span class="hljs-number">0</span>);       <span class="hljs-comment">// 加速加速度(RPM/s)低8位字节  </span><br>    cmd[<span class="hljs-number">5</span>]  =  (<span class="hljs-type">uint8_t</span>)(dec &gt;&gt; <span class="hljs-number">8</span>);       <span class="hljs-comment">// 减速加速度(RPM/s)高8位字节</span><br>    cmd[<span class="hljs-number">6</span>]  =  (<span class="hljs-type">uint8_t</span>)(dec &gt;&gt; <span class="hljs-number">0</span>);       <span class="hljs-comment">// 减速加速度(RPM/s)低8位字节  </span><br>    cmd[<span class="hljs-number">7</span>]  =  (<span class="hljs-type">uint8_t</span>)(vel &gt;&gt; <span class="hljs-number">8</span>);       <span class="hljs-comment">// 最大速度(RPM)高8位字节</span><br>    cmd[<span class="hljs-number">8</span>]  =  (<span class="hljs-type">uint8_t</span>)(vel &gt;&gt; <span class="hljs-number">0</span>);       <span class="hljs-comment">// 最大速度(RPM)低8位字节 </span><br>    cmd[<span class="hljs-number">9</span>]  =  (<span class="hljs-type">uint8_t</span>)(pos &gt;&gt; <span class="hljs-number">24</span>);      <span class="hljs-comment">// 位置(bit24 - bit31)</span><br>    cmd[<span class="hljs-number">10</span>] =  (<span class="hljs-type">uint8_t</span>)(pos &gt;&gt; <span class="hljs-number">16</span>);      <span class="hljs-comment">// 位置(bit16 - bit23)</span><br>    cmd[<span class="hljs-number">11</span>] =  (<span class="hljs-type">uint8_t</span>)(pos &gt;&gt; <span class="hljs-number">8</span>);       <span class="hljs-comment">// 位置(bit8  - bit15)</span><br>    cmd[<span class="hljs-number">12</span>] =  (<span class="hljs-type">uint8_t</span>)(pos &gt;&gt; <span class="hljs-number">0</span>);       <span class="hljs-comment">// 位置(bit0  - bit7 )</span><br>    cmd[<span class="hljs-number">13</span>] =  raf;                       <span class="hljs-comment">// 相位位置/绝对位置标志</span><br>    cmd[<span class="hljs-number">14</span>] =  snF;                       <span class="hljs-comment">// 多机同步运动标志</span><br>    cmd[<span class="hljs-number">15</span>] =  <span class="hljs-number">0x6B</span>;                      <span class="hljs-comment">// 校验字节</span><br><br>    <span class="hljs-comment">//通过UART的Write函数发送cmd的参数</span><br>    <span class="hljs-built_in">IoTUartWrite</span>(HI_UART_IDX_1, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)cmd, <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZDT_X42_V2_Origin_Trigger_Return</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> o_mode, <span class="hljs-type">bool</span> snF)</span><span class="hljs-comment">//电机归零函数，没啥用，需要外界碰撞或者限位，该文件未使用此函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义接收值以及数据长度</span><br>    <span class="hljs-type">uint32_t</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-type">uint8_t</span> cmd[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-comment">// 装载命令</span><br>    cmd[<span class="hljs-number">0</span>] =  addr;                       <span class="hljs-comment">// 地址</span><br>    cmd[<span class="hljs-number">1</span>] =  <span class="hljs-number">0x9A</span>;                       <span class="hljs-comment">// 功能码</span><br>    cmd[<span class="hljs-number">2</span>] =  o_mode;                     <span class="hljs-comment">// 回零模式，0为单圈就近回零，1为单圈方向回零，2为多圈无限位碰撞回零，3为多圈有限位开关回零</span><br>    cmd[<span class="hljs-number">3</span>] =  snF;                        <span class="hljs-comment">// 多机同步运动标志，false为不启用，true为启用</span><br>    cmd[<span class="hljs-number">4</span>] =  <span class="hljs-number">0x6B</span>;                       <span class="hljs-comment">// 校验字节</span><br><br>    <span class="hljs-comment">//通过UART的Write函数发送cmd的参数</span><br>    <span class="hljs-built_in">IoTUartWrite</span>(HI_UART_IDX_1, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)cmd, <span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZDT_X42_V2_Stop_Now</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> snF)</span><span class="hljs-comment">//立即停机</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义接收值以及数据长度</span><br>    <span class="hljs-type">uint32_t</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uartReadBuff[UART_BUFF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-type">uint8_t</span> cmd[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-comment">// 装载命令</span><br>    cmd[<span class="hljs-number">0</span>] =  addr;                       <span class="hljs-comment">// 地址</span><br>    cmd[<span class="hljs-number">1</span>] =  <span class="hljs-number">0xFE</span>;                       <span class="hljs-comment">// 功能码</span><br>    cmd[<span class="hljs-number">2</span>] =  <span class="hljs-number">0x98</span>;                       <span class="hljs-comment">// 辅助码</span><br>    cmd[<span class="hljs-number">3</span>] =  snF;                        <span class="hljs-comment">// 多机同步运动标志</span><br>    cmd[<span class="hljs-number">4</span>] =  <span class="hljs-number">0x6B</span>;                       <span class="hljs-comment">// 校验字节</span><br><br>    <span class="hljs-comment">//通过UART的Write函数发送cmd的参数</span><br>    <span class="hljs-built_in">IoTUartWrite</span>(HI_UART_IDX_1, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)cmd, <span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">IoTUartFlush</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span> <span class="hljs-comment">//串口清空函数，用于进行清空UART内部缓存，不然会出现读取错误</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义要存储数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-comment">//定义读取值</span><br>    <span class="hljs-type">int</span> read;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//将读取值全部存入数组当中，从而达到清空效果</span><br>        read = <span class="hljs-built_in">IoTUartRead</span>(id, buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br>    &#125; <span class="hljs-keyword">while</span> (read &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> IOT_SUCCESS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZDT_X42_V2_Read_Sys_Params</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, SysParams_t s)</span><span class="hljs-comment">//读取电机的实时位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义发送数组</span><br>    <span class="hljs-type">uint8_t</span> cmd[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <br>    <span class="hljs-comment">// 装载命令</span><br>    cmd[<span class="hljs-number">0</span>] =  addr;                       <span class="hljs-comment">// 地址</span><br><br>    <span class="hljs-comment">//对功能码进行选择</span><br>    <span class="hljs-keyword">switch</span>(s)                             <span class="hljs-comment">// 功能码</span><br>    &#123;<br>        <span class="hljs-keyword">case</span> S_VER   : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x1F</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取固件版本和对应的硬件版本 */</span><br>        <span class="hljs-keyword">case</span> S_RL    : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x20</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取读取相电阻和相电感 */</span><br>        <span class="hljs-keyword">case</span> S_PID   : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取PID参数 */</span><br>        <span class="hljs-keyword">case</span> S_ORG   : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x22</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取回零参数 */</span><br>        <span class="hljs-keyword">case</span> S_VBUS  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x24</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取总线电压 */</span><br>        <span class="hljs-keyword">case</span> S_CBUS  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x26</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取总线电流 */</span><br>        <span class="hljs-keyword">case</span> S_CPHA  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x27</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取相电流 */</span><br>        <span class="hljs-keyword">case</span> S_ENC   : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x29</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取编码器原始值 */</span><br>        <span class="hljs-keyword">case</span> S_CPUL  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x30</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取实时脉冲数（根据实时位置计算得到的脉冲数） */</span><br>        <span class="hljs-keyword">case</span> S_ENCL  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x31</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取经过线性化校准后的编码器值 */</span><br>        <span class="hljs-keyword">case</span> S_TPUL  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x32</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取输入脉冲数 */</span><br>        <span class="hljs-keyword">case</span> S_TPOS  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x33</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取电机目标位置 */</span><br>        <span class="hljs-keyword">case</span> S_OPOS  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x34</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取电机实时设定的目标位置（开环模式的实时位置） */</span><br>        <span class="hljs-keyword">case</span> S_VEL   : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x35</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取电机实时转速 */</span><br>        <span class="hljs-keyword">case</span> S_CPOS  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x36</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取电机实时位置（基于角度编码器累加的电机实时位置） */</span><br>        <span class="hljs-keyword">case</span> S_PERR  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x37</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取电机位置误差 */</span><br>        <span class="hljs-keyword">case</span> S_TEMP  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x39</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取电机实时温度 */</span><br>        <span class="hljs-keyword">case</span> S_SFLAG : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x3A</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取状态标志位 */</span><br>        <span class="hljs-keyword">case</span> S_OFLAG : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x3B</span>; <span class="hljs-keyword">break</span>;                  <span class="hljs-comment">/* 读取回零状态标志位 */</span><br>        <span class="hljs-keyword">case</span> S_Conf  : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x42</span>; cmd[<span class="hljs-number">2</span>] = <span class="hljs-number">0x6C</span>; <span class="hljs-keyword">break</span>;   <span class="hljs-comment">/* 读取驱动参数 */</span><br>        <span class="hljs-keyword">case</span> S_State : cmd[<span class="hljs-number">1</span>] = <span class="hljs-number">0x43</span>; cmd[<span class="hljs-number">2</span>] = <span class="hljs-number">0x7A</span>; <span class="hljs-keyword">break</span>;   <span class="hljs-comment">/* 读取系统状态参数 */</span><br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果需要四字节，将校验字节放在 cmd[3]</span><br>    cmd[<span class="hljs-number">2</span>] = <span class="hljs-number">0x6B</span>; <br><br>    <span class="hljs-comment">//通过UART的Write函数发送cmd的参数</span><br>    <span class="hljs-built_in">IoTUartWrite</span>(HI_UART_IDX_1, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)cmd, <span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZDT_X42_V2_Receive_Data</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> *rxCmd, <span class="hljs-type">uint32_t</span> *rxCount)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> startTime = <span class="hljs-built_in">osKernelGetTickCount</span>();  <span class="hljs-comment">// 获取当前系统时间</span><br>    <span class="hljs-type">uint8_t</span> buffer[UART_BUFF_SIZE];<br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        len = <span class="hljs-built_in">IoTUartRead</span>(HI_UART_IDX_1, buffer, <span class="hljs-built_in">sizeof</span>(buffer));  <span class="hljs-comment">// 从UART读取数据</span><br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将读取的数据复制到rxCmd数组中，确保不会溢出</span><br>            <span class="hljs-type">uint32_t</span> copySize = (*rxCount + len &gt; UART_BUFF_SIZE) ? (UART_BUFF_SIZE - *rxCount) : len;<br>            <span class="hljs-built_in">memcpy</span>(rxCmd + *rxCount, buffer, copySize);<br>            *rxCount += copySize;<br><br>            startTime = <span class="hljs-built_in">osKernelGetTickCount</span>();  <span class="hljs-comment">// 更新最后一次接收数据的时间</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否超时</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">osKernelGetTickCount</span>() - startTime) &gt; UART_TIMEOUT_MS) &#123;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果超过设定的超时时间，则停止接收数据</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">absolute</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span> <span class="hljs-comment">//找不到绝对值的函数值定义，自己创建一个函数用于进行绝对值计算</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (value &lt; <span class="hljs-number">0</span>) ? -value : value;<span class="hljs-comment">//判断如何取正</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">ReadMotorAngle</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> sliderId)</span> <span class="hljs-comment">//定义读取角度，并计算和输出角度值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//清空缓存区</span><br>    <span class="hljs-built_in">IoTUartFlush</span>(HI_UART_IDX_1);<br><br>    <span class="hljs-comment">//定义角度取值为小数点后一位</span><br>    <span class="hljs-type">float</span> pos = <span class="hljs-number">0.0f</span>, Motor_Cur_Pos = <span class="hljs-number">0.0f</span>;<br><br>    <span class="hljs-comment">// 定义接收数据数组、接收数据长度</span><br>    <span class="hljs-type">uint8_t</span> rxCmd[UART_BUFF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">uint32_t</span> rxCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 读取电机实时位置</span><br>    <span class="hljs-built_in">ZDT_X42_V2_Read_Sys_Params</span>(sliderId, S_CPOS);<br><br>    <span class="hljs-comment">// 等待返回命令，命令数据缓存在数组rxCmd上，长度为rxCount</span><br>    <span class="hljs-built_in">ZDT_X42_V2_Receive_Data</span>(sliderId, rxCmd, &amp;rxCount);<br><br>    <span class="hljs-comment">//将读取的rxCmd[]十六进制编码打印，用于测试调试</span><br>    <span class="hljs-comment">// printf(&quot;Received bytes: &quot;);</span><br>    <span class="hljs-comment">// for (int i = 0; i &lt; 8; i++) &#123;</span><br>    <span class="hljs-comment">//     printf(&quot;%02X &quot;, rxCmd[i]);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// printf(&quot;\n&quot;);</span><br><br>    <span class="hljs-comment">// 获取电机实时角度返回值（电机实时角度返回值放大了10倍返回的，因为要保留1位小数）</span><br>    pos = ((<span class="hljs-type">uint32_t</span>)rxCmd[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) | ((<span class="hljs-type">uint32_t</span>)rxCmd[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-type">uint32_t</span>)rxCmd[<span class="hljs-number">5</span>] &lt;&lt; <span class="hljs-number">8</span>) | (<span class="hljs-type">uint32_t</span>)rxCmd[<span class="hljs-number">6</span>];<br><br>    <span class="hljs-comment">// 缩小10倍，并判断符号，得到真正的实时角度，存放在浮点数变量Motor_Cur_Pos中</span><br>    Motor_Cur_Pos = pos * <span class="hljs-number">0.1f</span>;<br>    <span class="hljs-keyword">if</span> (rxCmd[<span class="hljs-number">2</span>]) &#123;<br>        Motor_Cur_Pos = -Motor_Cur_Pos;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印解析后的角度值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current position (as angle): %.1f degrees\n&quot;</span>, Motor_Cur_Pos);<br><br>    <span class="hljs-keyword">return</span> Motor_Cur_Pos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetMotorToOrigin</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> sliderId)</span> <span class="hljs-comment">//电机归零函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//读取电机目前角度</span><br>    <span class="hljs-type">float</span> Motor_Cur_Pos = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);<br><br>    <span class="hljs-type">float</span> targetPosition = <span class="hljs-number">0</span>; <span class="hljs-comment">// 目标位置，这里假设为0度</span><br><br>    <span class="hljs-comment">// 根据当前角度和目标位置计算需要移动的距离</span><br>    <span class="hljs-type">float</span> delta = targetPosition - Motor_Cur_Pos;<br><br>    <span class="hljs-comment">// 将 delta 四舍五入到小数点后一位</span><br>    <span class="hljs-comment">//delta = ((int)(delta * 10 + 0.5)) / 10.0f;</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;delta: %.1f degrees\n&quot;</span>, delta);<br><br>    <span class="hljs-comment">// 调用轨迹位置控制函数将电机移动到目标位置</span><br>    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, (delta &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta), motor_raf_0, motor_snf_0);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParseJson</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* json)</span><span class="hljs-comment">//电机uart运行主函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 定义JSON键的字符串，根据上位机所需进行定义，格式类型相同</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* labelStr = <span class="hljs-string">&quot;\&quot;label\&quot;:&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* motor_EnStr = <span class="hljs-string">&quot;\&quot;motor_En\&quot;:&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sliderIdStr = <span class="hljs-string">&quot;\&quot;sliderId\&quot;:&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* valueStr = <span class="hljs-string">&quot;\&quot;value\&quot;:&quot;</span>;<br>    <br><br>    <span class="hljs-comment">// 找到JSON字符串中键的位置，用于进行键的连接，等于找到对应的标签</span><br>    <span class="hljs-type">char</span>* labelPos = <span class="hljs-built_in">strstr</span>(json, labelStr);<br>    <span class="hljs-type">char</span>* motor_EnPos = <span class="hljs-built_in">strstr</span>(json, motor_EnStr);<br>    <span class="hljs-type">char</span>* sliderIdPos = <span class="hljs-built_in">strstr</span>(json, sliderIdStr);<br>    <span class="hljs-type">char</span>* valuePos = <span class="hljs-built_in">strstr</span>(json, valueStr);<br><br>    <span class="hljs-comment">// 如果找到键，解析其对应的值</span><br>    <span class="hljs-keyword">if</span> (labelPos != <span class="hljs-literal">NULL</span> &amp;&amp; motor_EnPos != <span class="hljs-literal">NULL</span> &amp;&amp; sliderIdPos != <span class="hljs-literal">NULL</span> &amp;&amp; valuePos != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">int</span> label = <span class="hljs-built_in">atoi</span>(labelPos + <span class="hljs-built_in">strlen</span>(labelStr)); <span class="hljs-comment">// 将label转换为整数</span><br>        <span class="hljs-type">int</span> sliderId = <span class="hljs-built_in">atoi</span>(sliderIdPos + <span class="hljs-built_in">strlen</span>(sliderIdStr)); <span class="hljs-comment">// 将sliderId转换为整数</span><br><br>        <span class="hljs-comment">//放大30倍，对应谐波减速器</span><br>        <span class="hljs-type">int</span> value = <span class="hljs-built_in">atof</span>(valuePos + <span class="hljs-built_in">strlen</span>(valueStr));<br>        <span class="hljs-type">int</span> motor_En = <span class="hljs-built_in">atoi</span>(motor_EnPos + <span class="hljs-built_in">strlen</span>(motor_EnStr));<br><br>        <span class="hljs-comment">// 打印解析出的值</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;label: %d, motor_En: %d, Slider ID: %d, Value: %d\n&quot;</span>, label, motor_En, sliderId, value);<br><br>        <span class="hljs-comment">// 根据Slider ID和Value执行相应的操作</span><br>        <span class="hljs-keyword">if</span> (label == <span class="hljs-number">1</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(motor_En == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 使能</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 失能</span><br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(motor_En == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 使能</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">if</span>(motor_En == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 使能</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-keyword">if</span>(motor_En == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 使能</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">5</span>)&#123;<br>                <span class="hljs-keyword">if</span>(motor_En == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 使能</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 失能</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">6</span>)&#123;<br>                <span class="hljs-keyword">if</span>(motor_En == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 使能</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">ZDT_X42_V2_En_Control</span>(sliderId, motor_En, motor_snf_0);  <span class="hljs-comment">// 失能</span><br>                &#125;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label == <span class="hljs-number">2</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">float</span> value_before = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);  <span class="hljs-comment">//读取电机现在角度值</span><br>                <span class="hljs-type">float</span> delta_value = value - value_before;  <span class="hljs-comment">// 计算想要的变化值</span><br>                <span class="hljs-keyword">if</span> (delta_value &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//利用值的正负，判断电机正反转</span><br>                    <span class="hljs-comment">//正转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//反转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">float</span> value_before = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);  <span class="hljs-comment">//读取电机现在角度值</span><br>                <span class="hljs-type">float</span> delta_value = value - value_before;  <span class="hljs-comment">// 计算想要的变化值</span><br>                <span class="hljs-keyword">if</span> (delta_value &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//利用值的正负，判断电机正反转</span><br>                    <span class="hljs-comment">//正转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//反转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-type">float</span> value_before = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);  <span class="hljs-comment">//读取电机现在角度值</span><br>                <span class="hljs-type">float</span> delta_value = value - value_before;  <span class="hljs-comment">// 计算想要的变化值</span><br>                <span class="hljs-keyword">if</span> (delta_value &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//利用值的正负，判断电机正反转</span><br>                    <span class="hljs-comment">//正转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//反转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-type">float</span> value_before = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);  <span class="hljs-comment">//读取电机现在角度值</span><br>                <span class="hljs-type">float</span> delta_value = value - value_before;  <span class="hljs-comment">// 计算想要的变化值</span><br>                <span class="hljs-keyword">if</span> (delta_value &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//利用值的正负，判断电机正反转</span><br>                    <span class="hljs-comment">//正转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//反转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">5</span>)&#123;<br>                <span class="hljs-type">float</span> value_before = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);  <span class="hljs-comment">//读取电机现在角度值</span><br>                <span class="hljs-type">float</span> delta_value = value - value_before;  <span class="hljs-comment">// 计算想要的变化值</span><br>                <span class="hljs-keyword">if</span> (delta_value &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//利用值的正负，判断电机正反转</span><br>                    <span class="hljs-comment">//正转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//反转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sliderId == <span class="hljs-number">6</span>)&#123;<br>                <span class="hljs-type">float</span> value_before = <span class="hljs-built_in">ReadMotorAngle</span>(sliderId);  <span class="hljs-comment">//读取电机现在角度值</span><br>                <span class="hljs-type">float</span> delta_value = value - value_before;  <span class="hljs-comment">// 计算想要的变化值</span><br>                <span class="hljs-keyword">if</span> (delta_value &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//利用值的正负，判断电机正反转</span><br>                    <span class="hljs-comment">//正转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_pos, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 0);  //LED灯调试代码</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//反转</span><br>                    <span class="hljs-built_in">ZDT_X42_V2_Traj_Position_Control</span>(sliderId, DIR_neg, Speed_acc, Speed_dec, Speed_max, <span class="hljs-built_in">absolute</span>(delta_value), motor_raf_0, motor_snf_0);<br>                    <span class="hljs-comment">//IoTGpioSetOutputVal(IOT_IO_NAME_GPIO_2, 1);  //LED灯调试代码</span><br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label == <span class="hljs-number">3</span>) <span class="hljs-comment">//电机紧急停机</span><br>        &#123;<br>            <span class="hljs-built_in">ZDT_X42_V2_Stop_Now</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//调用停机函数</span><br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);  <span class="hljs-comment">//延时确保函数依次执行</span><br>            <span class="hljs-built_in">ZDT_X42_V2_Stop_Now</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ZDT_X42_V2_Stop_Now</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ZDT_X42_V2_Stop_Now</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ZDT_X42_V2_Stop_Now</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ZDT_X42_V2_Stop_Now</span>(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label == <span class="hljs-number">4</span>) <span class="hljs-comment">//电机复位函数</span><br>        &#123;<br>            <span class="hljs-built_in">ResetMotorToOrigin</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//调用复位函数</span><br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);  <span class="hljs-comment">//延时确保函数依次执行</span><br>            <span class="hljs-built_in">ResetMotorToOrigin</span>(<span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ResetMotorToOrigin</span>(<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ResetMotorToOrigin</span>(<span class="hljs-number">4</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ResetMotorToOrigin</span>(<span class="hljs-number">5</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">ResetMotorToOrigin</span>(<span class="hljs-number">6</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Task1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//系统主函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> socket_fd = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> re = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">uint32_t</span> count_0 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> len_0 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uartReadBuff_0[UART_BUFF_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// 对UART1的一些初始化 Some initialization of UART1</span><br>    <span class="hljs-built_in">Uart1GpioInit</span>();<br>    <span class="hljs-comment">// 对UART1参数的一些配置 Some configurations of UART1 parameters</span><br>    <span class="hljs-built_in">Uart1Config</span>();<br><br>    <span class="hljs-comment">// 连接Wifi</span><br>    <span class="hljs-built_in">WiFi_connectHotspots</span>(<span class="hljs-string">&quot;esp32&quot;</span>, <span class="hljs-string">&quot;12345678&quot;</span>);<br>    socket_fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>); <span class="hljs-comment">// 创建套接字（TCP）</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(TCP_SERVER_PORT);<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(TCP_SERVER_IP); <span class="hljs-comment">// 填写服务器的IP地址</span><br><br>    re = <span class="hljs-built_in">connect</span>(socket_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr)); <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-keyword">if</span> (re == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to connect to the server\r\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection to server successful\r\n&quot;</span>);<br><br>    <span class="hljs-comment">// 发送第一条数据</span><br>    <span class="hljs-built_in">send</span>(socket_fd, <span class="hljs-string">&quot;Connection to server successful.&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;Connection to server successful.&quot;</span>), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">memset_s</span>(buff, <span class="hljs-built_in">sizeof</span>(buff), <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buff));<br>        re = <span class="hljs-built_in">recv</span>(socket_fd, buff, <span class="hljs-built_in">sizeof</span>(buff), <span class="hljs-number">0</span>); <span class="hljs-comment">//接收客户端发送过来的消息</span><br>        <span class="hljs-keyword">if</span> (re &lt;= <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">ParseJson</span>(buff);<span class="hljs-comment">//执行控制主函数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(socket_fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UartExampleEntry</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//配置上报函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//osThreadAttr_t attr;</span><br>    <span class="hljs-built_in">IoTWatchDogDisable</span>();<br><br>    osThreadAttr_t options;<br>    options.name = <span class="hljs-string">&quot;thread_1&quot;</span>;<br>    options.attr_bits = <span class="hljs-number">0</span>;<br>    options.cb_mem = <span class="hljs-literal">NULL</span>;<br>    options.cb_size = <span class="hljs-number">0</span>;<br>    options.stack_mem = <span class="hljs-literal">NULL</span>;<br>    options.stack_size = TASK_STACK_SIZE;<br>    options.priority = osPriorityNormal;<br><br>    Task1_ID = <span class="hljs-built_in">osThreadNew</span>((osThreadFunc_t)Task1, <span class="hljs-literal">NULL</span>, &amp;options);<br>    <span class="hljs-keyword">if</span> (Task1_ID != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ID = %d, Create Task1_ID is OK!\r\n&quot;</span>, Task1_ID);<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">APP_FEATURE_INIT</span>(UartExampleEntry);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hi3861</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FOC无刷电机控制</title>
    <link href="/YYang.github.io/2024/04/15/20240319ZYY-FOC%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/"/>
    <url>/YYang.github.io/2024/04/15/20240319ZYY-FOC%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="FOC无刷电机控制"><a href="#FOC无刷电机控制" class="headerlink" title="FOC无刷电机控制"></a>FOC无刷电机控制</h1><h2 id="一、无刷电机基本理解"><a href="#一、无刷电机基本理解" class="headerlink" title="一、无刷电机基本理解"></a>一、无刷电机基本理解</h2><p>基本的航模无刷电机结构图如下图所示，<strong>分为前盖，中盖，后盖，磁铁，硅钢片，漆包线、轴承和转轴组成</strong>。</p><img src="http://dengfoc.com/dengfoc/shouimage/1-1.png" alt="无刷电机的组成" style="zoom:50%;" /><h3 id="1-可以直接把电机分为定子部分和转子部分："><a href="#1-可以直接把电机分为定子部分和转子部分：" class="headerlink" title="1.可以直接把电机分为定子部分和转子部分："></a>1.可以直接把电机分为定子部分和转子部分：</h3><ul><li><strong>定子</strong>就是有线圈绕组，固定不动的部分；</li><li><strong>转子</strong>就是电机旋转的部分，用于输出电机的转动和扭矩。</li></ul><h3 id="2-内外旋转类型区分："><a href="#2-内外旋转类型区分：" class="headerlink" title="2.内外旋转类型区分："></a>2.内外旋转类型区分：</h3><ul><li><p><strong>内转子无刷电机</strong>就是转子在内部，轴进行旋转；</p></li><li><p><strong>外转子无刷电机</strong>就是转子在外面，外壳进行旋转。</p></li><li><p>而<strong>直流无刷电机的驱动</strong>，就是依靠<strong>改变电机定子线圈的电流交变频率和波形，在定子周围形成磁场，驱动转子永磁体转动</strong>，进而带动电机转起来。</p></li></ul><h3 id="3-无刷电机跟有刷电机的区别"><a href="#3-无刷电机跟有刷电机的区别" class="headerlink" title="3.无刷电机跟有刷电机的区别"></a>3.<strong>无刷电机跟有刷电机的区别</strong></h3><ul><li>顾名思义就是<strong>无刷电机没有了有刷电机里的电刷</strong>。因此它<strong>不能够如同有刷电机那样采用机械结构就可以进行电流的换向</strong>， 而是必须通过采用如MOS这样的器件实现<strong>电子换向</strong>。</li></ul><img src="http://dengfoc.com/dengfoc/shouimage/2-2.png" alt="2-2" style="zoom: 33%;" /><img src="http://dengfoc.com/dengfoc/shouimage/2-4.png" alt="2-4" style="zoom: 33%;" /><img src="http://dengfoc.com/dengfoc/shouimage/2-5.png" alt="2-5" style="zoom: 50%;" /><ul><li><strong>对电机的控制实际上就是对MOS管开关规律的控制</strong>。而MOS管的开关规律是需要用到单片机程序进行控制的，因此这就引出了我们的<strong>FOC控制算法，FOC控制就是一种对电机运动模型进行抽象化和简化，进而有规律控制各个MOS管开关和通断的过程</strong>。</li></ul><h2 id="二、克拉克变换"><a href="#二、克拉克变换" class="headerlink" title="二、克拉克变换"></a>二、克拉克变换</h2><h3 id="1-克拉克变换基本含义"><a href="#1-克拉克变换基本含义" class="headerlink" title="1.克拉克变换基本含义"></a>1.克拉克变换基本含义</h3><ul><li>交替开关的MOS管可以实现电机的转动，而这些交替开关的MOS管是以极其快的速度在周期性进行的，把这些周期性的开启和关断过程联系起来，并且对其各个相进行单独观察，就可以得到三个相A、B、C的电流随时间变换的曲线，如下图所示，他们之间存在120°的相位差。换一个角度来思考此问题，实际上，我们只要能够<strong>控制这个相位差为120°的sin状波形，就能够实现针对电机的控制</strong>。</li></ul><p><img src="http://dengfoc.com/dengfoc/shouimage/3.1-1.png" alt="3.1-1"></p><ul><li><p><strong>克拉克变换，实际上就是降维解耦的过程，把难以辨明和控制的三相相位差120°电机波形降维为两维矢量</strong>。</p></li><li><p><strong>第一就是把三相随时间变换的，相位差为120°的电流波形抽象化为三个间隔120°的矢量</strong>。</p></li><li><p><strong>第二就是利用三角函数对矢量进行降维，降维到两个坐标轴</strong>，从此复杂的三相变化问题就降解为了α-β坐标轴的坐标上的数值变化问题。</p></li></ul><img src="http://dengfoc.com/dengfoc/shouimage/3.1-3.png" alt="3.1-3" style="zoom:50%;" /><img src="http://dengfoc.com/dengfoc/shouimage/3.1-4.png" alt="3.1-4" style="zoom:67%;" /><ul><li>上图中，左边是我们把三相120度相位差的sin状波形抽象化为矢量之后的样子，而右边就是我们需要<strong>把这三个矢量进行投影的坐标轴。只要我们把三个矢量都投影到坐标轴上，那么，一个三矢量问题就变成一个二维坐标平面问题</strong>。</li></ul><h3 id="2-克拉克变换推导公式"><a href="#2-克拉克变换推导公式" class="headerlink" title="2.克拉克变换推导公式"></a>2.克拉克变换推导公式</h3><ul><li><p><strong>克拉克变换的第一步，作投影</strong></p></li><li><p>针对α-β坐标系中α轴，有：</p></li></ul><img src="https://s2.loli.net/2024/07/25/YO6LurHIQkSfV21.png" alt="image-20240318150726168.png" style="zoom:50%;" /><ul><li>针对α-β坐标系中β轴，有：</li></ul><img src="https://s2.loli.net/2024/07/25/ZUyTqOcmRVtHSe7.png" alt="image-20240318150741335.png" style="zoom:50%;" /><ul><li>把上面的投影结果列成矩阵形式，有：</li></ul><img src="https://s2.loli.net/2024/07/25/xR4twW1ynvGp2ou.png" alt="image-20240318150755362.png" style="zoom:50%;" /><h3 id="3-克拉克变换的等辐值形式"><a href="#3-克拉克变换的等辐值形式" class="headerlink" title="3.克拉克变换的等辐值形式"></a>3.克拉克变换的等辐值形式</h3><ul><li>何为等幅值变换？用α相电流输入1A电流的特例来举例，当电流输入时候，根据基尔霍夫电流定律（电路中任一个节点上，在任意时刻，流入节点的电流之和等于流出节点的电流之和，如下图），有：</li></ul><img src="https://s2.loli.net/2024/07/25/fSHMDIEoRj4JsOl.png" alt="image-20240318151006334.png" style="zoom:67%;" /><img src="https://s2.loli.net/2024/07/25/1bvRp6E8T3Q5dPk.png" alt="image-20240318152249217.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/25/esquFgkWVyZpf4c.png" alt="image-20240318152309335.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/25/58PAe2iML9I1uDW.png" alt="image-20240319174421088.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/25/qxy9OB8GJH2frNj.png" alt="image-20240319174945752.png" style="zoom:50%;" /><ul><li>在式子中，我们消去了变量Ic，这是因为由于基尔霍夫电流定律的存在，我们并不需要知道所有三相电流，我们只需要知道两相电流就能够求解得到另外一相的电流，反映在硬件上，<strong>我们就可以省去一路的电流传感器！节省了成本！</strong></li></ul><h3 id="4-克拉克逆变换"><a href="#4-克拉克逆变换" class="headerlink" title="4.克拉克逆变换"></a>4.克拉克逆变换</h3><img src="https://s2.loli.net/2024/07/25/eYjA7Q6pOFBVcNo.png" alt="image-20240319175252143.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/25/Rbtm5MOlFEc8k1d.png" alt="image-20240319175403342.png" style="zoom:50%;" /><h3 id="5-克拉克变换总结"><a href="#5-克拉克变换总结" class="headerlink" title="5.克拉克变换总结"></a>5.克拉克变换总结</h3><ul><li><p>克拉克变换首先将<strong>三相电流转换成两维度的矢量电流</strong>，因此我们就可以通过<strong>控制两维度的矢量电流来表达三项电流的变换情况</strong>，并且通过等幅值变换，我们就可以将<strong>电流进行消项，之后又可以消去一路Ic，优化处理速度</strong>；</p></li><li><p>而克拉克逆变换的目的是我们通<strong>过需求的两项矢量电流来反向求解三相电流，并且来控制无刷电机驱动。</strong></p></li></ul><h2 id="三、帕克变换"><a href="#三、帕克变换" class="headerlink" title="三、帕克变换"></a>三、帕克变换</h2><h3 id="1-帕克变换基本定义"><a href="#1-帕克变换基本定义" class="headerlink" title="1.帕克变换基本定义"></a>1.帕克变换基本定义</h3><ul><li><p>通过克拉克变换之后，我们就将三相电路降阶至二维矢量电流，但是电流和电机旋转角度的关系是未知的，还需要将这个理论和旋转电机对应起来，也就是<strong>建立电机旋转时的数学模型</strong>，这就是帕克变换的目的。</p></li><li><p>其实整个帕克变换的思路很简单，首先，我们把电机的定子t线圈上固定一个Iα−Iβ坐标系，这时候，我在坐标系的右边放上一个转子，如下图右边所示，如果此时转子被吸引且不动，那么在Iα−Iβ坐标系中就一定有一个Iα和Iβ值是能够对应转子现在的状态的</p></li></ul><p><img src="http://dengfoc.com/dengfoc/shouimage/3.3-2.png" alt="3.3-2"></p><p><img src="http://dengfoc.com/dengfoc/shouimage/3.3-3.png" alt="3.3-3"></p><h3 id="2-帕克变换推导公式"><a href="#2-帕克变换推导公式" class="headerlink" title="2.帕克变换推导公式"></a>2.帕克变换推导公式</h3><ul><li>根据上图，可以推导Iα−Iβ坐标系于Iq−Id坐标系的关系，这也就是帕克变换：</li></ul><p><img src="https://s2.loli.net/2024/07/25/fahwsKAl9RnDUr6.png" alt="image-20240320174459687.png"></p><ul><li>在实际的情况中，电角度是可以根据传感器求解得出，因此，我们只需要控制Iq和Id的电流，就可以控制无刷电机的旋转，而我们可以将Id设置成0，因此，我们只需要一个Iq的电流，就可以控制电机旋转。</li></ul><h2 id="四、推导原理总结"><a href="#四、推导原理总结" class="headerlink" title="四、推导原理总结"></a>四、推导原理总结</h2><img src="http://dengfoc.com/dengfoc/shouimage/3.4-1.png" alt="3.4-1" style="zoom:50%;" /><ul><li><strong>电机想要旋转，就需要三相电流相互作用，而三项电流可以通过克拉克变换转成二维的矢量，而这个二维的矢量通过和转子的电角度建立关系，即可得出控制的电流Iq（Id默认为0），因此我们仅仅只需要通过设定Iq就可以控制电机进行旋转。</strong></li></ul><h2 id="五、电压形式转换"><a href="#五、电压形式转换" class="headerlink" title="五、电压形式转换"></a>五、电压形式转换</h2><ul><li>因为单片机的控制都是<strong>基于电压进行控制</strong>，包括PWM的控制，也是通过控制电压进行设定，因此我们需要将电流转换成电压形式，<strong>而电压和电流的转换可以直接等于，因为等号两边都需要除以电阻，可以直接消项。</strong></li></ul><img src="https://s2.loli.net/2024/07/25/GQ3qP7uYbaWCotK.png" alt="image-20240320180833702.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/25/ZwqigGLHyDB9tFb.png" alt="image-20240320181038012.png" style="zoom:50%;" /><h2 id="六、电角度于机械角度"><a href="#六、电角度于机械角度" class="headerlink" title="六、电角度于机械角度"></a>六、电角度于机械角度</h2><img src="https://s2.loli.net/2024/07/25/IqfPkovwQDlSTR9.png" alt="image-20240320182308979.png" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/25/76QqI34TyP5rozm.png" alt="image-20240320182250898.png" style="zoom:50%;" /><ul><li><p><strong>极对数：是N极和S极的对数数量</strong></p></li><li><p><strong>电角度：电角度是定子电流矢量与转子磁极矢量之间的夹角</strong></p></li><li><p><strong>机械角度：电机旋转一圈的空间几何角度，旋转一圈为360度</strong></p></li><li><p>如果只是刚刚的一级对电机，那么的机械角度转一圈，相位的一个周期是能够和机械角度一一对应的，此时电角度&#x3D;机械角度；但是，如果是多级电机，那么机械角度转一圈，相位的周期可能是很多个。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无刷电机控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制工程学习笔记</title>
    <link href="/YYang.github.io/2024/01/26/20240201ZYY-%E6%8E%A7%E5%88%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/YYang.github.io/2024/01/26/20240201ZYY-%E6%8E%A7%E5%88%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="控制工程学习笔记"><a href="#控制工程学习笔记" class="headerlink" title="控制工程学习笔记"></a>控制工程学习笔记</h1><ul><li>【学习路径】动力学方程-拉普拉斯变换-PID-卡尔曼滤波-bode+奈奎斯特图</li></ul><h2 id="1-学习资料"><a href="#1-学习资料" class="headerlink" title="1 学习资料"></a><strong>1 学习资料</strong></h2><ul><li>【怎么学习经典控制（结合MATLAB）】<a href="https://zhuanlan.zhihu.com/p/266048048">https://zhuanlan.zhihu.com/p/266048048</a></li><li>【物理量解释】<a href="https://blog.csdn.net/qq_38422317/article/details/108460482">转动惯量到底是个什么物理量_转动惯量类比-CSDN博客</a></li><li>【常用的微分，求导和积分公式大总结】<a href="https://blog.csdn.net/wfei101/article/details/82431442">数学之美：常用的微分，求导和积分公式大总结_微积分求导公式-CSDN博客</a></li><li>【倒立摆建模控制系统设计】<a href="https://blog.csdn.net/qq_42731705/article/details/122464642">线性系统大作业——1.一阶倒立摆建模与控制系统设计_一阶倒立摆系统的建模仿真与控制-CSDN博客</a></li><li>【小车动态模型设计Matlab】<a href="https://space.bilibili.com/1134403370/video">J_H_Li投稿视频-J_H_Li视频分享-哔哩哔哩视频 (bilibili.com)</a></li><li>【如何使用Typora编辑数学公式】[如何使用Typora编辑数学公式](<a href="https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=%E6%89%93%E5%BC%80Typora%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9D%97">https://www.cnblogs.com/YanQing1998/p/10986911.html#:~:text=打开Typora选择数学模块</a> 点击“段落”—&gt;“公式块”,快捷键Ctrl%2BShift%2Bm 在两个%24中间直接编辑公式)</li><li>【由拉普拉斯变换到传递函数】<a href="https://zhuanlan.zhihu.com/p/146769901">由拉普拉斯变换到传递函数 - 知乎 (zhihu.com)</a></li><li>【如何给文科生解释傅里叶变换】<a href="https://zhuanlan.zhihu.com/p/48305950">如何给文科生解释傅里叶变换？ - 知乎 (zhihu.com)</a></li><li>【超级直观！！！】<a href="https://zhuanlan.zhihu.com/c_1041689010053341184">直观の数学 - 知乎 (zhihu.com)</a></li><li>【一阶倒立摆的PID控制和LQR控制】<a href="https://zhuanlan.zhihu.com/p/54071212">一阶倒立摆的PID控制和LQR控制 - 知乎 (zhihu.com)</a></li><li>【拉普拉斯变换】<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2#">拉普拉斯变换 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li>【LQR算法】<a href="https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1">https://www.bilibili.com/video/BV1Ng4y1V7JQ?p=1</a></li><li>【simulink快捷键】<a href="https://blog.csdn.net/booksyhay/article/details/88129359">Simulink建模与仿真学习笔记之常用快捷操作（快捷键）_simulink快捷键-CSDN博客</a></li></ul><p><img src="https://s2.loli.net/2024/07/25/K2CbOEa8XyjN9Io.png" alt="image-20240131111616891.png"></p><h2 id="2-动力学方程求解"><a href="#2-动力学方程求解" class="headerlink" title="2 动力学方程求解"></a>2 动力学方程求解</h2><h3 id="2-1-什么是动力学方程"><a href="#2-1-什么是动力学方程" class="headerlink" title="2.1 什么是动力学方程"></a>2.1 什么是动力学方程</h3><ul><li>动力学方程（Differential Equations of Motion），也称为运动方程，是描述物体运动的数学方程。这些方程通常是微分方程，用来描述物体的位置、速度、加速度等随时间的变化关系。<strong>动力学方程是经典力学的基础，它们揭示了物体受到的力和运动状态之间的关系。</strong></li></ul><h3 id="2-2-建立倒立摆动力学方程步骤"><a href="#2-2-建立倒立摆动力学方程步骤" class="headerlink" title="2.2 建立倒立摆动力学方程步骤"></a>2.2 建立倒立摆动力学方程步骤</h3><h4 id="①牛顿第二定律"><a href="#①牛顿第二定律" class="headerlink" title="①牛顿第二定律"></a><strong>①牛顿第二定律</strong></h4><ul><li><strong>【确定世界坐标】</strong>世界坐标设立不同，求解结果不同</li><li><strong>【确定反馈量、控制量和控制目标】</strong>获得需要设置的传感器和控制对象以及实现目标</li><li><strong>【分析系统受力情况】</strong>分析系统位移和转动的情况以及所受外力情况</li><li><strong>【罗列涉及物理量】</strong>罗列所有已知的量，并确定质心</li><li><strong>【分析受力情况】</strong>根据位移和转动情况，列各个子系统的受力</li><li><strong>【合并公式求出动力学方程】</strong>合并子系统受力，求出总系统的动力学方程</li></ul><h4 id="②拉格朗日定理"><a href="#②拉格朗日定理" class="headerlink" title="②拉格朗日定理"></a><strong>②拉格朗日定理</strong></h4><ul><li><strong>【确定世界坐标】</strong>世界坐标设立不同，求解结果不同</li><li><strong>【确定反馈量、控制量和控制目标】</strong>获得需要设置的传感器和控制对象以及实现目标</li><li><strong>【分析系统受力情况】</strong>分析系统位移和转动的情况以及所受外力情况</li><li><strong>【罗列涉及物理量】</strong>罗列所有已知的量，并确定质心</li><li><strong>【列举拉格朗日方程】</strong>罗列拉格朗日表达式</li><li><strong>【求解拉格朗日方程】</strong>多少个变量，求解多少个拉格朗日方程，分析所有系统的总动能（由于速度产生的动能，竖直方向也可能存在，除重力势能之外的所有力）、总势能（重力势能），并根据拉格朗日公式进行求解，求出动力学方程</li><li><strong>【合并得出动力学方程】</strong>合并变量式，得到总系统的动力学方程</li></ul><h3 id="2-3-求解案例过程"><a href="#2-3-求解案例过程" class="headerlink" title="2.3 求解案例过程"></a>2.3 求解案例过程</h3><p><img src="https://s2.loli.net/2024/07/25/J3nAMrF8SgCkzZ5.png" alt="image-20240202100715483.png"></p><h4 id="①牛顿第二定律求解"><a href="#①牛顿第二定律求解" class="headerlink" title="①牛顿第二定律求解"></a><strong>①牛顿第二定律求解</strong></h4><p><img src="https://s2.loli.net/2024/07/25/tJMUe8F5PoNnumL.png" alt="image-20240203181633034.png"></p><h4 id="②拉格朗日定理-1"><a href="#②拉格朗日定理-1" class="headerlink" title="②拉格朗日定理"></a><strong>②拉格朗日定理</strong></h4><p><img src="https://s2.loli.net/2024/07/25/2Pg6zReWbKABMTu.png" alt="image-20240203121952572.png"></p><h3 id="2-4-线性化处理"><a href="#2-4-线性化处理" class="headerlink" title="2.4 线性化处理"></a>2.4 线性化处理</h3><p>倒立摆的动力学方程通常是非线性的，但在某些应用中，为了进行控制设计或分析，可以对动力学方程进行线性化。线性化的目的是获得一个简化的线性系统，以便应用线性控制理论。</p><p>小角度近似 sin(<em>θ</em>)≈<em>θ</em> 是一种在角度较小的情况下进行近似的数学技巧，它通常用于简化非线性系统的分析和求解。这个近似的合理性来源于正弦函数在零附近的泰勒级数展开。</p><p><img src="https://s2.loli.net/2024/07/25/VwCkGBTNlHUOQp1.png" alt="image-20240203181307595.png"></p><p><img src="https://s2.loli.net/2024/07/25/EnfWpyGBqP1txgF.png" alt="image-20240203181739601.png"></p><h2 id="3-拉普拉斯变换求传递函数"><a href="#3-拉普拉斯变换求传递函数" class="headerlink" title="3 拉普拉斯变换求传递函数"></a>3 拉普拉斯变换求传递函数</h2><p>拉普拉斯变换是一种数学工具，用于将一个函数从时域（通常是时间域）转换到复频域。拉普拉斯变换的好处之一是它可以将微分方程转换成代数方程，从而简化了问题的求解。</p><p>物理上可实现的信号总有相对应的拉氏变换（根据拉普拉斯的存在定义可得）</p><p>拉普拉斯变换通常更适用于线性系统和线性微分方程。当面对非线性常微分方程时，使用拉普拉斯变换可能会变得更加困难，因为拉普拉斯变换的一些性质和简便性主要基于线性系统的性质，有时可以尝试将非线性问题线性化</p><h3 id="3-1-拉氏变换定义"><a href="#3-1-拉氏变换定义" class="headerlink" title="3.1 拉氏变换定义"></a>3.1 拉氏变换定义</h3><p><img src="https://s2.loli.net/2024/07/25/FzdD1hvwgUOriQf.png" alt="image-20240205132357835.png"></p><h3 id="3-2-拉氏逆变换定义"><a href="#3-2-拉氏逆变换定义" class="headerlink" title="3.2 拉氏逆变换定义"></a>3.2 拉氏逆变换定义</h3><p><img src="https://s2.loli.net/2024/07/25/Ikbf73zKeJ1VLSN.png" alt="image-20240205132336647.png"></p><h3 id="3-3-拉普拉斯各类定理"><a href="#3-3-拉普拉斯各类定理" class="headerlink" title="3.3 拉普拉斯各类定理"></a>3.3 拉普拉斯各类定理</h3><p><img src="https://s2.loli.net/2024/07/25/LnF38Jj7eR1cE6o.png" alt="image-20240205133019691.png"></p><h3 id="3-4-常用拉氏变换公式"><a href="#3-4-常用拉氏变换公式" class="headerlink" title="3.4 常用拉氏变换公式"></a>3.4 常用拉氏变换公式</h3><p><img src="https://s2.loli.net/2024/07/25/O9zh1y8KqlYjbDH.png" alt="image-20240205171104326.png"></p><p><img src="https://s2.loli.net/2024/07/25/8LqcGhTnJNzOPIR.png" alt="image-20240205171210118.png"></p><h3 id="3-5-复频域好处"><a href="#3-5-复频域好处" class="headerlink" title="3.5 复频域好处"></a>3.5 复频域好处</h3><ul><li><p><strong>频率响应分析：</strong> 复频域提供了对系统对不同频率输入信号的响应更清晰的视角。通过分析系统在复频域中的行为，可以得到频率响应信息，即系统对不同频率成分的放大或衰减程度。这对于了解系统的频率特性和选择适当的滤波器或控制器非常有帮助。</p></li><li><p><strong>稳定性分析：</strong> 复频域分析对于评估系统的稳定性至关重要。通过观察系统在复频域中的极点（pole）和零点（zero），可以得知系统的稳定性信息。例如，在控制系统中，稳定性分析可以通过查看系统的极点位置来判断系统的稳定性和相应的性能。</p></li><li><p><strong>传递函数表示：</strong> 复频域中，系统的行为可以通过传递函数（Transfer Function）更简洁地表示。传递函数是输出与输入的拉普拉斯变换之比，对于线性时不变系统，它在复频域提供了对系统的完整描述。</p></li><li><p><strong>频域设计：</strong> 复频域分析对于在设计中选择合适的控制器或滤波器参数非常有用。通过在频域中分析性能要求和系统响应，可以更好地调整系统以满足指定的性能规范。</p></li><li><p><strong>去除时域中的复杂性：</strong> 在复频域中分析系统可能会使分析更简便。例如，复频域分析可以通过拉普拉斯变换将微分方程转换为代数方程，从而减少问题的复杂性。</p></li></ul><h3 id="3-6-案例求解"><a href="#3-6-案例求解" class="headerlink" title="3.6 案例求解"></a>3.6 案例求解</h3><p><img src="https://s2.loli.net/2024/07/25/4LZuYacRPtHSbkW.png" alt="image-20240205191534825.png"></p><h3 id="3-7-传递函数求解"><a href="#3-7-传递函数求解" class="headerlink" title="3.7 传递函数求解"></a>3.7 传递函数求解</h3><p><img src="https://s2.loli.net/2024/07/25/u8FnNmArfQo7HRS.png" alt="image-20240210115216577.png"></p><h2 id="4-知识点总结"><a href="#4-知识点总结" class="headerlink" title="4 知识点总结"></a>4 知识点总结</h2><ul><li><p><strong>【分析力】</strong>小车水平位移、竖直位移，摆杆转动、水平位移、竖直位移</p></li><li><p><strong>【拉格朗日建模】</strong>小车受到外力，摆杆没有受到外力，小车的变量是位移，摆杆的变量是角度，所以一共两个方程，摆杆右边等于零</p></li><li><p><strong>【线性化】</strong>消去三角函数，利用约等假设进行消除</p></li><li><p><strong>【转动惯量定义】</strong>转动惯量（也称为转动惯性、惯性矩）是描述物体对绕轴旋转的难度或惯性程度的物理量。它与物体的质量分布和形状有关，是旋转运动中的重要参量。</p></li><li><p><strong>【势能定义】</strong>势能是物体由于位置而具有的能量，它与物体的位置和相互作用力有关。势能通常用符号 <em>U</em> 表示</p></li><li><p><strong>【动能定义】</strong>动能是物体由于运动而具有的能量，它与物体的质量和速度有关。动能通常用符号 <em>T</em> 表示</p></li><li><p><strong>【系统总动能】</strong>摆杆动能需要考虑竖直方向具有速度的运动，除重力做功之外，支撑力也有做功</p></li><li><p><strong>【转动惯量正反】</strong>顺时针为正、逆时针为副</p></li><li><p>【<strong>线性化处理</strong>】如果两个变量的关系可以通过直线来表示，且满足以下两个条件：1.比例性，变量的变化是成比例的。2.叠加性，两个或多个影响因素的效应可以相加。</p></li><li><p><strong>【傅里叶变换】</strong>傅里叶变换的内涵，就是满足一定条件的函数可以表示成三角函数(正弦和&#x2F;或余弦函数)或者它们的积分的线性组合。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown用法</title>
    <link href="/YYang.github.io/2023/11/30/20231204ZYY-Markdown%E7%94%A8%E6%B3%95/"/>
    <url>/YYang.github.io/2023/11/30/20231204ZYY-Markdown%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown用法"><a href="#Markdown用法" class="headerlink" title="Markdown用法"></a>Markdown用法</h1><ul><li>要写一个好看的文档，格式和各种引用非常重要，Markdown作为开发过程中的记录文件，也是目前应用最广泛的一个格式，因此开篇先分享一下基本用法。</li><li>这边主要分享几种最常规的使用方法，主要有标题、换行、强调、代码块、分割线、链接、图片、表格这8种非常常用的用法，其余请参照<a href="https://markdown.com.cn/">官方网站</a></li></ul><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><ul><li>一级标题：<code># ZYY 1</code></li><li>二级标题：<code>## ZYY 2</code></li><li>三级标题：<code>### ZYY 3</code></li><li>最简单的解释就是，<strong>n个#代表n级标题</strong>，空格之后加上标题就行</li></ul><h2 id="2-换行"><a href="#2-换行" class="headerlink" title="2.换行"></a>2.换行</h2><ul><li>句子末尾加上 <code>&lt;br&gt;</code> 或者 <code>两个空格+Enter键</code><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">example1</span>：<span class="hljs-variable">ZYY</span> &lt;<span class="hljs-variable">br</span>&gt;<br><span class="hljs-variable">example2</span>：<span class="hljs-function"><span class="hljs-title">ZYY</span>(<span class="hljs-variable">Space</span>*<span class="hljs-number">2</span>+<span class="hljs-variable">Enter</span>，括号和汉字自动忽视)</span><br></code></pre></td></tr></table></figure></li><li><strong>最好用的还是2个空格+Enter键</strong>，但是你看不见它到底有没有换行，所以 <code>&lt;br&gt;</code> 这个是比较直观的，但是打字速度就慢了</li></ul><h2 id="3-强调"><a href="#3-强调" class="headerlink" title="3.强调"></a>3.强调</h2><ul><li>粗体（Bold）： <code>**ZYY** 或者 __ZYY__</code></li><li>斜体（Italic）： <code>*ZYY* 或者 _ZYY_</code></li><li>粗斜体： <code>***ZYY*** 或者 ___ZYY___</code><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">example1：ZZZ <span class="hljs-strong">**YYY**</span> YYY  或者ZZZ <span class="hljs-emphasis">__YYY__</span> YYY<br>example2：ZZZ <span class="hljs-strong">*YYY*</span> YYY  或者ZZZ <span class="hljs-emphasis">_YYY_</span> YYY<br>example3：ZZZ <span class="hljs-strong">***YYY**</span>* YYY  或者ZZZ <span class="hljs-emphasis">___YYY__</span>_ YYY<br></code></pre></td></tr></table></figure></li><li>这个没啥特殊要求，两种方法都可以，<strong>但是最好每种符号的前后都加上空格，不然有些会失灵</strong></li></ul><h2 id="4-代码块-and-代码"><a href="#4-代码块-and-代码" class="headerlink" title="4.代码块 and 代码"></a>4.代码块 and 代码</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">代码： ` + ` 单个反引号做开头，单个反引号做结尾，中间就是特殊的代码区<br>代码块：``` + ``` 用三个反引号做开头，三个反引号做结尾，中间就是代码块<br><br>example1： ZZZ `YYY` YYY<br></code></pre></td></tr></table></figure><ul><li>这个代码块挺好用的，<strong>特别是想要强调说一些事情的时候，可以给他框出来</strong>，我上面的所有例子都是用代码块罗列的，清晰明了，代码块不一定写代码</li></ul><h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><ul><li><code>*** 或者 --- 或者 ___</code><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">example1： <span class="hljs-strong">***</span><br>example2： ---<br>example3： <span class="hljs-emphasis">___</span><br></code></pre></td></tr></table></figure></li><li>就会出现一个非常丑的线，<strong>这三根线的类型是一样的，不管用哪个都是一根线</strong></li></ul><h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h2><ul><li>链接： <code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></li><li>直接上网址或者email地址：&lt;链接地址&gt;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">example1</span>：<span class="hljs-selector-tag">ZZZ</span> <span class="hljs-selector-attr">[YYY]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/BraveYiYang) YYY</span><br>example2：ZZZ [YYY](<span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/BraveYiYang &quot;Brave&quot;) YYY</span><br>example3：&lt;<span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/BraveYiYang&gt;</span><br></code></pre></td></tr></table></figure></li><li>这个还是很好用的，中括号里面的是你可以随便定义，然后把你小括号的链接赋值在你中括号的定义里面，小括号的双引号里面是你鼠标放上去，他会显示出来你的小标签</li></ul><h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h2><ul><li>插入图片： <code>[![图片alt](图片链接 &quot;图片title&quot;)](超链接)</code><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">example1：!<span class="hljs-selector-attr">[ZYY]</span>(/ZYY/Z.jpg)<br>example2：!<span class="hljs-selector-attr">[ZYY]</span>(/ZYY/Z<span class="hljs-selector-class">.jpg</span> <span class="hljs-string">&quot;Brave&quot;</span>)<br>example3：<span class="hljs-selector-attr">[![ZYY]</span>(/ZYY/Z<span class="hljs-selector-class">.jpg</span> <span class="hljs-string">&quot;Brave&quot;</span>)](https:<span class="hljs-comment">//github.com/BraveYiYang)</span><br></code></pre></td></tr></table></figure></li><li>这个图片的用处是很多的，我们可以随心所欲的插入图片，<strong>图文并茂</strong></li></ul><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><ul><li>| 表示表格的线，用他来固定列数，几行就是表格的几行，</li><li>— 来定义标题行，而且每一列的 — 数量不一样代表每一列的长度也不一样</li><li>:— 表示左对齐 —: 表示右对齐 :—: 表示居中对齐<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">example1：<br>|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> ----------- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<br>example2：<br>|<span class="hljs-string"> Syntax </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header </span>|<span class="hljs-string"> Title </span>|<br>|<span class="hljs-string"> Paragraph </span>|<span class="hljs-string"> Text </span>|<br>example3：<br>|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<span class="hljs-string"> Test Text     </span>|<br>|<span class="hljs-string"> :---        </span>|<span class="hljs-string">    :----:   </span>|<span class="hljs-string">          ---: </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<span class="hljs-string"> Here&#x27;s this   </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<span class="hljs-string"> And more      </span>|<br></code></pre></td></tr></table></figure></li><li><strong>表格其实不是很常用，但是也是算作是一个基本的使用方法</strong></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>markdown的使用方法其实不难，而且也很容易入门，只不过没有那么直观，但是大家用习惯之后，就非常容易上手，所以鼓励大家多使用，熟能生巧，多练才会掌握的快！</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>路演文书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电气路控制设计</title>
    <link href="/YYang.github.io/2023/11/26/20231204ZYY-%E7%94%B5%E6%B0%94%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/YYang.github.io/2023/11/26/20231204ZYY-%E7%94%B5%E6%B0%94%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="电气路控制设计"><a href="#电气路控制设计" class="headerlink" title="电气路控制设计"></a>电气路控制设计</h1><ul><li><strong>一个简单的气动控制一共分为四大步：</strong><ul><li>第一步是进行<strong>气路仿真</strong>，然后确定气路控制的逻辑性；</li><li>第二步<strong>编写控制程序</strong>，将气路仿真得出的逻辑结果以控制代码的形式进行书写；</li><li>第三步<strong>设计气路控制板</strong>，因为很多电磁阀根本无法直接通过单片机进行驱动，因此我们需要借助外部电源的力量，就需要制作外围电路，来完成小马拉大车的效果；</li><li>第四步进行实际的<strong>气路连接并控制</strong>，连线的话就需要根据之前的仿真图来进行气路的连线，测试当然也是要基于第二步的控制代码来进行；</li></ul></li><li>所以要想做好一个完整的气路控制，这四步少一步不行，不要因为很麻烦而去省略其中一步，当你在排查气路问题的时候，会让你抓狂的</li></ul><h2 id="1-设计需求假设"><a href="#1-设计需求假设" class="headerlink" title="1.设计需求假设"></a>1.设计需求假设</h2><ul><li>示例：现在要设计一个机械臂的抬升，使用了一个双作用气缸，该气缸能够通过控制实现伸长和收缩</li></ul><h2 id="2-气路仿真"><a href="#2-气路仿真" class="headerlink" title="2.气路仿真"></a>2.气路仿真</h2><ul><li>气路仿真最好用的还是FuildSim，这款软件是费斯托公司提供用户进行气路仿真，用法简单，操作容易，因此我这边仿真都是采用了这个软件进行仿真</li><li>构建仿真原理图，这个软件的详细操作请看<strong>FuildSim</strong>专栏帖子，这边不进行详细介绍，下面是我构建的简易气路图，这个气路图里面包含了1个双作用气缸，3个电磁阀，1个气泵，1个节流阀，节流阀的作用是控制气流量来控制气缸伸缩的用时，这里面<strong>我给电磁阀进行了编号，这个编号非常重要，而且后续接线以及编写代码，必须要按这个编号严格进行，减少错误，甚至后续测试的时候，必须在电磁阀上面贴上编号</strong></li></ul><p><img src="https://picss.sunbangyan.cn/2023/11/29/f271e8d8706ef9ac62eaab4025ec81f3.jpeg" alt="气路图"></p><ul><li><p>开始进行仿真，这次的目的是要实现一个双作用气缸的伸长和收缩控制，开始仿真后，得出控制顺序为：</p><ul><li>伸长：打开DCF3，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF3，归为所有电磁阀，达到伸长控制<strong>（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）</strong>；</li></ul><p><img src="https://picdm.sunbangyan.cn/2023/11/29/f3526be0094237b34f961ecf2d2b9e04.jpeg" alt="气缸伸长"></p><ul><li>缩回：打开DCF2，保持通路，打开DCF1，实现进气，进行延时，以达到所需要求，达到固定位置后，关闭DCF1，关闭DCF2，归为所有电磁阀，达到伸长控制<strong>（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）</strong>；</li></ul><p><img src="https://picst.sunbangyan.cn/2023/11/29/6b7f958fbe983a0f05d3e9c2ad4252c3.jpeg" alt="气缸缩回"></p></li><li><p>完成仿真，得出想要的结果，之后开始根据结果进行代码的设计</p></li></ul><h2 id="3-代码设计"><a href="#3-代码设计" class="headerlink" title="3.代码设计"></a>3.代码设计</h2><ul><li>代码设计采用最简单的Arduino控制，设计的过程也很简单，跟点灯一模一样，按照仿真的结果进行顺序点灯，即可达到效果</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> DCF1=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> DCF2=<span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> DCF3=<span class="hljs-number">7</span>;<br><span class="hljs-comment">//引脚的定义根据实际连接电磁阀的需求来设计</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">pinMode</span>(DCF1,<span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(DCF2,<span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(DCF3,<span class="hljs-literal">OUTPUT</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UP</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//气缸伸长（ DCF3 - DCF1 - 5秒 - DCF1 - DCF3 ）</span><br>  <span class="hljs-built_in">digitalWrite</span>(DCF3,<span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//延时的目的防止电磁阀响应过快</span><br>  <span class="hljs-built_in">digitalWrite</span>(DCF1,<span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">5000</span>);<span class="hljs-comment">//延时的目的为了能够控制进入气流量，达到控制位置效果</span><br>  <span class="hljs-built_in">digitalWrite</span>(DCF1,<span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(DCF3,<span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Down</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//气缸缩短（ DCF2 - DCF1 - 5秒 - DCF1 - DCF2 ）</span><br>  <span class="hljs-built_in">digitalWrite</span>(DCF2,<span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(DCF1,<span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">5000</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(DCF1,<span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(DCF2,<span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">UP</span>();<br>  <span class="hljs-built_in">Down</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里面的代码逻辑是跟上面仿真的结果一样，因此环环相扣，不能因为怕麻烦，缺失了其中一个环节</li></ul><h2 id="4-电磁阀控制"><a href="#4-电磁阀控制" class="headerlink" title="4.电磁阀控制"></a>4.<a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=36262310020&_u=t2g8gqc420ea">电磁阀</a>控制</h2><ul><li>因为目前所用的电磁阀基本都是12V和24V的，所以要想能够利用单片机的3.3V输出的话是不可能的，因此就需要用我们的单片机的3.3V搭配上一个只能开关NMOS管来实现小电压控制大电压的效果，当然这里面还需要进行外部高电压的接入，以下是我们会用到的元器件以及他的功能<ul><li><strong><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc49fb1&id=670446268383&spm=a1z09.2.0.0.32c42e8dCPUvWl">ESP32</a>：</strong>这个最简单理解，我们代码的承载体，以及整个机器人控制的设备，为啥选择ESP32，因为他简单而且比Arduino小，还集成WIFI功能</li><li><strong><a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.32c42e8dCPUvWl&id=672833563616&_u=t2g8gqc4b0ae">24V&#x2F;12V电源</a>：</strong>一部分用于驱动电磁阀的通断，借助外部电源的电压来实现驱动，一部分用于ESP32的供电</li><li><strong><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc495fe&id=582430989377&spm=a1z09.2.0.0.32c42e8dCPUvWl">DC-DC降压模块</a>：</strong>利用输入的高电压，转为5V的稳压电源，供电给ESP32，来保证一个电源即可实现多种利用</li><li><strong><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc44f16&id=14478416081&spm=a1z09.2.0.0.32c42e8dCPUvWl">NMOS管（A3400）</a>：</strong>用来充当开关的作用，G极连接单片机引脚，用于接收信号来实现控制，D极连接24V&#x2F;12V电源的正极，S极连接接地端，来实现电路的导通</li><li><strong><a href="https://item.taobao.com/item.htm?spm=a21n57.1.0.0.3d58523cFi5cOt&id=583531277832&ns=1&abbucket=19#detail">光耦模块(LTV-247)</a>：</strong>利用光电隔离，实现高低电压的连接处隔离，防止大电流倒灌，损坏ESP32，光耦模块最好只用三组，四组的功率太大，容易损坏光耦模块，光耦模块的输出接地端，需要加一个保护电阻560欧，输出端也需要加一个保护电阻100K欧</li><li><strong><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc49a07&id=13860351935&spm=a1z09.2.0.0.32c42e8dCPUvWl">LED灯（0603）</a>：</strong>用来提示电源是否接入，需要添加一个保护电阻100K</li><li><strong><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc4e83f&id=18691413288&spm=a1z09.2.0.0.32c42e8dCPUvWl">船型开关</a>：</strong>用来开关控制电源的输入，减少插拔电源的麻烦</li><li><strong><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc448e3&id=13300685584&spm=a1z09.2.0.0.32c42e8dCPUvWl">快速插拔二端子（XH-2.54-2P）</a>：</strong>用来快速插拔电磁阀，能够实现电池阀的快速的接入</li><li><a href="https://detail.tmall.com/item.htm?_u=t2g8gqc4ad83&id=16520506238&spm=a1z09.2.0.0.32c42e8dCPUvWl"><strong>DC插头母头（DC-005）</strong></a>：</li></ul></li><li><strong>电路图请看目录下的QL-EDA.pdf文件</strong></li><li>以上的是整体所需的元器件以及购买链接，正常来说都是以上的类型，然后需要注意一个问题，<strong>就是整个电路，必须低电压一个接地，高电压一个接地，不允许出现共地情况，防止出现烧坏的情况，整体电路，导通24V&#x2F;12V的PCB电路宽度不低于0.8mm，导通常规5V&#x2F;3.3V的电路宽度不低于0.5mm</strong></li></ul><h2 id="5-气路连接并控制"><a href="#5-气路连接并控制" class="headerlink" title="5.气路连接并控制"></a>5.气路连接并控制</h2><ul><li><p>做到这一步的时候，基本上已经完成差不多了，这个时候只需要对照第一步进行连线，这边需要强调的是电磁阀的1、2、3口是具体指那几个口，图片会给予详细解答，请查看</p><ul><li>费斯托电磁阀（24V），具备高速开关能力</li></ul><p><img src="https://picdm.sunbangyan.cn/2023/11/29/2be07b3e5d478d569f147c98f91da10d.jpeg" alt="费斯托电磁阀"></p><ul><li>海德斯电磁阀（12V），小巧，但是不具备高速开关能力</li></ul><p><img src="https://picdm.sunbangyan.cn/2023/11/29/a611906e4e773fa55356787357dcf618.jpeg" alt="海德斯电磁阀"></p><ul><li>转接头，仅仅列举几个</li></ul><p>![TLTBHDFZOG4_{&#96;U(H9GL6MR](<a href="https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![%E5%9B%9B%E9%80%9A%E8%BD%AC%E6%8E%A5%E5%A4%B4](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)">https://picss.sunbangyan.cn/2023/11/29/2e62fc7686022bc47f98f1fe186cf7df.jpeg)![四通转接头](https://picss.sunbangyan.cn/2023/11/29/0095a70ac81fa88a189f0f66f78b101b.jpeg)</a></p><ul><li>气动调节阀</li></ul><p><img src="https://picst.sunbangyan.cn/2023/11/29/8704c328c58619d6fb920f54f5bf54f2.jpeg" alt="气动调节阀"></p><ul><li>稳压阀</li></ul><p><img src="https://picst.sunbangyan.cn/2023/11/29/9f9500dda6401faee73322dc803ee935.jpeg" alt="稳压阀"></p></li><li><p>以上就是电气路设计的全过程，这里面的经验成分居多，需要不断的实操，不断的学习，才能够更深的掌握气动方面的知识</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何制作一份优秀的路演PPT</title>
    <link href="/YYang.github.io/2023/11/10/20231204ZYY-%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%BB%BD%E4%BC%98%E7%A7%80%E7%9A%84%E8%B7%AF%E6%BC%94PPT/"/>
    <url>/YYang.github.io/2023/11/10/20231204ZYY-%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%BB%BD%E4%BC%98%E7%A7%80%E7%9A%84%E8%B7%AF%E6%BC%94PPT/</url>
    
    <content type="html"><![CDATA[<h1 id="如何制作一份优秀的路演PPT"><a href="#如何制作一份优秀的路演PPT" class="headerlink" title="如何制作一份优秀的路演PPT"></a>如何制作一份优秀的路演PPT</h1><h3 id="1-PPT的基本思路"><a href="#1-PPT的基本思路" class="headerlink" title="1.PPT的基本思路"></a>1.PPT的基本思路</h3><ul><li><h4 id="这个比赛的定位"><a href="#这个比赛的定位" class="headerlink" title="这个比赛的定位"></a><strong>这个比赛的定位</strong></h4><ul><li>商业比赛还是创新比赛，这两个是完全不一样的思路和逻辑，不能什么比赛都同一份PPT，需要根据评委的胃口来选择</li><li><strong>评分细则，一定一定一定要详读评分细则，因为只有详细的阅读评分细则之后，你才能嗅到这个比赛的侧重点是啥，你的PPT必须要紧贴这个比赛的侧重点，评分细则的每一个字都要想清楚它在我们PPT里面如何体现</strong></li><li>如果是商业比赛，技术含量要降到4-5页，因为评委听不懂你讲的任何技术，要把技术转化成服务，<strong>总结来说就是，你的产品能提供啥服务，能给用户提供啥功能，这些功能有啥用，效果咋样，咋卖钱，商业比赛要讲赚钱，怎么用最低的成本赚最多的钱</strong></li><li>如果是创新比赛，几乎都是技术讲解，因为评委是专家，他要看你这个项目的新意、创意，跟国内外比起来，你们项目新奇在哪里，技术点突破在哪里，突破的效果怎么样，<strong>总结来说就是，你的项目创新点在哪，技术突破情况咋样，创新比赛要讲学术，你的理论基础、技术基础如何突破，偏学术</strong></li></ul></li><li><h4 id="解决的社会痛点是啥"><a href="#解决的社会痛点是啥" class="headerlink" title="解决的社会痛点是啥"></a><strong>解决的社会痛点是啥</strong></h4><ul><li><strong>项目背景：</strong>你这个项目的起源是啥，为啥要做这个项目，做他的目的是啥，其中<strong>重点是：讲清楚、跟随政策、量化数据、提供依据，明确方向</strong>，但是切忌，项目的背景不要脱离实际，不要太离谱，比如郑州某大学想要自己研发光刻机，这只会给别人觉得你在骗人，但是也别出现太泛的情况，比如想要研发一种设备能够治疗所有疾病，没有针对点，没有细分领域。</li><li><strong>社会痛点：</strong>讲完你的项目起源，就要开始说清楚目前市面上的痛点是啥，这个痛点痛不痛，不要解决一个可有可无的社会痛点，那别人凭什么为你买单，<strong>这个痛点要讲的很透彻，就是一下子让别人感觉，你这个项目想法很好，新意很好</strong></li></ul></li><li><h4 id="你的解决方案"><a href="#你的解决方案" class="headerlink" title="你的解决方案"></a><strong>你的解决方案</strong></h4><ul><li><strong>项目概述：</strong>第一时间告诉所有评委，针对这个痛点问题，你的完整解决方案是什么，<strong>如果是商业比赛，第一时间要告诉评委，你能提供什么服务</strong>，比如提供康复训练服务和康复评估服务，<strong>如果是创新比赛，第一时间要告诉评委你这个项目的整体情况，以及你的创新点</strong>，你的与众不同点在哪，比如采用柔顺康复、采用多模态康复评估等等，不同的比赛需要不同的方式</li><li>解决方案的整体介绍的方式有挺多种的，<strong>偏向商业的就直接展示你这个产品</strong>，然后告诉他们，这个产品有啥用，有哪些功能，<strong>偏向创新的就需要展示这个项目整套技术流程</strong>，技术流程里面的创新点如何体现，<strong>这一部分是整个PPT的核心，需要非常精准有效的让别人第一时间知道你在做什么，你做的东西是啥，概括性很强，整体性很强，这里面不是简单把所有东西凑一起说，而是应该以一个整体思维，把每一个部分串联起来，介绍一个整体的东西</strong></li></ul></li><li><h4 id="怎么证明你的方案比别人好"><a href="#怎么证明你的方案比别人好" class="headerlink" title="怎么证明你的方案比别人好"></a><strong>怎么证明你的方案比别人好</strong></h4><ul><li><strong>项目技术突破：</strong>这部分就是讲你的技术有多牛逼，这块偏向现有技术，但是你的技术比别人精度更高、效果更好等等，但是也一定要注意，<strong>商业比赛不要讲很深的理论</strong>，评委听不懂，你要用他听得懂的话语去讲最牛逼的事，<strong>创新比赛也不能讲的太底层</strong>，不然评委老师会困，要讲新的点，吸引住他们的点，这里面<strong>必须要图文并茂，用实际成果证明你的数据可靠，用数据证明你牛逼</strong></li><li><strong>项目新思路：</strong>项目的新思路是另一个方面，就是别人走常规的道路，而你却实现弯道超车，用<strong>更简单的思路解决问题</strong>，类似这种的话一般会很感兴趣，而且<strong>新思路的话不一定要做的很深，但是要说明你这个思路是实际可靠的，而不是天马行空</strong></li><li><strong>竞品分析：</strong>这个也是很好证明你比别人厉害的，同类型对比，你功能比他们多，价格比他们低等等，都会是你产品的优势，商业方面的话就讲功能、服务、价格优势，创新方面的话就讲技术突破、思路突破、效率等等，但是<strong>切忌不要吹太过分了，到时候用很低的价格，然后功能却比别人强很多，大家都不是傻子，难道只有你想得到，所以一旦太过分了，就变得很假了</strong></li></ul></li><li><h4 id="你的产品怎么卖"><a href="#你的产品怎么卖" class="headerlink" title="你的产品怎么卖"></a><strong>你的产品怎么卖</strong></h4><ul><li><strong>产品市场：这个就告诉别人，你这个行业赚不赚钱，</strong>如果行业很小，有可能投入都比你产出还大，那就没啥意义了，如果行业超级大，那会不会竞争对手也非常多，那你怎么脱颖而出，分析市场<strong>主要就是告诉评委，我给你画的饼有多大，心不心动</strong></li><li><strong>商业逻辑：很简单的道理，你怎么赚到别人的钱</strong>，要考虑成本多少、客户是谁、供应商是谁、合作对象是谁、销售渠道有哪些、能提供哪些盈利服务、短期怎么推广、中期怎么推广、长期怎么推广、怎么打造产品的品牌效益等等，<strong>要真实考虑到卖东西的各个方面，越详细越深入越好，而且要形成一个闭环，丢掉学生思维，转向商人思维，把自己当成一个老板，这个产品怎么进行打造</strong>，可以学习国内外知名企业的商业逻辑，赚设备费用还是赚服务费用还是其他更新颖的赚钱思路</li><li><strong>商业创新：</strong>这块是一个能够脱颖而出的地方，商业也是有创新点的，<strong>很多产品能够发家致富，产品的创新点反而是其次，更重要的是营销手段，商业创新</strong>，比如共享单车、跑腿服务等等，这些都是纯靠商业模式活下来，技术根本不是核心，商业创新也有很多方面，比如我们有哪些独特优势、哪些特有资源，怎么利用这些去突围，我们常说的产学研合作就是这里面的一个创新，只不过太老了，还有产品生态，像小米或者苹果，他们其实不是卖手机，而是买一个能够买他们设备的设备而已，构建一套全生态，这样能够不断地、长期的盈利，所以，<strong>我们可以想想，我们怎么卖得更好</strong></li></ul></li></ul><h3 id="2-PPT的基本框架"><a href="#2-PPT的基本框架" class="headerlink" title="2.PPT的基本框架"></a>2.PPT的基本框架</h3><ul><li><strong>常规的商业PPT主要包含这几大方面</strong><ul><li>1.解决的社会痛点是啥：<strong>项目背景、市场痛点</strong></li><li>2.你的解决方案：<strong>项目简介、技术架构</strong></li><li>3.怎么证明你的方案比别人好：<strong>项目创新点（一般都是3点，最多不超过4点），竞品分析</strong></li><li>4.你的产品怎么卖：<strong>商业模式、成本分析、营销模式、客户对象、盈利预测、产品生态</strong></li><li>5.证明价值：<strong>测试情况、落地情况、社会报道、商业合作、专家点评、知识产权、论文支撑、行业标准</strong>等等</li><li>6.团队合作：<strong>指导老师团队、开发团队</strong></li></ul></li></ul><h3 id="3-PPT制作过程中的细节"><a href="#3-PPT制作过程中的细节" class="headerlink" title="3.PPT制作过程中的细节"></a>3.PPT制作过程中的细节</h3><ul><li><strong>配色正常</strong>，不要太晃眼睛，<strong>最好三配色，全文基本就三种颜色（推荐的是白色背景搭配藏蓝色、红色，重点部分用红色突出，暗系背景搭配白色和亮黄色，重点部分用亮黄色突出）</strong>，不然会感觉花里胡哨的，字体一定不要全文太亮、或者全文太暗，遇到重点或者你想要强调的地方，一定用亮色突出，让别人第一目光就聚焦到你想要让他看的地方，<strong>学会管理评委的目光</strong></li><li><strong>微软雅黑字体，最好都采用微软雅黑加粗，字体厚实，观看清晰，不会给人感觉看不清、或者太乱、太细</strong>，楷体宋体都不好看，太细，给人感觉弱不禁风的样子</li><li><strong>背景配色</strong>，<strong>不要纯白背景、最好背景后面有点很淡的一些东西，感觉不是很空</strong>，米白色会更好看，也不要纯黑背景，太黑暗，给人非常压抑，<strong>如果想要偏暗系背景的话，采用藏蓝色然后搞一个黑色透明套上去</strong>，我会提供几个背景模板</li><li><strong>方块</strong>，PPT常用的就是各种方块，<strong>方块一定一定一定要无边框，不然非常的难看</strong>，想要在边框里面加上自己想要的字体，<strong>不建议新建文本框，而是直接在方块里面编辑，不然后续想改的时候会非常麻烦，非常的累</strong></li><li><strong>设计器</strong>，微软的PPT自带设计器，有时候能够解决你非常多的麻烦，又好看又快速</li><li><strong>图片版PPT，一定不要另存出来图片版，图片的质量非常的差，一定要一页一页播放，截图，然后粘贴在新的PPT里面</strong>，遇到动图的时候，直接复制过去就行，如果遇到覆盖的时候，就做两页或者更多页</li><li><strong>切换方式，不要任何切换方式，所有PPT都不要任何切换方式</strong>，评委会头晕，看的真的非常晕，而且而且，遇到垃圾电脑，你的动画会比老太太还慢，会出现各种bug，如果是线上的话，直接死亡，你觉得很快速，但是网速延迟非常高，别人那边就是一卡一卡的，印象分非常低</li></ul>]]></content>
    
    
    <categories>
      
      <category>路演文书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献检索</title>
    <link href="/YYang.github.io/2023/10/26/20231204ZYY-%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/"/>
    <url>/YYang.github.io/2023/10/26/20231204ZYY-%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="文献检索"><a href="#文献检索" class="headerlink" title="文献检索"></a>文献检索</h1><ul><li><h3 id="翻译软件"><a href="#翻译软件" class="headerlink" title="翻译软件"></a>翻译软件</h3><ul><li><p>Mate Translate（网站翻译插件）</p></li><li><p>搜狗文档翻译</p></li><li><p>有道学生认证翻译</p></li></ul></li><li><h3 id="检索技巧"><a href="#检索技巧" class="headerlink" title="检索技巧"></a>检索技巧</h3><ul><li><p>关键词+literature review（综述后缀搜索）</p></li><li><p>知网摘要批量导出</p></li></ul></li><li><h3 id="资源网站"><a href="#资源网站" class="headerlink" title="资源网站"></a>资源网站</h3><ul><li><p><a href="https://www.ligongku.com/invite/28243">资源下载 - 理工酷 (ligongku.com)</a>（资料下载）</p></li><li><p><a href="http://www.chinapower.com.cn/">电力网 - 最具影响力的电力行业门户网站 (chinapower.com.cn)</a>（资料下载）</p></li><li><p><a href="https://www.in-en.com/">国际能源网-能源全产业链服务平台，服务全球能源企业！ (in-en.com)</a>（资料下载）</p></li><li><p><a href="https://www.mittrchina.com/news">麻省理工科技评论-发现改变世界的新兴科技 (mittrchina.com)</a>（前沿科技网站）</p></li><li><p><a href="https://stats.oecd.org/">OECD Statistics</a>（数据网站）</p></li></ul></li><li><h3 id="关键词检索引擎"><a href="#关键词检索引擎" class="headerlink" title="关键词检索引擎"></a>关键词检索引擎</h3><ul><li><p>学校WEBVPN：<a href="https://webvpn.zzuli.edu.cn/login">WEBVPN系统 (zzuli.edu.cn)</a></p></li><li><p><a href="https://www.paperdigest.org/">Paper Digest – Sci-Tech knowledge graph &amp; text analysis platform for scientific literature tracking, summarization and search</a>（文献检索引擎）</p></li><li><p><a href="https://zenodo.org/">Zenodo - Research. Shared.</a>（文献检索引擎）</p></li><li><p><a href="https://link.springer.com/">Home - Springer</a>（文献检索引擎）</p></li><li><p><a href="https://www.proquest.com/">ProQuest | 更好的研究，更好的学习，更好的见解。</a>（文献检索引擎）</p></li><li><p><a href="https://ac.scmor.com/">谷歌学术镜像_Google学术搜索导航@思谋学术 (scmor.com)</a>（谷歌学术镜像）</p></li><li><p><a href="http://www.chongbuluo.cn/">虫部落快搜-Google 学术搜索 - 快搜 - 谷歌搜索 (chongbuluo.cn)</a>（检索引擎大合集）</p></li></ul></li><li><h3 id="文献检索引擎"><a href="#文献检索引擎" class="headerlink" title="文献检索引擎"></a>文献检索引擎</h3><ul><li><a href="https://www.scidown.cn/">Sci论文期刊检索|文献检索求助互助 - Sci-Hub|Scidown</a>（文献检索引擎）</li></ul></li><li><h3 id="AI检索"><a href="#AI检索" class="headerlink" title="AI检索"></a>AI检索</h3><ul><li><p><a href="https://www.connectedpapers.com/">Connected Papers | Find and explore academic papers</a>（强烈推荐，AI关联文献）</p></li><li><p><a href="https://www.paper-digest.com/">Paper Digest (paper-digest.com)</a>（AI读论文）</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
